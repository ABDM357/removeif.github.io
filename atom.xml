<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>辣椒の酱</title>
  
  <subtitle>尚未执佩剑，转眼即江湖</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://removeif.github.io/"/>
  <updated>2019-09-05T14:05:20.513Z</updated>
  <id>https://removeif.github.io/</id>
  
  <author>
    <name>辣椒の酱</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发扣款相关问题</title>
    <link href="https://removeif.github.io/2019/09/05/%E5%B9%B6%E5%8F%91%E6%89%A3%E6%AC%BE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html"/>
    <id>https://removeif.github.io/2019/09/05/并发扣款相关问题.html</id>
    <published>2019-09-05T13:40:53.000Z</published>
    <updated>2019-09-05T14:05:20.513Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>继续解答星球水友提问。<br>沈老师，我们有个业务，同一个用户在并发“查询，逻辑计算，扣款”的情况下，余额可能出现不一致，请问有什么优化方法么？<br><a id="more"></a></p></blockquote><h2 id="并发扣款，如何保证数据的一致性？"><a href="#并发扣款，如何保证数据的一致性？" class="headerlink" title="并发扣款，如何保证数据的一致性？"></a>并发扣款，如何保证数据的一致性？</h2><p><strong>扣款的业务场景是怎样的？</strong></p><p>用户购买商品的过程中，要对余额进行查询与修改，大致的业务流程如下：</p><p><strong>第一步</strong>，从数据库查询用户现有余额：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> money <span class="hljs-keyword">FROM</span> t_yue <span class="hljs-keyword">WHERE</span> uid=$uid</span><br></pre></td></tr></table></figure></p><p>不妨设查询出来的$old_money=100元。</p><p><strong>第二步</strong>，业务层实施业务逻辑计算，比如：<br>（1）先查询购买商品的价格，例如是80元；<br>（2）再查询产品是否有活动，以及活动折扣，例如是9折；<br>（3）比对余额是否足够，足够时才往下走；</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span>($old_money&gt; <span class="hljs-number">80</span>\*<span class="hljs-number">0.9</span>)&#123;    </span><br><span class="line">    $new_money=$old_money-<span class="hljs-number">80</span>\*<span class="hljs-number">0.9</span>=<span class="hljs-number">28</span>;</span><br><span class="line">   &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"Not enough minerals"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，将数据库中的余额进行修改。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> t_yue <span class="hljs-keyword">SET</span> money=new_money <span class="hljs-keyword">WHERE</span> uid=uid;</span><br></pre></td></tr></table></figure><p>在并发量低的情况下，这个流程没有任何问题，原有金额100元，购买了80元的九折商品（72元），剩余28元。</p><p><strong>同一个用户，并发扣款可能出现什么问题？</strong></p><p>在分布式环境中，如果并发量很大，这种“查询+修改”的业务有一定概率出现数据不一致。</p><p>极限情况下，可能出现这样的异常流程：</p><p><strong>步骤一</strong>，业务1和业务2并发查询余额，是100元。</p><p><em>画外音：这些并发查询，是在不同的站点实例/服务实例上完成的，进程内互斥锁肯定解决不了。</em><br><strong>步骤二</strong>，业务1和业务2并发进行逻辑计算，算出各自业务的余额，假设业务1算出的余额是28元，业务2算出的余额是38元。</p><p><strong>步骤三</strong>，业务1对数据库中的余额先进行修改，设置成28元。</p><p>业务2对数据库中的余额后进行修改，设置成38元。</p><p>此时异常出现了，原有金额100元，业务1扣除了72元，业务2扣除了62元，最后剩余38元。<br><em>画外音：假设业务1先写回余额，业务2再写回余额。</em></p><p><strong>常见的解决方案？</strong></p><p>对于此案例，同一个用户，并发扣款时，有小概率会出现异常，可以对每一个用户进行分布式锁互斥，例如：在redis/zk里抢到一个key才能继续操作，否则禁止操作。</p><p>这种<strong>悲观锁</strong>方案确实可行，但要引入额外的组件(redis/zk)，并且会降低吞吐量。</p><p><strong>对于小概率的不一致，有没有乐观锁的方案呢？</strong></p><p>对并发扣款进行进一步的分析发现：</p><p>（1）业务1写回时，旧余额100，这是一个初始状态；新余额28，这是一个结束状态。理论上只有在旧余额为100时，新余额才应该写回成功。</p><p>而业务1并发写回时，旧余额确实是100，理应写回成功。</p><p>（2）业务2写回时，旧余额100，这是一个初始状态；新余额28，这是一个结束状态。理论上只有在旧余额为100时，新余额才应该写回成功。</p><p>可实际上，这个时候数据库中的金额已经变为28了，所以业务2的并发写回，不应该成功。</p><p><strong>如何低成本实施乐观锁？</strong></p><p>在set写回的时候，加上初始状态的条件compare，只有初始状态不变时，才允许set写回成功，Compare And Set（CAS），是一种常见的降低读写锁冲突，保证数据一致性的方法。</p><p><strong>此时业务要怎么改？</strong></p><p>使用CAS解决高并发时数据一致性问题，只需要在进行set操作时，compare初始值，如果初始值变换，不允许set成功。</p><p>具体到这个case，只需要将：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> t_yue <span class="hljs-keyword">SET</span> money=$new_money <span class="hljs-keyword">WHERE</span> uid=$uid;</span><br></pre></td></tr></table></figure></p><p>升级为：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> t_yue <span class="hljs-keyword">SET</span> money=$new_money <span class="hljs-keyword">WHERE</span> uid=$uid <span class="hljs-keyword">AND</span> money=$old_money</span><br></pre></td></tr></table></figure></p><p>并发操作发生时：</p><p>业务1执行：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> t_yue <span class="hljs-keyword">SET</span> money=<span class="hljs-number">28</span> <span class="hljs-keyword">WHERE</span> uid=$uid <span class="hljs-keyword">AND</span> money=<span class="hljs-number">100</span>;</span><br></pre></td></tr></table></figure></p><p>业务2执行：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> t_yue <span class="hljs-keyword">SET</span> money=<span class="hljs-number">38</span> <span class="hljs-keyword">WHERE</span> uid=$uid <span class="hljs-keyword">AND</span> money=<span class="hljs-number">100</span>;</span><br></pre></td></tr></table></figure></p><p>这两个操作同时进行时，只可能有一个执行成功。</p><p><strong>怎么判断哪个并发执行成功，哪个并发执行失败呢？</strong></p><p>set操作，其实无所谓成功或者失败，业务能通过affect rows来判断：</p><ul><li>写回成功的，affect rows为1</li><li>写回失败的，affect rows为0</li></ul><p><strong>总结</strong></p><p>高并发“查询并修改”的场景，可以用CAS（Compare and Set）的方式解决数据一致性问题。对应到业务，即在set的时候，加上初始条件的比对即可。</p><p>优化不难，只改了半行SQL，但确实能解决问题。<br>但希望大家有收获<strong>，思路比结论重要</strong>。</p><h2 id="并发扣款一致性优化，CAS下ABA问题"><a href="#并发扣款一致性优化，CAS下ABA问题" class="headerlink" title="并发扣款一致性优化，CAS下ABA问题"></a>并发扣款一致性优化，CAS下ABA问题</h2><p>上文中提到：用CAS乐观锁，可以在尽量不影响吞吐量的情况下，保证数据的一致性。</p><p>大家有非常多的留言，大概有这么几类：</p><p>（1）<strong>是否存在ABA问题？</strong></p><p>（2）<strong>为什么不能用</strong>：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> t_yue <span class="hljs-keyword">SET</span> money=money-$diff <span class="hljs-keyword">AND</span> money&gt;=$diff;</span><br></pre></td></tr></table></figure></p><p>（3）能否借助<strong>redis事务</strong>来扣减余额； 能，上文有讲。</p><p>问题比较多，今天先聊第一个问题，ABA。 </p><p><strong>什么是ABA问题？</strong></p><p>CAS乐观锁机制确实能够提升吞吐，并保证一致性，但在极端情况下可能会出现ABA问题。</p><p>考虑如下操作：</p><ul><li>并发1（上）：获取出数据的初始值是A，后续计划实施CAS乐观锁，期望数据仍是A的时候，修改才能成功</li><li>并发2：将数据修改成B</li><li>并发3：将数据修改回A</li><li>并发1（下）：CAS乐观锁，检测发现初始值还是A，进行数据修改</li></ul><p>上述并发环境下，并发1在修改数据时，虽然还是A，但已经不是初始条件的A了，中间发生了A变B，B又变A的变化，此A已经非彼A，数据却成功修改，可能导致错误，这就是CAS引发的所谓的ABA问题。</p><p><strong>余额操作，出现ABA问题并不会对业务产生影响</strong>，因为对于“余额”属性来说，前一个A为100余额，与后一个A为100余额，本质是相同的。</p><p>但其他场景未必是这样，举一个堆栈操作的例子： A1 B C A1 F</p><p>并发1（上）：读取栈顶的元素为“A1”</p><p>并发2：进行了2次出栈</p><p>并发3：又进行了1次出栈</p><p>并发1（下）：实施CAS乐观锁，发现栈顶还是“A1”，于是修改为A2</p><p>此时会出现系统错误，因为此“A1”非彼“A1”</p><p><strong>ABA问题可以怎么优化？</strong></p><p>ABA问题导致的原因，是CAS过程中只简单进行了“值”的校验，再有些情况下，“值”相同不会引入错误的业务逻辑（例如余额），有些情况下，“值”虽然相同，却已经不是原来的数据了（例如堆栈）。</p><p>因此，CAS不能只比对“值”，还必须确保是原来的数据，才能修改成功。</p><p><strong>常见的实践</strong>是，将“值”比对，升级为“版本号”的比对，一个数据一个版本，<strong>版本变化，即使值相同，也不应该修改成功</strong>。</p><p>余额并发读写例子，引入版本号的具体实践如下：</p><p>（1）<strong>余额表要升级</strong>。<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_yue(uid, money)</span><br></pre></td></tr></table></figure></p><p>升级为：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_yue(uid, money, version)</span><br></pre></td></tr></table></figure></p><p>（2）<strong>查询余额时，同时查询版本号</strong>。<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> money <span class="hljs-keyword">FROM</span> t_yue <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">sid</span>=$<span class="hljs-keyword">sid</span></span><br></pre></td></tr></table></figure></p><p>升级为：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> money,<span class="hljs-keyword">version</span> <span class="hljs-keyword">FROM</span> t_yue <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">sid</span>=$<span class="hljs-keyword">sid</span></span><br></pre></td></tr></table></figure></p><p>假设有并发操作，都会将版本号查询出来。</p><p>（3）设置余额时，必须版本号相同，并且版本号要修改。</p><p>旧版本“值”比对：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> t_yue <span class="hljs-keyword">SET</span> money=<span class="hljs-number">38</span> <span class="hljs-keyword">WHERE</span> uid=$uid <span class="hljs-keyword">AND</span> money=<span class="hljs-number">100</span>;</span><br></pre></td></tr></table></figure></p><p>升级为“版本号”比对：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> t_yue <span class="hljs-keyword">SET</span> money=<span class="hljs-number">38</span>,<span class="hljs-keyword">version</span>=$version_new <span class="hljs-keyword">WHERE</span> uid=$uid <span class="hljs-keyword">AND</span> <span class="hljs-keyword">version</span>=$version_old;</span><br></pre></td></tr></table></figure></p><p>此时假设有并发操作，首先操作的请求会修改版本号，并发操作会执行失败。</p><p><em>画外音：<strong>version</strong>通用，本例是强行用version举例而已，实际上本例可以用余额“值”比对。</em></p><p>总结</p><ul><li><code>select&amp;set</code>业务场景，在并发时会出现一致性问题</li><li>基于“值”的CAS乐观锁，可能导致ABA问题</li><li>CAS乐观锁，必须保证修改时的“此数据”就是“彼数据”，应该由“值”比对，优化为“版本号”比对</li></ul><h2 id="并发扣款一致性，幂等性问题"><a href="#并发扣款一致性，幂等性问题" class="headerlink" title="并发扣款一致性，幂等性问题"></a>并发扣款一致性，幂等性问题</h2><p>分享了同一个用户并发扣款时，有一定概率出现数据不一致，可以使用CAS乐观锁的方式，在不降低吞吐量，并且只有少量修改的情况下，保证数据的一致性。</p><p>文章发布不到24小时，就有近200的评论。</p><p>其中，问的比较多的是<strong>ABA问题</strong>，这个问题已经在《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962761&amp;idx=1&amp;sn=11513a9e34bf77b4545ecdc289f4c8fd&amp;chksm=bd2d08558a5a8143ce15fbd9722fbcc42593b55480ca5eba7b19b2911763bb15bde65e9a2c4b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">并发扣款一致性优化，CAS下ABA问题，这个话题还没聊完！！！</a>》中扩展。</p><p>其次，问的比较多的是作业题，为什么一定要用<code>select&amp;set</code>的方式进行<strong>余额写回</strong>：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> t_yue <span class="hljs-keyword">SET</span> money=$new_money <span class="hljs-keyword">WHERE</span> uid=$uid <span class="hljs-keyword">AND</span> money=$old_money;</span><br></pre></td></tr></table></figure></p><p>为什么<strong>不能采用</strong>直接扣减的方法：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> t_yue <span class="hljs-keyword">SET</span> money=money-$diff <span class="hljs-keyword">WHERE</span> uid=$uid;</span><br></pre></td></tr></table></figure></p><p>很人说，在并发情况下，会将money扣成负数。</p><p>为了保证余额<strong>不被扣成负数</strong>，再加一个where条件：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> t_yue <span class="hljs-keyword">SET</span> money=money-$diff <span class="hljs-keyword">WHERE</span> uid=$uid* <span class="hljs-keyword">AND</span> money-$diff&gt;<span class="hljs-number">0</span>;</span><br></pre></td></tr></table></figure></p><p><strong>这样是否可行？</strong></p><p><em>画外音：额，撇开业务不谈，这个SQL用列做运算，其实是不好的，建议使用：</em><br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> t_yue <span class="hljs-keyword">SET</span> money=money-$diff <span class="hljs-keyword">WHERE</span> uid=$uid <span class="hljs-keyword">AND</span> money&gt;$diff;</span><br></pre></td></tr></table></figure></p><p>很遗憾，仍然不行。原因在《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962738&amp;idx=1&amp;sn=d2d91a380bad06af9f7b9f7a80db26b3&amp;chksm=bd2d08ae8a5a81b8a7f044af52c5e6e77ec3df2bb4a9c91cd450c3fd932e8dade56afb09f784&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">并发扣款，如何保证数据的一致性？</a>》一文里点赞最多的评论，<strong>不幂等</strong>。</p><p><em>画外音：说明绝大部分同学，能够回答正确作业。</em></p><p>聊幂等性之前，先看另一个测试用例的case。</p><p>假设有一个服务接口，<strong>注册新用户</strong>：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">bool <span class="hljs-title">RegisterUser</span><span class="hljs-params">($uid, $name)</span></span>&#123;</span><br><span class="line">​         <span class="hljs-comment">//**查看uid是否已经存在***</span></span><br><span class="line">​         select uid from t_user where uid=$uid;</span><br><span class="line">​         <span class="hljs-comment">//**不是新用户，返回失败***</span></span><br><span class="line">​         <span class="hljs-keyword">if</span>(rows&gt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">​         <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">​              <span class="hljs-comment">//**把新用户插入用户表***</span></span><br><span class="line">​              <span class="hljs-function">insert into t_user <span class="hljs-title">values</span><span class="hljs-params">($uid, $name)</span></span>;</span><br><span class="line">​              <span class="hljs-comment">//**返回成功***</span></span><br><span class="line">​              <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">​         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一个测试工程师，对该接口写了一个<strong>测试用例</strong>：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">bool <span class="hljs-title">TestCase_RegisterUser</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">​         <span class="hljs-comment">//**造一些假数据***</span></span><br><span class="line">​         <span class="hljs-keyword">long</span> uid=<span class="hljs-number">123</span>;</span><br><span class="line">​         String name=<span class="hljs-string">'shenjian'</span>;</span><br><span class="line">​         <span class="hljs-comment">//**调用被测试的接口***</span></span><br><span class="line">​         bool result= RegisterUser(uid,name);</span><br><span class="line">​         <span class="hljs-comment">//预期注册成功，**对结果进行断言判断***</span></span><br><span class="line">​         Assert(result,<span class="hljs-keyword">true</span>);</span><br><span class="line">​         <span class="hljs-comment">//**返回测试结果***</span></span><br><span class="line">​         <span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>这是不是一个好的测试用例？这个用例存在什么问题？</strong></p><p>你会发现，相同条件下，这个测试用例执行两次，得到的结果不一样：</p><p>（1）第一次执行，第一次造数据，调用接口，注册成功；</p><p>（2）第二次执行，又造了一次相同的数据，调用接口，注册会失败；</p><p>这不是一个好的测试用例，多次执行结果不同。</p><p><strong>什么是幂等性？</strong></p><p>相同条件下，执行同一请求，得到的结果相同，才符合幂等性。</p><p><em>画外音：Google一下，比我解释得更好，但意思应该说清楚了。</em> </p><p><strong>如何将上面的测试用例改为符合“幂等性”的测试用例呢？</strong></p><p>只需要加一行代码：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">bool <span class="hljs-title">TestCase_RegisterUser</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">​        <span class="hljs-comment">//造一些假数据*</span></span><br><span class="line">​        <span class="hljs-keyword">long</span> uid=<span class="hljs-number">123</span>;</span><br><span class="line">​        String name=’shenjian’;</span><br><span class="line">​        <span class="hljs-comment">//**先删除这个伪造的用户***</span></span><br><span class="line">​        DeleteUser(uid);</span><br><span class="line">​        <span class="hljs-comment">//调用被测试的接口*</span></span><br><span class="line">​        bool result= RegisterUser(uid,name);</span><br><span class="line">​        <span class="hljs-comment">//预期注册成功，对结果进行断言判断*</span></span><br><span class="line">​        Assert(result,<span class="hljs-keyword">true</span>);</span><br><span class="line">​        <span class="hljs-comment">//返回测试结果*</span></span><br><span class="line">​        <span class="hljs-keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，<strong>在相同条件下</strong>，不管这个用例执行多少次，得到的测试结果都是相同的。</p><p>是不是对幂等性有点感觉了。</p><p>读请求，一般是幂等的。</p><p>写请求，视情况而定：</p><ul><li><code>insert x</code>，一般来说不是幂等的，重复插入得到的结果不一定一样</li><li><code>delete x</code>，一般来说是幂等的，删除多次得到的结果仍相同</li><li><code>set a=x</code>，是幂等的</li><li><code>set a=a-x</code>，不是幂等的</li><li>…</li></ul><p>因此，这么扣减余额：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> t_yue <span class="hljs-keyword">SET</span> money=$new_money <span class="hljs-keyword">WHERE</span> uid=$uid <span class="hljs-keyword">AND</span> money=$old_money;</span><br></pre></td></tr></table></figure></p><p><strong>是幂等操作</strong>。</p><p>要是这么扣减余额：<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> t_yue <span class="hljs-keyword">SET</span> money=money-$diff <span class="hljs-keyword">WHERE</span> uid=$uid <span class="hljs-keyword">AND</span> money-$diff&gt;<span class="hljs-number">0</span>;</span><br></pre></td></tr></table></figure></p><p><strong>不是幂等操作</strong>。</p><p>聊到这里，或许有朋友要抬杠了，<strong>测试用例会重复执行，扣款怎么会重复执行呢？</strong></p><p><code>重试。</code></p><p>重试，是异常处理里很常见的手段。</p><p>你在写业务的时候有没有写过这样的代码：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = DoSomething();</span><br><span class="line"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">false</span>==result || TIMEOUT)&#123;</span><br><span class="line">​         <span class="hljs-comment">//**错误，或者超时，重试一次***</span></span><br><span class="line">​         result= DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br></pre></td></tr></table></figure></p><p>当然，又会有朋友抬杠了，我从来不重试！！！</p><p><em>画外音：额，这是合格，还是不合格呢？</em></p><p>你可以决定业务代码怎么写，你<strong>不能决定底层框架代码怎么写</strong>：</p><p>（1）站点框架有没有自动重试？</p><p>（2）服务框架有没有自动重试？</p><p>（3）服务连接池，数据库连接池有没有自动重试？</p><p><em>画外音：</em></p><p><em>（1）服务化分层的架构中，建议只入口层重试，服务层不要重试，防止雪崩；</em></p><p><em>（2）dubbo底层，调用超时是默认重试的，这个设计不好；</em></p><p>因此，<strong>在有重试的架构体系里，幂等性是需要考虑的一个问题</strong>。</p><p>现在该懂了，为啥扣款和充值业务，一般使用：</p><ul><li><code>select&amp;set，配合CAS方案</code></li></ul><p>而不使用：</p><ul><li><code>set money-=X</code>方案</li></ul><p><em>画外音：充了100电话费，怎么多了200块？</em></p><p><a href="https://mp.weixin.qq.com/s/xXju0y64KKUiD06QE0LoeA" target="_blank" rel="noopener">参考自文章</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;继续解答星球水友提问。&lt;br&gt;沈老师，我们有个业务，同一个用户在并发“查询，逻辑计算，扣款”的情况下，余额可能出现不一致，请问有什么优化方法么？&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="架构" scheme="https://removeif.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="设计" scheme="https://removeif.github.io/categories/%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="支付系统" scheme="https://removeif.github.io/tags/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="支付架构" scheme="https://removeif.github.io/tags/%E6%94%AF%E4%BB%98%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis二级缓存</title>
    <link href="https://removeif.github.io/2019/08/28/MyBatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html"/>
    <id>https://removeif.github.io/2019/08/28/MyBatis二级缓存.html</id>
    <published>2019-08-28T10:36:29.000Z</published>
    <updated>2019-08-29T02:01:20.781Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>我们在上一篇文章介绍了 MyBatis 的一级缓存的作用，如何开启，一级缓存的本质是什么，一级缓存失效的原因是什么？MyBatis 只有一级缓存吗？来找找答案吧！<br><a id="more"></a><br><strong>MyBatis 二级缓存介绍</strong></p></blockquote><p>上一篇文章中我们介绍到了 MyBatis 一级缓存其实就是 SqlSession 级别的缓存，什么是 SqlSession 级别的缓存呢？一级缓存的本质是什么呢？以及一级缓存失效的原因？我希望你在看下文之前能够回想起来这些内容。</p><p>MyBatis 一级缓存最大的共享范围就是一个SqlSession内部，那么如果多个 SqlSession 需要共享缓存，则需要开启二级缓存，开启二级缓存后，会使用 CachingExecutor 装饰 Executor，进入一级缓存的查询流程前，先在CachingExecutor 进行二级缓存的查询，具体的工作流程如下所示</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190828093242.png" alt=""></p><p>当二级缓存开启后，同一个命名空间(namespace) 所有的操作语句，都影响着一个 共同的 cache，也就是二级缓存被多个 SqlSession 共享，是一个全局的变量。当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p><p> <strong>二级缓存开启条件</strong></p><p>二级缓存默认是不开启的，需要手动开启二级缓存，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。开启二级缓存的条件也是比较简单，通过直接在 MyBatis 配置文件中通过 </p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span> = <span class="hljs-string">"cacheEnabled"</span> <span class="hljs-attr">value</span> = <span class="hljs-string">"true"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>来开启二级缓存，还需要在 Mapper 的xml 配置文件中加入 <cache> 标签</cache></p><p><strong>设置 cache 标签的属性</strong></p><p>cache 标签有多个属性，一起来看一些这些属性分别代表什么意义</p><ul><li>eviction: 缓存回收策略，有这几种回收策略</li><li>LRU - 最近最少回收，移除最长时间不被使用的对象</li><li>FIFO - 先进先出，按照缓存进入的顺序来移除它们</li><li>SOFT - 软引用，移除基于垃圾回收器状态和软引用规则的对象</li><li>WEAK - 弱引用，更积极的移除基于垃圾收集器和弱引用规则的对象</li></ul><p>默认是 LRU 最近最少回收策略</p><ul><li>flushinterval 缓存刷新间隔，缓存多长时间刷新一次，默认不清空，设置一个毫秒值</li><li>readOnly: 是否只读；<strong>true 只读</strong> ，MyBatis 认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。MyBatis 为了加快获取数据，直接就会将数据在缓存中的引用交给用户。不安全，速度快。<strong>读写(默认)</strong>：MyBatis 觉得数据可能会被修改</li><li>size : 缓存存放多少个元素</li><li>type: 指定自定义缓存的全类名(实现Cache 接口即可)</li><li>blocking：若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。</li></ul><p><strong>探究二级缓存</strong></p><p>我们继续以 MyBatis 一级缓存文章中的例子为基础，搭建一个满足二级缓存的例子，来对二级缓存进行探究，例子如下(对 一级缓存的例子部分源码进行修改)：</p><p>Dept.java</p><p>//存放在共享缓存中数据进行序列化操作和反序列化操作</p><p>//因此数据对应实体类必须实现【序列化接口】并提供 无参数的构造方法</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dept</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>myBatis-config.xml</p><p>在myBatis-config 中添加开启二级缓存的条件</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>DeptDao.xml</p><p>还需要在 Mapper 对应的xml中添加 cache 标签，表示对哪个mapper 开启缓存<cache></cache></p><p>对应的二级缓存测试类如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisSecondCacheTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> SqlSession sqlSession;</span><br><span class="line">    SqlSessionFactory factory;</span><br><span class="line">    <span class="hljs-meta">@Before</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(<span class="hljs-string">"myBatis-config.xml"</span>);</span><br><span class="line">        SqlSessionFactoryBuilder builderObj = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        factory = builderObj.build(is);</span><br><span class="line">        sqlSession = factory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@After</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(sqlSession!=<span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSecondCache</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-comment">//会话过程中第一次发送请求，从数据库中得到结果</span></span><br><span class="line">        <span class="hljs-comment">//得到结果之后，mybatis自动将这个查询结果放入到当前用户的一级缓存</span></span><br><span class="line">        DeptDao dao =  sqlSession.getMapper(DeptDao.class);</span><br><span class="line">        Dept dept = dao.findByDeptNo(<span class="hljs-number">1</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"第一次查询得到部门对象 = "</span>+dept);</span><br><span class="line">        <span class="hljs-comment">//触发MyBatis框架从当前一级缓存中将Dept对象保存到二级缓存</span></span><br><span class="line"></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        <span class="hljs-comment">// 改成 sqlSession.close(); 效果相同</span></span><br><span class="line"></span><br><span class="line">        SqlSession session2 = factory.openSession();</span><br><span class="line">        DeptDao dao2 = session2.getMapper(DeptDao.class);</span><br><span class="line">        Dept dept2 = dao2.findByDeptNo(<span class="hljs-number">1</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"第二次查询得到部门对象 = "</span>+dept2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试二级缓存效果，提交事务，sqlSession 查询完数据后，sqlSession2相同的查询是否会从缓存中获取数据。</p><p>测试结果如下：</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190829100049.png" alt=""></p><p>通过结果可以得知，首次执行的SQL语句是从数据库中查询得到的结果，然后第一个 SqlSession 执行提交，第二个 SqlSession 执行相同的查询后是从缓存中查取的。</p><p>用一下这幅图能够比较直观的反映两次 SqlSession 的缓存命中</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190828093326.png" alt=""></p><p><strong>二级缓存失效的条件</strong></p><p>与一级缓存一样，二级缓存也会存在失效的条件的，下面我们就来探究一下哪些情况会造成二级缓存失效</p><p><strong>第一次SqlSession 未提交</strong></p><p>SqlSession 在未提交的时候，SQL 语句产生的查询结果还没有放入二级缓存中，这个时候 SqlSession2 在查询的时候是感受不到二级缓存的存在的，修改对应的测试类，结果如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSqlSessionUnCommit</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">  <span class="hljs-comment">//会话过程中第一次发送请求，从数据库中得到结果</span></span><br><span class="line">  <span class="hljs-comment">//得到结果之后，mybatis自动将这个查询结果放入到当前用户的一级缓存</span></span><br><span class="line">  DeptDao dao =  sqlSession.getMapper(DeptDao.class);</span><br><span class="line">  Dept dept = dao.findByDeptNo(<span class="hljs-number">1</span>);</span><br><span class="line">  System.out.println(<span class="hljs-string">"第一次查询得到部门对象 = "</span>+dept);</span><br><span class="line">  <span class="hljs-comment">//触发MyBatis框架从当前一级缓存中将Dept对象保存到二级缓存</span></span><br><span class="line"></span><br><span class="line">  SqlSession session2 = factory.openSession();</span><br><span class="line">  DeptDao dao2 = session2.getMapper(DeptDao.class);</span><br><span class="line">  Dept dept2 = dao2.findByDeptNo(<span class="hljs-number">1</span>);</span><br><span class="line">  System.out.println(<span class="hljs-string">"第二次查询得到部门对象 = "</span>+dept2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产生的输出结果：</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190828184119.png" alt=""><br><strong>更新对二级缓存影响</strong></p><p>与一级缓存一样，更新操作很可能对二级缓存造成影响，下面用三个 SqlSession来进行模拟，第一个 SqlSession 只是单纯的提交，第二个 SqlSession 用于检验二级缓存所产生的影响，第三个 SqlSession 用于执行更新操作，测试如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSqlSessionUpdate</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">  SqlSession sqlSession = factory.openSession();</span><br><span class="line">  SqlSession sqlSession2 = factory.openSession();</span><br><span class="line">  SqlSession sqlSession3 = factory.openSession();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 第一个 SqlSession 执行更新操作</span></span><br><span class="line">  DeptDao deptDao = sqlSession.getMapper(DeptDao.class);</span><br><span class="line">  Dept dept = deptDao.findByDeptNo(<span class="hljs-number">1</span>);</span><br><span class="line">  System.out.println(<span class="hljs-string">"dept = "</span> + dept);</span><br><span class="line">  sqlSession.commit();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 判断第二个 SqlSession 是否从缓存中读取</span></span><br><span class="line">  DeptDao deptDao2 = sqlSession2.getMapper(DeptDao.class);</span><br><span class="line">  Dept dept2 = deptDao2.findByDeptNo(<span class="hljs-number">1</span>);</span><br><span class="line">  System.out.println(<span class="hljs-string">"dept2 = "</span> + dept2);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 第三个 SqlSession 执行更新操作</span></span><br><span class="line">  DeptDao deptDao3 = sqlSession3.getMapper(DeptDao.class);</span><br><span class="line">  deptDao3.updateDept(<span class="hljs-keyword">new</span> Dept(<span class="hljs-number">1</span>,<span class="hljs-string">"ali"</span>,<span class="hljs-string">"hz"</span>));</span><br><span class="line">  sqlSession3.commit();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 判断第二个 SqlSession 是否从缓存中读取</span></span><br><span class="line">  dept2 = deptDao2.findByDeptNo(<span class="hljs-number">1</span>);</span><br><span class="line">  System.out.println(<span class="hljs-string">"dept2 = "</span> + dept2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的输出结果如下</p><p>​    <img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190828093353.png" alt=""></p><p><strong>探究多表操作对二级缓存的影响</strong></p><p>现有这样一个场景，有两个表，部门表dept（deptNo,dname,loc）和 部门数量表deptNum（id,name,num），其中部门表的名称和部门数量表的名称相同，通过名称能够联查两个表可以知道其坐标(loc)和数量(num)，现在我要对部门数量表的 num 进行更新，然后我再次关联dept 和 deptNum 进行查询，你认为这个 SQL 语句能够查询到的 num 的数量是多少？来看一下代码探究一下</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeptNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    get and set...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeptVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Integer deptNo;</span><br><span class="line">    <span class="hljs-keyword">private</span> String  dname;</span><br><span class="line">    <span class="hljs-keyword">private</span> String  loc;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer num;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeptVo</span><span class="hljs-params">(Integer deptNo, String dname, String loc, Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.deptNo = deptNo;</span><br><span class="line">        <span class="hljs-keyword">this</span>.dname = dname;</span><br><span class="line">        <span class="hljs-keyword">this</span>.loc = loc;</span><br><span class="line">        <span class="hljs-keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeptVo</span><span class="hljs-params">(String dname, Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.dname = dname;</span><br><span class="line">        <span class="hljs-keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get and set...</span><br><span class="line">    toString()...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DeptDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="hljs-comment">// ...其他方法</span></span><br><span class="line">    <span class="hljs-function">DeptVo <span class="hljs-title">selectByDeptVo</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function">DeptVo <span class="hljs-title">selectByDeptVoName</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateDeptVoNum</span><span class="hljs-params">(DeptVo deptVo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByDeptVo"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.mybatis.beans.DeptVo"</span>&gt;</span></span><br><span class="line">  select d.deptno,d.dname,d.loc,dn.num from dept d,deptNum dn where dn.name = d.dname</span><br><span class="line">  and d.dname = #&#123;name&#125;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByDeptVoName"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.mybatis.beans.DeptVo"</span>&gt;</span></span><br><span class="line">  select * from deptNum where name = #&#123;name&#125;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateDeptVoNum"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.mybatis.beans.DeptVo"</span>&gt;</span></span><br><span class="line">  update deptNum set num = #&#123;num&#125; where name = #&#123;dname&#125;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>DeptNum 数据库初始值：</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190828093419.png" alt=""></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 探究多表操作对二级缓存的影响</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOtherMapper</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 第一个mapper 先执行联查操作</span></span><br><span class="line">  SqlSession sqlSession = factory.openSession();</span><br><span class="line">  DeptDao deptDao = sqlSession.getMapper(DeptDao.class);</span><br><span class="line">  DeptVo deptVo = deptDao.selectByDeptVo(<span class="hljs-string">"ali"</span>);</span><br><span class="line">  System.out.println(<span class="hljs-string">"deptVo = "</span> + deptVo);</span><br><span class="line">  <span class="hljs-comment">// 第二个mapper 执行更新操作 并提交</span></span><br><span class="line">  SqlSession sqlSession2 = factory.openSession();</span><br><span class="line">  DeptDao deptDao2 = sqlSession2.getMapper(DeptDao.class);</span><br><span class="line">  deptDao2.updateDeptVoNum(<span class="hljs-keyword">new</span> DeptVo(<span class="hljs-string">"ali"</span>,<span class="hljs-number">1000</span>));</span><br><span class="line">  sqlSession2.commit();</span><br><span class="line">  sqlSession2.close();</span><br><span class="line">  <span class="hljs-comment">// 第一个mapper 再次进行查询,观察查询结果</span></span><br><span class="line">  deptVo = deptDao.selectByDeptVo(<span class="hljs-string">"ali"</span>);</span><br><span class="line">  System.out.println(<span class="hljs-string">"deptVo = "</span> + deptVo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190828093437.png" alt=""></p><p>在对DeptNum 表执行了一次更新后，再次进行联查，发现数据库中查询出的还是 num 为 1050 的值，也就是说，实际上 1050 -&gt; 1000 ，最后一次联查实际上查询的是第一次查询结果的缓存，而不是从数据库中查询得到的值，这样就读到了脏数据。</p><p><strong>解决办法</strong></p><p>如果是两个mapper命名空间的话，可以使用<code>&lt;cache-ref&gt;</code>来把一个命名空间指向另外一个命名空间，从而消除上述的影响，再次执行，就可以查询到正确的数据</p><p><strong>二级缓存源码解析</strong></p><p>源码模块主要分为两个部分：二级缓存的创建和二级缓存的使用，首先先对二级缓存的创建进行分析：</p><p><strong>二级缓存的创建</strong></p><p>二级缓存的创建是使用 Resource 读取 XML 配置文件开始的</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = Resources.getResourceAsStream(<span class="hljs-string">"myBatis-config.xml"</span>);</span><br><span class="line">SqlSessionFactoryBuilder builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">factory = builder.build(is);</span><br></pre></td></tr></table></figure><p>读取配置文件后，需要对XML创建 Configuration并初始化</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLConfigBuilder parser = <span class="hljs-keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line"><span class="hljs-keyword">return</span> build(parser.parse());</span><br></pre></td></tr></table></figure><p>调用 parser.parse() 解析根目录 /configuration 下面的标签，依次进行解析</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Configuration <span class="hljs-title">parse</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = <span class="hljs-keyword">true</span>;</span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="hljs-string">"/configuration"</span>));</span><br><span class="line">  <span class="hljs-keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseConfiguration</span><span class="hljs-params">(XNode root)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    <span class="hljs-comment">//issue #117 read properties first</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="hljs-string">"properties"</span>));</span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode(<span class="hljs-string">"settings"</span>));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="hljs-string">"typeAliases"</span>));</span><br><span class="line">    pluginElement(root.evalNode(<span class="hljs-string">"plugins"</span>));</span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="hljs-string">"objectFactory"</span>));</span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="hljs-string">"objectWrapperFactory"</span>));</span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="hljs-string">"reflectorFactory"</span>));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="hljs-comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="hljs-string">"environments"</span>));</span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="hljs-string">"databaseIdProvider"</span>));</span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="hljs-string">"typeHandlers"</span>));</span><br><span class="line">    mapperElement(root.evalNode(<span class="hljs-string">"mappers"</span>));</span><br><span class="line">  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一个二级缓存的解析就是 </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapperElement(root.evalNode(<span class="hljs-string">"mappers"</span>));</span><br></pre></td></tr></table></figure><p>然后进去 mapperElement 方法中</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLMapperBuilder mapperParser = <span class="hljs-keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());            </span><br><span class="line">mapperParser.parse();</span><br></pre></td></tr></table></figure><p>继续跟 mapperParser.parse() 方法</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parse</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    configurationElement(parser.evalNode(<span class="hljs-string">"/mapper"</span>));</span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中有一个 configurationElement 方法，它是对二级缓存进行创建，如下</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurationElement</span><span class="hljs-params">(XNode context)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    String namespace = context.getStringAttribute(<span class="hljs-string">"namespace"</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (namespace == <span class="hljs-keyword">null</span> || namespace.equals(<span class="hljs-string">""</span>)) &#123;</span><br><span class="line">      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    cacheRefElement(context.evalNode(<span class="hljs-string">"cache-ref"</span>));</span><br><span class="line">    cacheElement(context.evalNode(<span class="hljs-string">"cache"</span>));</span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="hljs-string">"/mapper/parameterMap"</span>));</span><br><span class="line">    resultMapElements(context.evalNodes(<span class="hljs-string">"/mapper/resultMap"</span>));</span><br><span class="line">    sqlElement(context.evalNodes(<span class="hljs-string">"/mapper/sql"</span>));</span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="hljs-string">"select|insert|update|delete"</span>));</span><br><span class="line">  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">"Error parsing Mapper XML. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个二级缓存的关键点</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cacheRefElement(context.evalNode(<span class="hljs-string">"cache-ref"</span>));</span><br><span class="line">cacheElement(context.evalNode(<span class="hljs-string">"cache"</span>));</span><br></pre></td></tr></table></figure><p>也就是说，mybatis 首先进行解析的是 cache-ref 标签，其次进行解析的是 cache 标签。</p><p><strong>根据上面我们的 — 多表操作对二级缓存的影响 一节中提到的解决办法，采用 cache-ref 来进行命名空间的依赖能够避免二级缓存</strong>，但是总不能每次写一个 XML 配置都会采用这种方式吧，最有效的方式还是避免多表操作使用二级缓存</p><p>然后我们再来看一下cacheElement(context.evalNode(“cache”)) 这个方法</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cacheElement</span><span class="hljs-params">(XNode context)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (context != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">    String type = context.getStringAttribute(<span class="hljs-string">"type"</span>, <span class="hljs-string">"PERPETUAL"</span>);</span><br><span class="line">    Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">    String eviction = context.getStringAttribute(<span class="hljs-string">"eviction"</span>, <span class="hljs-string">"LRU"</span>);</span><br><span class="line">    Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">    Long flushInterval = context.getLongAttribute(<span class="hljs-string">"flushInterval"</span>);</span><br><span class="line">    Integer size = context.getIntAttribute(<span class="hljs-string">"size"</span>);</span><br><span class="line">    <span class="hljs-keyword">boolean</span> readWrite = !context.getBooleanAttribute(<span class="hljs-string">"readOnly"</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">    <span class="hljs-keyword">boolean</span> blocking = context.getBooleanAttribute(<span class="hljs-string">"blocking"</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">    Properties props = context.getChildrenAsProperties();</span><br><span class="line">    builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>认真看一下其中的属性的解析，是不是感觉很熟悉？这不就是对 cache 标签属性的解析吗？！！！</p><p>上述最后一句代码</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br></pre></td></tr></table></figure><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Cache <span class="hljs-title">useNewCache</span><span class="hljs-params">(Class&lt;? extends Cache&gt; typeClass,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">      Class&lt;? extends Cache&gt; evictionClass,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">      Long flushInterval,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">      Integer size,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">boolean</span> readWrite,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">boolean</span> blocking,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">      Properties props)</span> </span>&#123;</span><br><span class="line">    Cache cache = <span class="hljs-keyword">new</span> CacheBuilder(currentNamespace)</span><br><span class="line">        .implementation(valueOrDefault(typeClass, PerpetualCache.class))</span><br><span class="line">        .addDecorator(valueOrDefault(evictionClass, LruCache.class))</span><br><span class="line">        .clearInterval(flushInterval)</span><br><span class="line">        .size(size)</span><br><span class="line">        .readWrite(readWrite)</span><br><span class="line">        .blocking(blocking)</span><br><span class="line">        .properties(props)</span><br><span class="line">        .build();</span><br><span class="line">    configuration.addCache(cache);</span><br><span class="line">    currentCache = cache;</span><br><span class="line">    <span class="hljs-keyword">return</span> cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这段代码使用了构建器模式，一步一步构建Cache 标签的所有属性，最终把 cache 返回。</p><p><strong>二级缓存的使用</strong></p><p>在 mybatis 中，使用 Cache 的地方在 CachingExecutor中，来看一下 CachingExecutor 中缓存做了什么工作，我们以查询为例</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="hljs-function">  <span class="hljs-keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 得到缓存</span></span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">    <span class="hljs-comment">// 如果需要的话刷新缓存</span></span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="hljs-keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">      ensureNoOutParams(ms, parameterObject, boundSql);</span><br><span class="line">      <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)</span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="hljs-keyword">if</span> (list == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        tcm.putObject(cache, key, list); <span class="hljs-comment">// issue #578 and #116</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// 委托模式，交给SimpleExecutor等实现类去实现方法。</span></span><br><span class="line">  <span class="hljs-keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，先从 MapperStatement 取出缓存。只有通过<cache>,<cache-ref>或@CacheNamespace,@CacheNamespaceRef标记使用缓存的Mapper.xml或Mapper接口（同一个namespace，不能同时使用）才会有二级缓存。</cache-ref></cache></p><p>如果缓存不为空，说明是存在缓存。如果cache存在，那么会根据sql配置<code>(&lt;insert&gt;,&lt;select&gt;,&lt;update&gt;,&lt;delete&gt;</code>的flushCache属性来确定是否清空缓存。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushCacheIfRequired(ms);</span><br></pre></td></tr></table></figure><p>然后根据xml配置的属性useCache来判断是否使用缓存(resultHandler一般使用的默认值，很少会null)。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="hljs-keyword">null</span>)</span><br></pre></td></tr></table></figure><p>确保方法没有Out类型的参数，mybatis不支持存储过程的缓存，所以如果是存储过程，这里就会报错。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureNoOutParams</span><span class="hljs-params">(MappedStatement ms, Object parameter, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (ParameterMapping parameterMapping : boundSql.getParameterMappings()) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (parameterMapping.getMode() != ParameterMode.IN) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExecutorException(<span class="hljs-string">"Caching stored procedures with OUT params is not supported.  Please configure useCache=false in "</span> + ms.getId() + <span class="hljs-string">" statement."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据在 TransactionalCacheManager 中根据 key 取出缓存，如果没有缓存，就会执行查询，并且将查询结果放到缓存中并返回取出结果，否则就执行真正的查询方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line"><span class="hljs-keyword">if</span> (list == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">  list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  tcm.putObject(cache, key, list); <span class="hljs-comment">// issue #578 and #116</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> list;</span><br></pre></td></tr></table></figure><p><strong>是否应该使用二级缓存？</strong></p><p>那么究竟应该不应该使用二级缓存呢？先来看一下二级缓存的注意事项：</p><ul><li>缓存是以namespace为单位的，不同namespace下的操作互不影响。</li><li>insert,update,delete操作会清空所在namespace下的全部缓存。</li><li>通常使用MyBatis Generator生成的代码中，都是各个表独立的，每个表都有自己的namespace。</li><li>多表操作一定不要使用二级缓存，因为多表操作进行更新操作，一定会产生脏数据。</li></ul><p>如果你遵守二级缓存的注意事项，那么你就可以使用二级缓存。</p><p>但是，如果不能使用多表操作，二级缓存不就可以用一级缓存来替换掉吗？而且二级缓存是表级缓存，开销大，没有一级缓存直接使用 HashMap 来存储的效率更高，所以<strong>二级缓存并不推荐使用</strong>。</p><p><a href="https://mp.weixin.qq.com/s/sQLnePy2hMPkCB7xYz3qEQ" target="_blank" rel="noopener">文章来源</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;我们在上一篇文章介绍了 MyBatis 的一级缓存的作用，如何开启，一级缓存的本质是什么，一级缓存失效的原因是什么？MyBatis 只有一级缓存吗？来找找答案吧！&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mybatis" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mybatis/"/>
    
    
      <category term="mybatis" scheme="https://removeif.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Vim基本入门操作</title>
    <link href="https://removeif.github.io/2019/08/23/Vim%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C.html"/>
    <id>https://removeif.github.io/2019/08/23/Vim基本入门操作.html</id>
    <published>2019-08-23T15:21:36.000Z</published>
    <updated>2019-09-01T01:25:41.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Vim（Vi[Improved]）编辑器是功能强大的跨平台文本文件编辑工具，继承自Unix系统的Vi编辑器，支持Linux/Mac OS X/Windows系统，利用它可以建立、修改文本文件。进入Vim编辑程序，可以在终端输入下面的命令：<br><a id="more"></a></p></blockquote><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-variable">$vim</span> [filename]</span><br></pre></td></tr></table></figure><p>其中<code>filename</code>是要编辑器的文件的路径名。如果文件不存在，它将为你建立一个新文件。Vim编辑程序有三种操作模式，分别称为 <strong>编辑模式</strong>、<strong>插入模式</strong> 和 <strong>命令模式</strong>，当运行Vim时，首先进入编辑模式。</p><h2 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h2><p>Vim编辑方式的主要用途是在被编辑的文件中移动光标的位置。一旦光标移到到所要的位置，就可以进行剪切和粘贴正文块，删除正文和插入新的正文。当完成所有的编辑工作后，需要保存编辑器结果，退出编辑程序回到终端，可以发出<code>ZZ</code>命令，连续按两次大写的<code>Z</code>键。</p><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><p>如果键盘上有上、下、左、右箭头的导航键，就由这些键来完成光标的移动。另外，可以用下面的键完成同样的 <strong>按字符移动</strong> 功能：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k               上移；</span><br><span class="line">j               下移；</span><br><span class="line">h               左移；</span><br><span class="line">l               右移。</span><br></pre></td></tr></table></figure><p>上面这４个键将光标位置每次移动一行或一个 <strong>字符</strong> 。Vim还提供稍<code>大范围移动光标</code>的命令：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl+f      在文件中前移一页（相当于 page down）；</span><br><span class="line">ctrl+b      在文件中后移一页（相当于 page up）；</span><br></pre></td></tr></table></figure><p>更大范围的移动：<code>gg 起始位置, G最后一行,g_本行最后</code></p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*         当光标停留在一个单词上，* 键会在文件内搜索该单词，并跳转到下一处；</span><br><span class="line"><span class="hljs-comment">#         当光标停留在一个单词上，# 在文件内搜索该单词，并跳转到上一处；</span></span><br><span class="line">(/)       移动到 前/后 句 的开始；</span><br><span class="line">&#123;/&#125;       跳转到 当前/下一个 段落 的开始。</span><br><span class="line">g_        到本行最后一个不是 blank 字符的位置。</span><br><span class="line">fa        到下一个为 a 的字符处，你也可以fs到下一个为s的字符。</span><br><span class="line">t,        到逗号前的第一个字符。逗号可以变成其它字符。</span><br><span class="line">3fa       在当前行查找第三个出现的 a。</span><br><span class="line">F/T       和 f 和 t 一样，只不过是相反方向;</span><br><span class="line">gg        将光标定位到文件第一行起始位置；</span><br><span class="line">G         将光标定位到文件最后一行起始位置；</span><br><span class="line">NG或Ngg   将光标定位到第 N 行的起始位置。</span><br></pre></td></tr></table></figure><p>在屏幕中找到需要的 <strong>一页</strong> 时，可以用下面的命令快速移动光标：<code>H起始行，M中间行，L最后行</code></p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">H               将光标移到屏幕上的起始行（或最上行）；</span><br><span class="line">M               将光标移到屏幕中间；</span><br><span class="line">L               将光标移到屏幕最后一行。</span><br></pre></td></tr></table></figure><p>同样需要注意字母的大小写。<code>H</code> 和 <code>L</code> 命令还可以加数字。如 <code>2H</code> 表示将光标移到屏幕的第２行，<code>3L</code> 表示将光标移到屏幕的倒数第3行。<br> 当将光标移到所要的行是，<strong>行内移动</strong> 光标可以用下面的命令来实现：<code>&amp;末尾，^行头</code></p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">w               右移光标到下一个字的开头；</span><br><span class="line">e               右移光标到一个字的末尾；</span><br><span class="line">b               左移光标到前一个字的开头；</span><br><span class="line">0               数字０，左移光标到本行的开始；</span><br><span class="line">$               右移光标，到本行的末尾；</span><br><span class="line">^               移动光标，到本行的第一个非空字符。</span><br></pre></td></tr></table></figure><h3 id="2-2-搜索匹配"><a href="#2-2-搜索匹配" class="headerlink" title="2.2 搜索匹配"></a>2.2 搜索匹配</h3><p>和许多先进的编辑器一样，Vim 提供了强大的字符串搜索功能。要查找文件中指定字或短语出现的位置，可以用Vim直接进行搜索，而不必以手工方式进行。搜索方法是：键入字符 <code>/</code> ，后面跟以要搜索的字符串，然后按回车键。编辑程序执行正向搜索（即朝文件末尾方向），并在找到指定字符串后，将光标停到该字符串的开头；键入 <code>n</code> 命令可以继续执行搜索，找出这一字符串下次出现的位置。用字符 <code>?</code> 取代 <code>/</code> ，可以实现<code>反向搜索</code>。例如：<code>/str ，n下次出现，n上次出现</code></p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/str1               正向搜索字符串 str1；</span><br><span class="line">n                   继续搜索，找出 str1 字符串下次出现的位置；</span><br><span class="line">N                   继续搜索，找出 str1 字符串上一次出现的位置；</span><br><span class="line">?str2               反向搜索字符串 str2 。</span><br></pre></td></tr></table></figure><p>无论搜索方向如何，当到达文件末尾或开头时，搜索工作会循环到文件的另一端并继续执行。<br> Vim中执行搜索匹配最强大的地方是结合 <strong>正则表达式</strong> 来搜索，后续将会介绍。</p><h3 id="2-3-替换和删除"><a href="#2-3-替换和删除" class="headerlink" title="2.3 替换和删除"></a>2.3 替换和删除</h3><p>Vim常规的删除命令是 <code>d</code>、 <code>x</code> (前者删除 <code>行</code> ，后者删除 <code>字符</code> ),结合Vim的其他特性可以实现基础的删除功能。将光标定位于文件内指定位置后，可以用其他字符来替换光标所指向的字符，或从当前光标位置删除一个或多个字符或一行、多行。例如：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rc               用 c 替换光标所指向的当前字符；</span><br><span class="line">nrc              用 c 替换光标所指向的前 n 个字符；</span><br><span class="line">5rA              用 A 替换光标所指向的前 5 个字符；</span><br><span class="line">x                删除光标所指向的当前字符；</span><br><span class="line">nx               删除光标所指向的前 n 个字符；</span><br><span class="line">3x               删除光标所指向的前 3 个字符；</span><br><span class="line">dw               删除光标右侧的字；</span><br><span class="line">ndw              删除光标右侧的 n 个字；</span><br><span class="line">3dw              删除光标右侧的 3 个字；</span><br><span class="line">db               删除光标左侧的字；</span><br><span class="line">ndb              删除光标左侧的 n 个字；</span><br><span class="line">5db              删除光标左侧的 5 个字；</span><br><span class="line">dd               删除光标所在行，并去除空隙；</span><br><span class="line">ndd              删除（剪切） n 行内容，并去除空隙；</span><br><span class="line">3dd              删除（剪切） 3 行内容，并去除空隙；</span><br></pre></td></tr></table></figure><p>其他常用的删除命令有：<code>d$删到行尾，d0删到行首，J合并下行</code></p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d$              从当前光标起删除字符直到行的结束；</span><br><span class="line">d0              从当前光标起删除字符直到行的开始；</span><br><span class="line">J               删除本行的回车符（CR），并和下一行合并。</span><br></pre></td></tr></table></figure><p>Vim常规的替换命令有 <code>c</code> 和 <code>s</code> ，结合Vim的其他特性可以实现基础的替换功能，不过替换命令执行以后，通常会由 <strong>编辑模式</strong> 进入 <strong>插入模式</strong> ：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s                用输入的正文替换光标所指向的字符；</span><br><span class="line">S                删除当前行，并进入插入模式；</span><br><span class="line">ns               用输入的正文替换光标右侧 n 个字符；</span><br><span class="line">nS               删除当前行在内的 n 行，并进入插入模式；</span><br><span class="line">cw               用输入的正文替换光标右侧的字；</span><br><span class="line">cW               用输入的正文替换从光标到行尾的所有字符（同 c$ )；</span><br><span class="line">ncw              用输入的正文替换光标右侧的 n 个字；</span><br><span class="line">cb               用输入的正文替换光标左侧的字；</span><br><span class="line">ncb              用输入的正文替换光标左侧的 n 个字；</span><br><span class="line"><span class="hljs-built_in">cd</span>               用输入的正文替换光标的所在行；</span><br><span class="line">ncd              用输入的正文替换光标下面的 n 行；</span><br><span class="line">c$               用输入的正文替换从光标开始到本行末尾的所有字符；</span><br><span class="line">c0               用输入的正文替换从本行开头到光标的所有字符。</span><br></pre></td></tr></table></figure><h3 id="2-4-复制粘贴"><a href="#2-4-复制粘贴" class="headerlink" title="2.4 复制粘贴"></a>2.4 复制粘贴</h3><p>从正文中删除的内容（如字符、字或行）并没有真正丢失，而是被剪切并复制到了一个内存缓冲区中。用户可将其粘贴到正文中的指定位置。完成这一操作的命令是：<code>p粘到后面，P粘到前面</code></p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p               小写字母 p，将缓冲区的内容粘贴到光标的后面；</span><br><span class="line">P               大写字母 P，将缓冲区的内容粘贴到光标的前面。</span><br></pre></td></tr></table></figure><p>如果缓冲区的内容是字符或字，直接粘贴在光标的前面或后面；如果缓冲区的内容为整行正文，执行上述粘贴命令将会粘贴在当前光标所在行的上一行或下一行。<br> 注意上述两个命令中字母的大小写。Vim 编辑器经常以一对大、小写字母（如 <code>p</code> 和 <code>P</code>）来提供一对相似的功能。通常，小写命令在光标的后面进行操作，大写命令在光标的前面进行操作。</p><p>有时需要复制一段正文到新位置，同时保留原有位置的内容。这种情况下，首先应当把指定内容复制（而不是剪切）到内存缓冲区。完成这一操作的命令是：<code>yy 复制一行，nyy 复制n行</code></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yy              复制当前行到内存缓冲区；</span><br><span class="line">nyy             复制 n 行内容到内存缓冲区；</span><br><span class="line">5yy             复制 5 行内容到内存缓冲区；</span><br><span class="line">“+y             复制 1 行到操作系统的粘贴板；</span><br><span class="line">“+nyy           复制 n 行到操作系统的粘贴板。</span><br></pre></td></tr></table></figure><h3 id="2-5-撤销和重复"><a href="#2-5-撤销和重复" class="headerlink" title="2.5 撤销和重复"></a>2.5 撤销和重复</h3><p>在编辑文档的过程中，为消除某个错误的编辑命令造成的后果，可以用撤消命令。另外，如果用户希望在新的光标位置重复前面执行过的编辑命令，可用重复命令。<code>u撤销前一条，.重复最后一条命令</code></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u               撤消前一条命令的结果；</span><br><span class="line">.               重复最后一条修改正文的命令。</span><br></pre></td></tr></table></figure><h2 id="3-插入模式"><a href="#3-插入模式" class="headerlink" title="3. 插入模式"></a>3. 插入模式</h2><h3 id="3-1-进入插入模式"><a href="#3-1-进入插入模式" class="headerlink" title="3.1 进入插入模式"></a>3.1 进入插入模式</h3><p>在编辑模式下正确定位光标之后，可用以下命令切换到插入模式：<code>i左，a右，o下一行，O上一行，I光标开头，A末尾</code></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i            在光标左侧插入正文</span><br><span class="line">a            在光标右侧插入正文</span><br><span class="line">o            在光标所在行的下一行增添新行</span><br><span class="line">O            在光标所在行的上一行增添新行</span><br><span class="line">I            在光标所在行的开头插入</span><br><span class="line">A            在光标所在行的末尾插入</span><br></pre></td></tr></table></figure><h3 id="3-2-退出插入模式"><a href="#3-2-退出插入模式" class="headerlink" title="3.2 退出插入模式"></a>3.2 退出插入模式</h3><p>退出插入模式的方法是，按 <code>ESC</code> 键或组合键 <code>Ctrl+[</code> ，退出插入模式之后，将会进入编辑模式 。</p><h2 id="4-命令模式"><a href="#4-命令模式" class="headerlink" title="4. 命令模式"></a>4. 命令模式</h2><p>在Vim的命令模式下，可以使用复杂的命令。在编辑模式下键入 <code>:</code> ，光标就跳到屏幕最后一行，并在那里显示冒号，此时已进入命令模式。命令模式又称 <strong>末行模式</strong> ，用户输入的内容均显示在屏幕的最后一行，按回车键，Vim 执行命令。</p><h3 id="4-1-打开、保存、退出"><a href="#4-1-打开、保存、退出" class="headerlink" title="4.1 打开、保存、退出"></a>4.1 打开、保存、退出</h3><p>在已经启动的Vim中打开一个文件需要用 <strong>:e</strong> 命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:e path_to_file/filename</span><br></pre></td></tr></table></figure><p>保存当前编辑的文件需要用 <strong>:w</strong> 命令（单词 <code>write</code> 的缩写）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w</span><br></pre></td></tr></table></figure><p>将当前文件另存为 <code>file_temp</code> 则：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w file_temp</span><br></pre></td></tr></table></figure><p>在编辑模式下可以用 <code>ZZ</code> 命令退出Vim编辑程序，该命令保存对正文所作的修改，覆盖原始文件。如果只需要退出编辑程序，而不打算保存编辑的内容，可用下面的命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">: q                在未作修改的情况下退出；</span><br><span class="line">: q!               放弃所有修改，退出编辑程序。</span><br></pre></td></tr></table></figure><p>保存并退出则可以讲两条命令结合起来使用（注意命令顺序，先保存，后退出）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure><h3 id="4-2-行号与文件"><a href="#4-2-行号与文件" class="headerlink" title="4.2 行号与文件"></a>4.2 行号与文件</h3><p>编辑中的每一行正文都有自己的行号，用下列命令可以移动光标到指定行（效果与 <strong>编辑模式</strong> 下的 <code>ngg</code> 或 <code>nG</code> 相同）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: n             将光标移到第 n 行</span><br></pre></td></tr></table></figure><p>命令模式下，可以规定命令操作的行号范围。数值用来指定绝对行号；字符“.”表示光标所在行的行号；字符符“$”表示正文最后一行的行号；简单的表达式，例如“.+5”表示当前行往下的第 5 行。例如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:345                将光标移到第 345 行</span><br><span class="line">:345w file          将第 345 行写入 file 文件</span><br><span class="line">:3,5w file          将第 3 行至第 5 行写入 file 文件</span><br><span class="line">:1,.w file          将第 1 行至当前行写入 file 文件</span><br><span class="line">:.,$w file          将当前行至最后一行写入 file 文件</span><br><span class="line">:.,.+5w file        从当前行开始将 6 行内容写入 file 文件</span><br><span class="line">:1,$w file          将所有内容写入 file 文件，相当于 :w file 命令</span><br></pre></td></tr></table></figure><p>在命令模式下，允许从文件中读取正文，或将正文写入文件。例如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:w              将编辑的内容写入原始文件，用来保存编辑的中间结果</span><br><span class="line">:wq             将编辑的内容写入原始文件并退出编辑程序（相当于 ZZ 命令）</span><br><span class="line">:w file         将编辑的内容写入 file 文件，保持原有文件的内容不变</span><br><span class="line">:a,bw file      将第 a 行至第 b 行的内容写入 file 文件</span><br><span class="line">:r file         读取 file 文件的内容，插入当前光标所在行的后面</span><br><span class="line">:e file         编辑新文件 file 代替原有内容</span><br><span class="line">:f file         将当前文件重命名为 file</span><br><span class="line">:f              打印当前文件名称和状态，如文件的行数、光标所在的行号等</span><br></pre></td></tr></table></figure><h3 id="4-3-字符串搜索"><a href="#4-3-字符串搜索" class="headerlink" title="4.3 字符串搜索"></a>4.3 字符串搜索</h3><p>在 <strong>编辑模式</strong> 讲过字符串的搜索，此处的 <strong>命令模式</strong> 也可以进行字符串搜索，给出一个字符串，可以通过搜索该字符串到达指定行。如果希望进行正向搜索，将待搜索的字符串置于两个 <code>/</code> 之间；如果希望反向搜索，则将字符串放在两个 <code>?</code> 之间。例如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:/str/                  正向搜索，将光标移到下一个包含字符串 str 的行</span><br><span class="line">:?str?                  反向搜索，将光标移到上一个包含字符串 str 的行</span><br><span class="line">:/str/w file            正向搜索，并将第一个包含字符串 str 的行写入 file 文件</span><br><span class="line">:/str1/,/str2/w file    正向搜索，并将包含字符串 str1 的行至包含字符串 str2 的行写</span><br></pre></td></tr></table></figure><h3 id="4-4-Vim中的正则表达式"><a href="#4-4-Vim中的正则表达式" class="headerlink" title="4.4 Vim中的正则表达式"></a>4.4 Vim中的正则表达式</h3><p>当给Vim指定搜索字符串时，可以包含具有特殊含义的字符。包含这些特殊字符的搜索字符串称为正则表达式（Regular Expressions）。例如，要搜索一行正文，这行正文的开头包含 <code>struct</code> 字。下面的命令做不到这一点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/struct/</span><br></pre></td></tr></table></figure><p>因为它只找出在行中任意位置包含 <code>struct</code>的第一行，并不一定在行的开始包含 <code>struct</code> 。解决问题的办法是在搜索字符串前面加上特殊字符^：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/^struct/</span><br></pre></td></tr></table></figure><p><code>^</code> 字符比较每行开头的字符串。所以上面的命令表示：找出以字符串 <code>struct</code> 开头的行。<br> 也可以用类似办法在搜索字符串后面加上表示行的末尾的特殊字符 <code>$</code> 来找出位于行末尾的字：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/^struct/</span><br></pre></td></tr></table></figure><p>下表给出大多数特殊字符和它们的含义：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">^               放在字符串前面，匹配行首的字；</span><br><span class="line">$               放在字符串后面，匹配行尾的字；</span><br><span class="line">\&lt;              匹配一个字的字头；</span><br><span class="line">\&gt;              匹配一个字的字尾；</span><br><span class="line">.               匹配任何单个正文字符；</span><br><span class="line">[str]           匹配 str 中的任何单个字符；</span><br><span class="line">[^str]          匹配任何不在 str 中的单个字符；</span><br><span class="line">[a-b]           匹配 a 到 b 之间的任一字符；</span><br><span class="line">*               匹配前一个字符的 0 次或多次出现；</span><br><span class="line">\               转义后面的字符。</span><br></pre></td></tr></table></figure><p>简单介绍这么多，正则表达式知识可以参考<br> 《正则表达式30分钟入门》:<a href="https://link.jianshu.com?t=http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">http://deerchao.net/tutorials/regex/regex.htm</a><br> 另外，进阶的Vim正则表达式还有对Magic 模式的介绍，可以参考<br> 《Vim正则表达式详解》:<br> <a href="https://link.jianshu.com?t=http://blog.csdn.net/salc3k/article/details/8222397" target="_blank" rel="noopener">http://blog.csdn.net/salc3k/article/details/8222397</a></p><h3 id="4-5-正文替换"><a href="#4-5-正文替换" class="headerlink" title="4.5 正文替换"></a>4.5 正文替换</h3><p>利用 <code>:s</code> 命令可以实现字符串的替换。具体的用法包括：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:%s/str1/str2/      用字符串 str2 替换行中首次出现的字符串 str1</span><br><span class="line">:s/str1/str2/g      用字符串 str2 替换行中所有出现的字符串 str1</span><br><span class="line">:.,$ s/str1/str2/g  用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1</span><br><span class="line">:1,$ s/str1/str2/g  用字符串 str2 替换正文中所有出现的字符串 str1</span><br><span class="line">:g/str1/s//str2/g   功能同上</span><br><span class="line">:m,ns/str1/str2/g   将从m行到n行的str1替换成str2</span><br></pre></td></tr></table></figure><p>从上述替换命令可以看到：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`g` 放在命令末尾，表示对搜索字符串的每次出现进行替换,不止匹配每行中的第一次出现；不加 `g`，表示只对搜索字符串的首次出现进行替换；`g` 放在命令开头，表示对正文中所有包含搜索字符串的行进行替换操作;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`s` 表示后面跟着一串替换的命令；</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`%` 表示替换范围是所有行，即全文。</span><br></pre></td></tr></table></figure><p>另外一个实用的命令，在Vim中统计当前文件中字符串 <code>str1</code> 出现的次数，可用替换命令的变形：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/str1/&amp;/gn</span><br></pre></td></tr></table></figure><h3 id="4-6-删除正文"><a href="#4-6-删除正文" class="headerlink" title="4.6 删除正文"></a>4.6 删除正文</h3><p>在命令模式下，同样可以删除正文中的内容。例如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:d                              删除光标所在行</span><br><span class="line">:3d                             删除 3 行</span><br><span class="line">:.,$d                           删除当前行至正文的末尾</span><br><span class="line">:/str1/,/str2/d                 删除从字符串 str1 到 str2 的所有行</span><br><span class="line">:g/^\(.*\)$\n\1$/d              删除连续相同的行，保留最后一行</span><br><span class="line">:g/\%(^\1$\n\)\@&lt;=\(.*\)$/d     删除连续相同的行，保留最开始一行</span><br><span class="line">:g/^\s*$\n\s*$/d                删除连续多个空行，只保留一行空行</span><br><span class="line">:5,20s/^#//g                    删除5到20行开头的 # 注释</span><br></pre></td></tr></table></figure><p>总之，Vim的初级删除命令是用 <code>d</code> ，高级删除命令可以用 <strong>正则替换</strong> 的方式执行。</p><h3 id="4-7-恢复文件"><a href="#4-7-恢复文件" class="headerlink" title="4.7 恢复文件"></a>4.7 恢复文件</h3><p>Vim 在编辑某个文件时，会另外生成一个临时文件，这个文件的名称通常以 <code>.</code> 开头，并以 <code>.swp</code> 结尾。Vim 在正常退出时，该文件被删除，若意外退出，而没有保存文件的最新修改内容，则可以使用恢复命令 <code>:recover</code> 来恢复文件，也可以在启动Vim时用 <code>-r</code> 选项。</p><h3 id="4-8-选项设置"><a href="#4-8-选项设置" class="headerlink" title="4.8 选项设置"></a>4.8 选项设置</h3><p>为控制不同的编辑功能，Vim 提供了很多内部选项。利用 <code>:set</code> 命令可以设置选项。基本语法为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set option         设置选项 option</span><br></pre></td></tr></table></figure><p>常见的功能选项包括：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">autoindent      设置该选项，则正文自动缩进</span><br><span class="line">ignorecase      设置该选项，则忽略规则表达式中大小写字母的区别</span><br><span class="line">number          设置该选项，则显示正文行号</span><br><span class="line">ruler           设置该选项，则在屏幕底部显示光标所在行、列的位置</span><br><span class="line">tabstop         设置按 Tab 键跳过的空格数。例如 :set tabstop=n，n 默认值为 8</span><br><span class="line">mk              将选项保存在当前目录的 .exrc 文件中</span><br></pre></td></tr></table></figure><h3 id="4-9-Shell切换"><a href="#4-9-Shell切换" class="headerlink" title="4.9 Shell切换"></a>4.9 Shell切换</h3><p>当处于编辑的对话过程中时，可能需要执行一些Linux命令。如果需要保存当前的结果，退出编辑程序，再执行所需的Linux命令，然后再回头继续编辑过程，就显得十分累赘。如果能在编辑的环境中运行Linux命令就要省事得多。在Vim中，可以用下面的命令来做到这一点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!shell_command   执行完 shell_command 后回到Vim</span><br></pre></td></tr></table></figure><p>这称为Shell切换。它允许执行任何可以在标准的Shell提示符下执行的命令。当这条命令执行完毕，控制返回给编辑程序。又可以继续编辑对话过程。</p><h3 id="4-10-分屏与标签页"><a href="#4-10-分屏与标签页" class="headerlink" title="4.10 分屏与标签页"></a>4.10 分屏与标签页</h3><h4 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h4><p>普通的Vim模式，打开一个Vim程序只能查看一个文件，如果想同时查看多个文件，就需要用到Vim分屏与标签页功能。<br> Vim的分屏，主要有两种方式：上下分屏（水平分屏）和左右分屏（垂直分屏），在命令模式分别敲入以下命令即可：</p><p><code>:sp 上下分屏,:vsp左右分屏</code></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:split（可用缩写 :sp）          上下分屏；</span><br><span class="line">:vsplit（可用缩写 :vsp）        左右分屏。</span><br></pre></td></tr></table></figure><p>另外，也可以在终端里启动vim时就开启分屏操作：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim -On file1 file2...   打开 file1 和 file2 ，垂直分屏</span><br><span class="line">vim -on file1 file2...   打开 file1 和 file2 ，水平分屏</span><br></pre></td></tr></table></figure><p>理论上，一个Vim窗口，可以分为多个Vim屏幕，切换屏幕需要用键盘快捷键，命令分别有：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+w+h            切换到当前分屏的左边一屏；</span><br><span class="line">Ctrl+w+l            切换到当前分屏的右边一屏；</span><br><span class="line">Ctrl+w+j            切换到当前分屏的下方一屏；</span><br><span class="line">Ctrl+w+k            切换到当前分屏的上方一屏。</span><br></pre></td></tr></table></figure><p>即键盘上的<code>h,j,k,l</code> 四个Vim专用方向键，配合<code>Ctrl</code>键和<code>w</code>键（<code>window</code>的缩写），就能跳转到目标分屏。另外，也可以直接按 <code>Ctrl+w+w</code> 来跳转分屏，不过跳转方向则是在当前Vim窗口所有分屏中，按照<code>逆时针</code>方向跳转。<br> 下面是改变尺寸的一些操作，主要是高度，对于宽度你可以使用 <code>[Ctrl+W &lt;]</code> 或是 <code>[Ctrl+W &gt;]</code> ，但这可能需要最新的版本才支持。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+W =            让所有的屏都有一样的高度；</span><br><span class="line">Ctrl+W +            增加高度；</span><br><span class="line">Ctrl+W -            减少高度。</span><br></pre></td></tr></table></figure><h4 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h4><p>Vim的标签（Tab）页，类似浏览器的标签页，一个标签页打开一个Vim的窗口，一个Vim的窗口可以支持N个分屏。<br> 在Vim中新建一个标签的命令是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tabnew</span><br></pre></td></tr></table></figure><p>如果要在新建标签页的同时打开一个文件，则可以在命令后面直接附带文件路径：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tabnew filename</span><br></pre></td></tr></table></figure><p>Vim中的每个标签页有一个唯一的数字序号，第一个标签页的序号是<code>0</code>，从左向右依次加一。关于标签页有一系列操作命令，简介如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">:tN[ext]                跳转到上一个匹配的标签</span><br><span class="line">:tabN[ext]              跳到上一个标签页</span><br><span class="line">:tabc[lose]             关闭当前标签页</span><br><span class="line">:tabdo                  为每个标签页执行命令</span><br><span class="line">:tabe[dit]              在新标签页里编辑文件</span><br><span class="line">:tabf[ind]              寻找 &apos;path&apos; 里的文件，在新标签页里编辑之</span><br><span class="line">:tabfir[st]             转到第一个标签页</span><br><span class="line">:tabl[ast]              转到最后一个标签页</span><br><span class="line">:tabm[ove]  N           把标签页移到序号为N位置</span><br><span class="line">:tabnew [filename]      在新标签页里编辑文件</span><br><span class="line">:tabn[ext]              转到下一个标签页</span><br><span class="line">:tabo[nly]              关闭所有除了当前标签页以外的所有标签页</span><br><span class="line">:tabp[revious]          转到前一个标签页</span><br><span class="line">:tabr[ewind]            转到第一个标签页</span><br></pre></td></tr></table></figure><h3 id="4-11-与外部工具集成"><a href="#4-11-与外部工具集成" class="headerlink" title="4.11 与外部工具集成"></a>4.11 与外部工具集成</h3><p>Vim可以与许多外部程序集成，功能十分强大，比如 <code>diff</code> , <code>ctags</code> , <code>sort</code> , <code>xxd</code> 等等，下面选取几个简单介绍一下。</p><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>Linux命令 <code>diff</code> 用来对比两个文件的内容，不过对比结果显示在终端里，可读性比较差。结合Vim，在终端里可以直接输入命令 <code>vimdiff</code>，后面跟两个文件名作为参数：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimdiff file1 file2</span><br></pre></td></tr></table></figure><p>即可在Vim里分屏显示两个文件内容的对比结果，对文件内容差异部分进行高亮标记，还可以同步滚动两个文件内容，更可以实时修改文件内容，方便程度和用户体验大大提高。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimdiff a.txt b.txt</span><br></pre></td></tr></table></figure><p>如果直接给 <code>-d</code> 选项是一样的</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -d a.txt b.txt</span><br></pre></td></tr></table></figure><p>除了在终端里开启vimdiff 功能，也可以在打开Vim后，在Vim的命令模式输入相关命令来开启 <code>vimdiff</code> 功能：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:diffsplit abc.txt</span><br></pre></td></tr></table></figure><p>如果你现在已经开启了一个文件，想Vim帮你区分你的文件跟 <code>abc.txt</code> 有什么区别，可以在Vim中用 <code>diffsplit</code> 的方式打开第二个文件，这个时 候Vim会用 <code>split</code>（分<strong>上下</strong>两屏）的方式开启第二个文件，并且通过颜色，<code>fold</code>来显示两个文件的区别<br> 这样Vim就会用颜色帮你区分开2个文件的区别。如果文件比较大（源码）重复的部分会帮你折叠起来。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:diffpatch filename</span><br></pre></td></tr></table></figure><p>通过 <code>:diffpatch</code> 你的patch的文件名，就可以以当前文件加上你的patch来显示。vim会split一个新的屏，显示patch后的信息并且用颜色标明区别。<br> 如果不喜欢上下对比，喜欢左右（比较符合视觉）可以在前面加 <code>vert</code> ，例如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:vert diffsplit abc.txt</span><br><span class="line">:vert diffpatch abc.txt</span><br></pre></td></tr></table></figure><p>看完diff，用 <code>:only</code> 回到原本编辑的文件，觉得diff的讨厌颜色还是在哪里，只要用 <code>:diffoff</code> 关闭就好了。<br> 还有个常用的diff中的就是 <code>:diffu</code> ,这个是 <code>:diffupdate</code> 的简写，更新的时候用。<br> Vim的<code>diff</code>功能显示效果如下所示：</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190823231928.png" alt=""></p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>Linux命令 <code>sort</code> 可以对文本内容进行按行中的字符比较、排序，但在终端里使用 <code>sort</code> 命令处理文件，并不能实时查看文件内容。具体用法请自查手册。</p><h4 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h4><p><code>vim+xxd</code> 是Linux下最常用的二进制文本编辑工具，<code>xxd</code>其实是Vim外部的一个转换程序，随Vim一起发布，在Vim里调用它来编辑二进制文本非常方便。<br> 首先以二进制模式在终端里打开一个文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -b filename</span><br></pre></td></tr></table></figure><p>Vim 的 <code>-b</code> 选项是告诉 Vim 打开的是一个二进制文件，不指定的话，会在后面加上 <code>0x0a</code> ，即一个换行符。<br> 然后在Vim的命令模式下键入：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%!xxd</span><br></pre></td></tr></table></figure><p>即可看到二进制模式显示出来的文本，看起来像这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000: 1f8b 0808 39d7 173b 0203 7474 002b 4e49  ....9..;..tt.+NI </span><br><span class="line">0000010: 4b2c 8660 eb9c ecac c462 eb94 345e 2e30  K,......b..4^.0 </span><br><span class="line">0000020: 373b 2731 0b22 0ca6 c1a2 d669 1035 39d9  7;&apos;1.&quot;.....i.59</span><br></pre></td></tr></table></figure><p>然后就可以在二进制模式下编辑该文件，编辑后保存，然后用下面命令从二进制模式转换到普通模式：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%!xxd -r</span><br></pre></td></tr></table></figure><p>另外，也可以调整二进制的显示模式，默认是 <strong>2</strong> 个字节为一组，可以通过 <code>g</code> 参数调整每组字节数：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:%!xxd -g 1         表示每1个字节为1组 </span><br><span class="line">:%!xxd -g 2         表示每2个字节为1组(默认) </span><br><span class="line">:%!xxd -g 4         表示每4个字节为1组</span><br></pre></td></tr></table></figure><h2 id="5-Vim配置"><a href="#5-Vim配置" class="headerlink" title="5. Vim配置"></a>5. Vim配置</h2><p>最初安装的Vim功能、特性支持比较少，用起来比较费劲，想要稍微“好用”一点，需做一些初步的配置。Vim的配置主要分为Vim本身特性的配置和外部插件的配置两部分。<br> Vim的配置是通常是存放在用户主目录的 <code>.vimrc</code> 的隐藏文件中的。就Vim本身特性来说，基础的配置有编程语言语法高亮、缩进设置、行号显示、搜索高亮、TAB键设置、字体设置、Vim主题设置等等，稍微高级一些的有编程语言缩进、自动补全设置等，具体配置项可以自行查资料，全面详细的配置项介绍可以参考：<br> 《Vim Options》：<br> <a href="https://link.jianshu.com?t=http://vimcdoc.sourceforge.net/doc/options.html#&#39;completeopt&#39;" target="_blank" rel="noopener">http://vimcdoc.sourceforge.net/doc/options.html#%27completeopt%27</a></p><h2 id="6-Vim插件"><a href="#6-Vim插件" class="headerlink" title="6. Vim插件"></a>6. Vim插件</h2><p>Vim“编辑器之神”的称号并不是浪得虚名，然而，这个荣誉的背后，或许近半的功劳要归功于强大的插件支持特性，以及社区开发的各种各样功能强大的插件。</p><p>平时开发人员常用插件主要是目录（文件）查看和管理、编程语言缩进与自动补全、编程语言Docs支持、函数跳转、项目管理等等，简单配置可以参考下面：</p><p>《Vim插件简单介绍》：<br> <a href="https://link.jianshu.com?t=http://blog.segmentfault.com/xuelang/1190000000630547" target="_blank" rel="noopener">http://blog.segmentfault.com/xuelang/1190000000630547</a></p><p>《手把手教你把Vim改装成一个IDE编程环境(图文)》：<br> <a href="https://link.jianshu.com?t=http://blog.csdn.net/wooin/article/details/1858917" target="_blank" rel="noopener">http://blog.csdn.net/wooin/article/details/1858917</a></p><p>《将Vim改造为强大的IDE》：<br> <a href="https://link.jianshu.com?t=http://www.cnblogs.com/zhangsf/archive/2013/06/13/3134409.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhangsf/archive/2013/06/13/3134409.html</a></p><p>当然，这些插件都是拜Vim本身的插件支持特性所赐。Vim为了支持丰富的第三方插件，自身定义了一套简单的脚本开发语言，供程序员自行开发自己所需要的插件，插件开发介绍可以参考：</p><p>《Writing Vim Plugins》：<br> <a href="https://link.jianshu.com?t=http://stevelosh.com/blog/2011/09/writing-vim-plugins/" target="_blank" rel="noopener">http://stevelosh.com/blog/2011/09/writing-vim-plugins/</a></p><h2 id="7-Vim完整文档"><a href="#7-Vim完整文档" class="headerlink" title="7. Vim完整文档"></a>7. Vim完整文档</h2><ol><li>Vim官方文档：<a href="https://link.jianshu.com?t=http://vimdoc.sourceforge.net/" target="_blank" rel="noopener">http://vimdoc.sourceforge.net/</a> </li><li>Vim中文用户手册7_3.pdf ：<a href="https://link.jianshu.com?t=http://pan.baidu.com/s/1jGzbTBo" target="_blank" rel="noopener">http://pan.baidu.com/s/1jGzbTBo</a></li></ol><p><a href="https://www.jianshu.com/p/bcbe916f97e1" target="_blank" rel="noopener">文章来源</a></p><p>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Vim（Vi[Improved]）编辑器是功能强大的跨平台文本文件编辑工具，继承自Unix系统的Vi编辑器，支持Linux/Mac OS X/Windows系统，利用它可以建立、修改文本文件。进入Vim编辑程序，可以在终端输入下面的命令：&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="基础工具类" scheme="https://removeif.github.io/categories/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
      <category term="Vim" scheme="https://removeif.github.io/categories/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E7%B1%BB/Vim/"/>
    
    
      <category term="vim" scheme="https://removeif.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>redis分布式锁Redlock的实现</title>
    <link href="https://removeif.github.io/2019/08/22/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81Redlock%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://removeif.github.io/2019/08/22/redis分布式锁Redlock的实现.html</id>
    <published>2019-08-22T10:41:23.000Z</published>
    <updated>2019-08-23T01:20:17.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h2><blockquote><p>说道Redis分布式锁大部分人都会想到：<code>setnx+lua</code>，或者知道<code>set key value px milliseconds nx</code>。后一种方式的核心实现命令如下：</p></blockquote><a id="more"></a><figure class="highlight ruby hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 获取锁（unique_value可以是UUID等）</span><br><span class="line">SET resource_name unique_value NX PX <span class="hljs-number">30000</span></span><br><span class="line"></span><br><span class="line">- 释放锁（lua脚本中，一定要比较value，防止误解锁）</span><br><span class="line"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">"get"</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span></span><br><span class="line">    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">"del"</span>,KEYS[<span class="hljs-number">1</span>])</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">end</span></span><br></pre></td></tr></table></figure><p>这种实现方式有3大要点（也是面试概率非常高的地方）：</p><ol><li>set命令要用<code>set key value px milliseconds nx</code>；</li><li>value要具有唯一性；</li><li>释放锁时要验证value值，不能误解锁；</li></ol><p>事实上这类琐最大的缺点就是它加锁时只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：</p><ol><li>在Redis的master节点上拿到了锁；</li><li>但是这个加锁的key还没有同步到slave节点；</li><li>master故障，发生故障转移，slave节点升级为master节点；</li><li>导致锁丢失。</li></ol><p>正因为如此，Redis作者antirez基于分布式环境下提出了一种更高级的分布式锁的实现方式：<strong>Redlock</strong>。笔者认为，Redlock也是Redis所有分布式锁实现方式中唯一能让面试官高潮的方式。</p><h2 id="Redlock实现"><a href="#Redlock实现" class="headerlink" title="Redlock实现"></a>Redlock实现</h2><p>antirez提出的redlock算法大概是这样的：</p><p>在Redis的分布式环境中，我们假设有N个Redis master。这些节点<strong>完全互相独立，不存在主从复制或者其他集群协调机制</strong>。我们确保将在N个实例上使用与在Redis单实例下相同方法获取和释放锁。现在我们假设有5个Redis master节点，同时我们需要在5台服务器上面运行这些Redis实例，这样保证他们不会同时都宕掉。</p><p>为了取到锁，客户端应该执行以下操作:</p><ul><li>获取当前Unix时间，以毫秒为单位。</li><li>依次尝试从5个实例，使用相同的key和<strong>具有唯一性的value</strong>（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。</li><li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。<strong>当且仅当从大多数</strong>（N/2+1，这里是3个节点）<strong>的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功</strong>。</li><li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li><li>如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在<strong>所有的Redis实例上进行解锁</strong>（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</li></ul><h2 id="Redlock源码"><a href="#Redlock源码" class="headerlink" title="Redlock源码"></a>Redlock源码</h2><p>redisson已经有对redlock算法封装，接下来对其用法进行简单介绍，并对核心源码进行分析（假设5个redis实例）。</p><ul><li>POM依赖</li></ul><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>首先，我们来看一下redission封装的redlock算法实现的分布式锁用法，非常简单，跟重入锁（ReentrantLock）有点类似：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="hljs-keyword">new</span> Config();</span><br><span class="line">config.useSentinelServers().addSentinelAddress(<span class="hljs-string">"127.0.0.1:6369"</span>,<span class="hljs-string">"127.0.0.1:6379"</span>, <span class="hljs-string">"127.0.0.1:6389"</span>)</span><br><span class="line">        .setMasterName(<span class="hljs-string">"masterName"</span>)</span><br><span class="line">        .setPassword(<span class="hljs-string">"password"</span>).setDatabase(<span class="hljs-number">0</span>);</span><br><span class="line">RedissonClient redissonClient = Redisson.create(config);</span><br><span class="line"><span class="hljs-comment">// 还可以getFairLock(), getReadWriteLock()</span></span><br><span class="line">RLock redLock = redissonClient.getLock(<span class="hljs-string">"REDLOCK_KEY"</span>);</span><br><span class="line"><span class="hljs-keyword">boolean</span> isLock;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    isLock = redLock.tryLock();</span><br><span class="line">    <span class="hljs-comment">// 500ms拿不到锁, 就认为获取锁失败。10000ms即10s是锁失效时间。</span></span><br><span class="line">    isLock = redLock.tryLock(<span class="hljs-number">500</span>, <span class="hljs-number">10000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="hljs-keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="hljs-comment">//TODO if get lock success, do something;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 无论如何, 最后都要解锁</span></span><br><span class="line">    redLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="唯一ID"><a href="#唯一ID" class="headerlink" title="唯一ID"></a>唯一ID</h4><p>实现分布式锁的一个非常重要的点就是set的value要具有唯一性，redisson的value是怎样保证value的唯一性呢？答案是<strong>UUID+threadId</strong>。<strong>入口</strong>在redissonClient.getLock(“REDLOCK_KEY”)，源码在Redisson.java和RedissonLock.java中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> UUID id = UUID.randomUUID();</span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getLockName</span><span class="hljs-params">(<span class="hljs-keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> id + <span class="hljs-string">":"</span> + threadId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p>获取锁的代码为redLock.tryLock()或者redLock.tryLock(500, 10000, TimeUnit.MILLISECONDS)，两者的最终核心源码都是下面这段代码，只不过前者获取锁的默认租约时间（leaseTime）是LOCK_EXPIRATION_INTERVAL_SECONDS，即30s：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="hljs-function">RFuture&lt;T&gt; <span class="hljs-title">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> leaseTime, TimeUnit unit, <span class="hljs-keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">    <span class="hljs-comment">// 获取锁时向5个redis实例发送的命令</span></span><br><span class="line">    <span class="hljs-keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">              <span class="hljs-comment">// 首先分布式锁的KEY不能存在，如果确实不存在，那么执行hset命令（hset REDLOCK_KEY uuid+threadId 1），并通过pexpire设置失效时间（也是锁的租约时间）</span></span><br><span class="line">              <span class="hljs-string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                  <span class="hljs-string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                  <span class="hljs-string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                  <span class="hljs-string">"return nil; "</span> +</span><br><span class="line">              <span class="hljs-string">"end; "</span> +</span><br><span class="line">              <span class="hljs-comment">// 如果分布式锁的KEY已经存在，并且value也匹配，表示是当前线程持有的锁，那么重入次数加1，并且设置失效时间</span></span><br><span class="line">              <span class="hljs-string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                  <span class="hljs-string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                  <span class="hljs-string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                  <span class="hljs-string">"return nil; "</span> +</span><br><span class="line">              <span class="hljs-string">"end; "</span> +</span><br><span class="line">              <span class="hljs-comment">// 获取分布式锁的KEY的失效时间毫秒数</span></span><br><span class="line">              <span class="hljs-string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">              <span class="hljs-comment">// 这三个参数分别对应KEYS[1]，ARGV[1]和ARGV[2]</span></span><br><span class="line">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取锁的命令中，</p><ul><li><strong>KEYS[1]</strong>就是Collections.singletonList(getName())，表示分布式锁的key，即REDLOCK_KEY；</li><li><strong>ARGV[1]</strong>就是internalLockLeaseTime，即锁的租约时间，默认30s；</li><li><strong>ARGV[2]</strong>就是getLockName(threadId)，是获取锁时set的唯一值，即UUID+threadId：</li></ul><hr><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>释放锁的代码为redLock.unlock()，核心源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> RFuture&lt;Boolean&gt; <span class="hljs-title">unlockInnerAsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 向5个redis实例都执行如下命令</span></span><br><span class="line">    <span class="hljs-keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="hljs-comment">// 如果分布式锁KEY不存在，那么向channel发布一条消息</span></span><br><span class="line">            <span class="hljs-string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                <span class="hljs-string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                <span class="hljs-string">"return 1; "</span> +</span><br><span class="line">            <span class="hljs-string">"end;"</span> +</span><br><span class="line">            <span class="hljs-comment">// 如果分布式锁存在，但是value不匹配，表示锁已经被占用，那么直接返回</span></span><br><span class="line">            <span class="hljs-string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span><br><span class="line">                <span class="hljs-string">"return nil;"</span> +</span><br><span class="line">            <span class="hljs-string">"end; "</span> +</span><br><span class="line">            <span class="hljs-comment">// 如果就是当前线程占有分布式锁，那么将重入次数减1</span></span><br><span class="line">            <span class="hljs-string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><br><span class="line">            <span class="hljs-comment">// 重入次数减1后的值如果大于0，表示分布式锁有重入过，那么只设置失效时间，还不能删除</span></span><br><span class="line">            <span class="hljs-string">"if (counter &gt; 0) then "</span> +</span><br><span class="line">                <span class="hljs-string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">                <span class="hljs-string">"return 0; "</span> +</span><br><span class="line">            <span class="hljs-string">"else "</span> +</span><br><span class="line">                <span class="hljs-comment">// 重入次数减1后的值如果为0，表示分布式锁只获取过1次，那么删除这个KEY，并发布解锁消息</span></span><br><span class="line">                <span class="hljs-string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">                <span class="hljs-string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                <span class="hljs-string">"return 1; "</span>+</span><br><span class="line">            <span class="hljs-string">"end; "</span> +</span><br><span class="line">            <span class="hljs-string">"return nil;"</span>,</span><br><span class="line">            <span class="hljs-comment">// 这5个参数分别对应KEYS[1]，KEYS[2]，ARGV[1]，ARGV[2]和ARGV[3]</span></span><br><span class="line">            Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&amp;mid=2247485917&amp;idx=1&amp;sn=289fd9fcd1c8141111b8bc337e8c5353&amp;chksm=fb0be349cc7c6a5f1c525c97f2d8a90d712475e58bcf79b3b1f8d83f4cd8a0fa617acf1de955&amp;token=1885824046&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">文章来源</a></p><p>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;普通实现&quot;&gt;&lt;a href=&quot;#普通实现&quot; class=&quot;headerlink&quot; title=&quot;普通实现&quot;&gt;&lt;/a&gt;普通实现&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;说道Redis分布式锁大部分人都会想到：&lt;code&gt;setnx+lua&lt;/code&gt;，或者知道&lt;code&gt;set key value px milliseconds nx&lt;/code&gt;。后一种方式的核心实现命令如下：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="redis" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
    
    
      <category term="redis" scheme="https://removeif.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>中华人民共和国消费者权益保护法</title>
    <link href="https://removeif.github.io/2019/08/21/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E6%B6%88%E8%B4%B9%E8%80%85%E6%9D%83%E7%9B%8A%E4%BF%9D%E6%8A%A4%E6%B3%95.html"/>
    <id>https://removeif.github.io/2019/08/21/中华人民共和国消费者权益保护法.html</id>
    <published>2019-08-21T09:43:57.000Z</published>
    <updated>2019-09-05T14:23:07.387Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基本信息</p></blockquote><p>发文字号：主席令第11号</p><p>效力级别：法律</p><p>时效性：已被修订</p><p>发布日期：1993-10-31</p><p>实施日期：1994-01-01</p><p>发布机关：全国人大常委会<br><a id="more"></a></p><blockquote><p>法律修订</p></blockquote><p>１９９３年１０月３１日第八届全国人民代表大会常务委员会第四次会议通过</p><p><a href="https://duxiaofa.baidu.com/detail?cid=bf606ce23ba8838dad27f27c64caf1be_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国消费者权益保护法（2013修正）</a></p><p><a href="https://duxiaofa.baidu.com/detail?cid=469392616d5672734f84e31e21cf12ac_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国消费者权益保护法（2009修正）</a></p><blockquote><p>正文</p></blockquote><h4 id="第一章-总则"><a href="#第一章-总则" class="headerlink" title="第一章　总则"></a>第一章　总则</h4><p><strong>第一条</strong></p><p>为保护消费者的合法权益，维护社会经济秩序，促进社会主义市场经济健康发展，制定本法。</p><p><strong>第二条</strong></p><p>消费者为生活消费需要购买、使用商品或者接受服务，其权益受本法保护；本法未作规定的，受其他有关法律、法规保护。</p><p><strong>第三条</strong></p><p>经营者为消费者提供其生产、销售的商品或者提供服务，应当遵守本法；本法未作出规定的，应当遵守其他有关法律、法规。</p><p><strong>第四条</strong></p><p>经营者与消费者进行交易，应当遵循自愿、平等、公平、诚实信用的原则。</p><p><strong>第五条</strong></p><p>国家保护消费者的合法权益不受侵害。 国家采取措施，保障消费者依法行使权利，维护消费者的合法权益。</p><p><strong>第六条</strong></p><p>保护消费者的合法权益是全社会的共同责任。 国家鼓励、支持一切组织和个人对损害消费者合法权益的行为进行社会监督。 大众传播媒介应当做好维护消费者合法权益的宣传，对损害消费者合法权益的行为进行舆论监督。</p><h4 id="第二章-消费者的权利"><a href="#第二章-消费者的权利" class="headerlink" title="第二章　消费者的权利"></a>第二章　消费者的权利</h4><p><strong>第七条</strong></p><p>消费者在购买、使用商品和接受服务时享有人身、财产安全不受损害的权利。 消费者有权要求经营者提供的商品和服务，符合保障人身、财产安全的要求。</p><p><strong>第八条</strong></p><p>消费者享有知悉其购买、使用的商品或者接受的服务的真实情况的权利。 消费者有权根据商品或者服务的不同情况，要求经营者提供商品的价格、产地、生产者、用途、性能、规格、等级、主要成份、生产日期、有效期限、检验合格证明、使用方法说明书、售后服务，或者服务的内容、规格、费用等有关情况。</p><p><strong>第九条</strong></p><p>消费者享有自主选择商品或者服务的权利。 消费者有权自主选择提供商品或者服务的经营者，自主选择商品品种或者服务方式，自主决定购买或者不购买任何一种商品、接受或者不接受任何一项服务。 消费者在自主选择商品或者服务时，有权进行比较、鉴别和挑选。</p><p><strong>第十条</strong></p><p>消费者享有公平交易的权利。 消费者在购买商品或者接受服务时，有权获得质量保障、价格合理、计量正确等公平交易条件，有权拒绝经营者的强制交易行为。</p><p><strong>第十一条</strong></p><p>消费者因购买、使用商品或者接受服务受到人身、财产损害的，享有依法获得赔偿的权利。</p><p><strong>第十二条</strong></p><p>消费者享有依法成立维护自身合法权益的社会团体的权利。</p><p><strong>第十三条</strong></p><p>消费者享有获得有关消费和消费者权益保护方面的知识的权利。 消费者应当努力掌握所需商品或者服务的知识和使用技能，正确使用商品，提高自我保护意识。</p><p><strong>第十四条</strong></p><p>消费者在购买、使用商品和接受服务时，享有其人格尊严、民族风俗习惯得到尊重的权利。</p><p><strong>第十五条</strong></p><p>消费者享有对商品和服务以及保护消费者权益工作进行监督的权利。 消费者有权检举、控告侵害消费者权益的行为和国家机关及其工作人员在保护消费者权益工作中的违法失职行为，有权对保护消费者权益工作提出批评、建议。</p><h4 id="第三章-经营者的义务"><a href="#第三章-经营者的义务" class="headerlink" title="第三章　经营者的义务"></a>第三章　经营者的义务</h4><p><strong>第十六条</strong></p><p>经营者向消费者提供商品或者服务，应当依照《中华人民共和国产品质量法》和其他有关法律、法规的规定履行义务。 经营者和消费者有约定的，应当按照约定履行义务，但双方的约定不得违背法律、法规的规定。</p><p><strong>第十七条</strong></p><p>经营者应当听取消费者对其提供的商品或者服务的意见，接受消费者的监督。</p><p><strong>第十八条</strong></p><p>经营者应当保证其提供的商品或者服务符合保障人身、财产安全的要求。对可能危及人身、财产安全的商品和服务，应当向消费者作出真实的说明和明确的警示，并说明和标明正确使用商品或者接受服务的方法以及防止危害发生的方法。 经营者发现其提供的商品或者服务存在严重缺陷，即使正确使用商品或者接受服务仍然可能对人身、财产安全造成危害的，应当立即向有关行政部门报告和告知消费者，并采取防止危害发生的措施。</p><p><strong>第十九条</strong></p><p>经营者应当向消费者提供有关商品或者服务的真实信息，不得作引人误解的虚假宣传。 经营者对消费者就其提供的商品或者服务的质量和使用方法等问题提出的询问，应当作为真实、明确的答复。 商店提供商品应当明码标价。</p><p><strong>第二十条</strong></p><p>经营者应当标明其真实名称和标记。 租赁他人柜台或者场地的经营者，应当标明其真实名称和标记。</p><p><strong>第二十一条</strong></p><p>经营者提供商品或者服务，应当按照国家有关规定或者商业惯例向消费者出具购货凭证或者服务单据；消费者索要购货凭证或者服务单据的，经营者必须出具。</p><p><strong>第二十二条</strong></p><p>经营者应当保证在正常使用商品或者接受服务的情况下其提供的商品或者服务应当具有的质量、性能、用途和有效期限；但消费者在购买该商品或者接受该服务前已经知道其存在瑕疵的除外。 经营者以广告、产品说明、实物样品或者其他方式表明商品或者服务的质量状况的，应当保证其提供的商品或者服务的实际质量与表明的质量状况相符。</p><p><strong>第二十三条</strong></p><p>经营者提供商品或者服务，按照国家规定或者与消费者的约定，承担包修、包换、包退或者其他责任的，应当按照国家规定或者约定履行，不得故意拖延或者无理拒绝。</p><p><strong>第二十四条</strong></p><p>经营者不得以格式合同、通知、声明、店堂告示等方式作出对消费者不公平、不合理的规定，或者减轻、免除其损害消费者合法权益应当承担的民事责任。 格式合同、通知、声明、店堂告示等含有前款所列内容的，其内容无效。</p><p><strong>第二十五条</strong></p><p>经营者不得对消费者进行侮辱、诽谤，不得搜查消费者的身体及其携带的物品，不得侵犯消费者的人身自由。</p><h4 id="第四章-国家对消费者合法权益的保护"><a href="#第四章-国家对消费者合法权益的保护" class="headerlink" title="第四章　国家对消费者合法权益的保护"></a>第四章　国家对消费者合法权益的保护</h4><p><strong>第二十六条</strong></p><p>国家制定有关消费者权益的法律、法规和政策时，应听取消费者的意见和要求。</p><p><strong>第二十七条</strong></p><p>各级人民政府应当加强领导，组织、协调、督促有关行政部门做好保护消费者合法权益的工作。 各级人民政府应当加强监督，预防危害消费者人身、财产安全行为的发生，及时制止危害消费者人身、财产安全的行为。</p><p><strong>第二十八条</strong></p><p>各级人民政府工商行政管理部门和其他有关行政部门应当依照法律、法规的规定，在各自的职责范围内，采取措施，保护消费者的合法权益。 有关行政部门应当听取消费者及其社会团体对经营者交易行为、商品和服务质量问题的意见，及时调查处理。</p><p><strong>第二十九条</strong></p><p>有关国家机关应当依照法律、法规的规定，惩处经营者在提供商品和服务中侵害消费者合法权益的违法犯罪行为。</p><p><strong>第三十条</strong></p><p>人民法院应当采取措施，方便消费者提起诉讼。对符合《中华人民共和国民事诉讼法》起诉条件的消费者权益争议，必须受理，及时审理。</p><h4 id="第五章-消费者组织"><a href="#第五章-消费者组织" class="headerlink" title="第五章　消费者组织"></a>第五章　消费者组织</h4><p><strong>第三十一条</strong></p><p>消费者协会和其他消费者组织是依法成立的对商品和服务进行社会监督的保护消费者合法权益的社会团体。</p><p><strong>第三十二条</strong></p><p>消费者协会履行下列职能： </p><ul><li>（一）向消费者提供消费信息和咨询服务； </li><li>（二）参与有关行政部门对商品和服务的监督、检查； </li><li>（三）就有关消费者合法权益的问题，向有关行政部门反映、查询，提出建议； </li><li>（四）受理消费者的投诉，并对投诉事项进行调查、调解； </li><li>（五）投诉事项涉及商品和服务质量问题的，可以提请鉴定部门鉴定，鉴定部门应当告知鉴定结论； </li><li>（六）就损害消费者合法权益的行为，支持受损害的消费者提起诉讼；</li><li>（七）对损害消费者合法权益的行为，通过大众传播媒介予以揭露、批评。 各级人民政府对消费者协会履行职能应当予以支持。</li></ul><p><strong>第三十三条</strong></p><p>消费者组织不得从事商品经营和营利性服务，不得以牟利为目的向社会推荐商品和服务。</p><h4 id="第六章-争议的解决"><a href="#第六章-争议的解决" class="headerlink" title="第六章　争议的解决"></a>第六章　争议的解决</h4><p><strong>第三十四条</strong></p><p>消费者和经营者发生消费者权益争议的，可以通过下列途径解决： </p><ul><li>（一）与经营者协商和解； </li><li>（二）请求消费者协会调解； </li><li>（三）向有关行政部门申诉； </li><li>（四）根据与经营者达成的仲裁协议提请仲裁机构仲裁； （五）向人民法院提起诉讼。</li></ul><p><strong>第三十五条</strong></p><p>消费者在购买、使用商品时，其合法权益受到损害的，可以向销售者要求赔偿。销售者赔偿后，属于生产者的责任或者属于向销售者提供商品的其他销售者的责任的，销售者有权向生产者或者其他销售者追偿。 消费者或者其他受害人因商品缺陷造成人身、财产损害的，可以向销售者要求赔偿，也可以向生产者要求赔偿。属于生产者责任的，销售者赔偿后，有权向生产者追偿。属于销售者责任的，生产者赔偿后，有权向销售者追偿。 消费者在接受服务时，其合法权益受到损害的，可以向服务者要求赔偿。</p><p><strong>第三十六条</strong></p><p>消费者在购买、使用商品或者接受服务时，其合法权益受到损害，因原企业分立、合并的，可以向变更后承受其权利义务的企业要求赔偿。</p><p><strong>第三十七条</strong></p><p>使用他人营业执照的违法经营者提供商品或者服务，损害消费者合法权益的，消费者可以向其要求赔偿，也可以向营业执照的持有人要求赔偿。</p><p><strong>第三十八条</strong></p><p>消费者在展销会、租赁柜台购买商品或者接受服务，其合法权益受到损害的，可以向销售者或者服务者要求赔偿。展销会结束或者柜台租赁期满后，也可以向展销会的举办者、柜台的出租者要求赔偿。展销会的举办者、柜台的出租者赔偿后，有权向销售者或者服务者追偿。</p><p><strong>第三十九条</strong></p><p>消费者因经营者利用虚假广告提供商品或者服务，其合法权益受到损害的，可以向经营者要求赔偿。广告的经营者发布虚假广告的，消费者可以请求行政主管部门予以惩处。广告的经营者不得提供经营者的真实名称、地址的，应当承担赔偿责任。</p><h4 id="第七章-法律责任"><a href="#第七章-法律责任" class="headerlink" title="第七章　法律责任"></a>第七章　法律责任</h4><p><strong>第四十条</strong></p><p>经营者提供商品或者服务有下列情形之一的，除本法另有规定外，应当依照《中华人民共和国产品质量法》和其他有关法律、法规的规定，承担民事责任： </p><ul><li>（一）商品存在缺陷的； </li><li>（二）不具备商品应当具备的使用性能而出售时未作说明的； </li><li>（三）不符合在商品或者其包装上注明采用的商品标准的； </li><li>（四）不符合商品说明、实物样品等方式表明的质量状况的； </li><li>（五）生产国家明令淘汰的商品或者销售失效、变质的商品的； </li><li>（六）销售的商品数量不足的； </li><li>（七）服务的内容和费用违反约定的； </li><li>（八）对消费者提出的修理、重作、更换、退货、补足商品数量、退还货款和服务费用或者赔偿损失的要求，故意拖延或者无理拒绝的； </li><li>（九）法律、法规规定的其他损害消费者权益的情形。</li></ul><p><strong>第四十一条</strong></p><p>经营者提供商品或者服务，造成消费者或者其他受害人人身伤害的，应当支付医疗费、治疗期间的护理费、因误工减少的收入等费用，造成残疾的，还应当支付残疾者生活自助具费、生活补助费、残疾赔偿金以及由其扶养的人所必需的生活费等费用；构成犯罪的，依法追究刑事责任。</p><p><strong>第四十二条</strong></p><p>经营者提供商品或者服务，造成消费者或者其他受害人死亡的，应当支付丧葬费、死亡赔偿金以及由死者生前扶养的人所必需的生活费等费用；构成犯罪的，依法追究刑事责任。</p><p><strong>第四十三条</strong></p><p>经营者违反本法第二十五条规定，侵害消费者的人格尊严或者侵犯消费者人身自由的，应当停止侵害、恢复名誉、消除影响、赔礼道歉，并赔偿损失。</p><p><strong>第四十四条</strong></p><p>经营者提供商品或者服务，造成消费者财产损害的，应当按照消费者的要求，以修理、重作、更换、退货、补足商品数量、退还货款和服务费用或者赔偿损失等方式承担民事责任。消费者与经营者另有约定的，按照约定履行。</p><p><strong>第四十五条</strong></p><p>对国家规定或者经营者与消费者约定包修、包换、包退的商品，经营者应当负责修理、更换或者退货。在保修期内两次修理仍不能正常使用的，经营者应当负责更换或者退货。 对包修、包换、包退的大件商品，消费者要求经营者修理、更换、退货的，经营者应当承担运输等合理费用。</p><p><strong>第四十六条</strong></p><p>经营者以邮购方式提供商品的，应当按照约定提供。未按照约定提供的，应当按照消费者的要求履行约定或者退回货款；并应当承担消费者必须支付的合理费用。</p><p><strong>第四十七条</strong></p><p>经营者以预收款方式提供商品或者服务的，应当按照约定提供。未按照约定提供的，应当按照消费者的要求履行约定或者退回预付款；并应当承担预付款的利息、消费者必须支付的合理费用。</p><p><strong>第四十八条</strong></p><p>依法经有关行政部门认定为不合格的商品，消费者要求退货的，经营者应当负责退货。</p><p><strong>第四十九条</strong></p><p>经营者提供商品或者服务有欺诈行为的，应当按照消费者的要求增加赔偿其受到的损失，增加赔偿的金额为消费者购买商品的价款或者接受服务的费用的一倍。</p><p><strong>第五十条</strong></p><p>经营者有下列情形之一，《中华人民共和国产品质量法》和其他有关法律、法规对处罚机关和处罚方式有规定的，依照法律、法规的规定执行；法律、法规未作规定的，由工商行政管理部门责令改正，可以根据情节单处或者并处警告、没收违法所得、处以违法所得一倍以上五倍以下的罚款，没有违法所得的处以一万元以下的罚款；情节严重的，责令停业整顿、吊销营业执照： </p><ul><li>（一）生产、销售的商品不符合保障人身、财产安全要求的； </li><li>（二）在商品中掺杂、掺假，以假充真，以次充好，或者以不合格商品冒充合格商品的；</li><li>（三）生产国家明令淘汰的商品或者销售失效、变质的商品的； </li><li>（四）伪造商品的产地，伪造或者冒用他人的厂名、厂址，伪造或者冒用认证标志、名优标志等质量标志的； </li><li>（五）销售的商品应当检验、检疫而未检验、检疫或者伪造检验、检疫结果的； </li><li>（六）对商品或者服务作引人误解的虚假宣传的； </li><li>（七）对消费者提出的修理、重作、更换、退货、补足商品数量、退还货款和服务费用或者赔偿损失的要求，故意拖延或者无理拒绝的； </li><li>（八）侵害消费者人格尊严或者侵犯消费者人身自由的； </li><li>（九）法律、法规规定的对损害消费者权益应当予以处罚的其他情形。</li></ul><p><strong>第五十一条</strong></p><p>经营者对行政处罚决定不服的，可以自收到处罚决定之日起十五日内向上一级机关申请复议，对复议决定不服的，可以自收到复议决定书之日起十五日内向人民法院提起诉讼；也可以直接向人民法院提起诉讼。</p><p><strong>第五十二条</strong></p><p>以暴力、威胁等方法阻碍有关行政部门工作人员依法执行职务的，依法追究刑事责任；拒绝、阻碍有关行政部门工作人员依法执行职务，未使用暴力、威胁方法的，由公安机关依照《中华人民共和国治安管理处罚条例》的规定处罚。</p><p><strong>第五十三条</strong></p><p>国家机关工作人员玩忽职守或者包庇经营者侵害消费者合法权益的行为的，由其所在单位或者上级机关给予行政处分；情节严重，构成犯罪的，依法追究刑事责任。</p><h4 id="第八章-附则"><a href="#第八章-附则" class="headerlink" title="第八章　附则"></a>第八章　附则</h4><p><strong>第五十四条</strong></p><p>农民购买、使用直接用于农业生产的生产资料，参照本法执行。</p><p><strong>第五十五条</strong></p><p>本法自１９９４年１月１日起施行。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基本信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;发文字号：主席令第11号&lt;/p&gt;
&lt;p&gt;效力级别：法律&lt;/p&gt;
&lt;p&gt;时效性：已被修订&lt;/p&gt;
&lt;p&gt;发布日期：1993-10-31&lt;/p&gt;
&lt;p&gt;实施日期：1994-01-01&lt;/p&gt;
&lt;p&gt;发布机关：全国人大常委会&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="法律" scheme="https://removeif.github.io/categories/%E6%B3%95%E5%BE%8B/"/>
    
    
      <category term="法律" scheme="https://removeif.github.io/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>中华人民共和国刑事诉讼法</title>
    <link href="https://removeif.github.io/2019/08/21/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%88%91%E4%BA%8B%E8%AF%89%E8%AE%BC%E6%B3%95.html"/>
    <id>https://removeif.github.io/2019/08/21/中华人民共和国刑事诉讼法.html</id>
    <published>2019-08-21T09:43:56.000Z</published>
    <updated>2019-08-31T11:11:24.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基本信息</p></blockquote><p>发文字号：中华人民共和国主席令第十号</p><p>效力级别法律：时效性现行有效</p><p>发布日期：2018-10-26</p><p>实施日期：2018-10-26</p><p>发布机关：全国人大常委会<br><a id="more"></a></p><blockquote><p>法律修订</p></blockquote><p>1979年7月1日第五届全国人民代表大会第二次会议通过</p><p>根据1996年3月17日第八届全国人民代表大会第四次会议《关于修改〈中华人民共和国刑事诉讼法〉的决定》第一次修正</p><p>根据2012年3月14日第十一届全国人民代表大会第五次会议《关于修改〈中华人民共和国刑事诉讼法〉的决定》第二次修正</p><p>根据2018年10月26日第十三届全国人民代表大会常务委员会第六次会议《关于修改〈中华人民共和国刑事诉讼法〉的决定》第三次修正</p><p><a href="https://duxiaofa.baidu.com/detail?cid=c269c27a87a7a20a52396a7dfbdfb441_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国刑事诉讼法（2012修正）</a></p><p><a href="https://duxiaofa.baidu.com/detail?cid=f87afec08c64f28df7deb07f9ed81b8b_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国刑事诉讼法（1996修正）</a></p><p><a href="https://duxiaofa.baidu.com/detail?cid=d9566b54dc70e2834d34e9b67d285233_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国刑事诉讼法（1979修正）</a></p><blockquote><p>正文</p></blockquote><h3 id="第一编-总-则"><a href="#第一编-总-则" class="headerlink" title="第一编　总　　则"></a>第一编　总　　则</h3><h4 id="第一章-任务和基本原则"><a href="#第一章-任务和基本原则" class="headerlink" title="第一章　任务和基本原则"></a>第一章　任务和基本原则</h4><p><strong>第一条</strong></p><p>为了保证刑法的正确实施，惩罚犯罪，保护人民，保障国家安全和社会公共安全，维护社会主义社会秩序，根据宪法，制定本法。</p><p><strong>第二条</strong></p><p>中华人民共和国<em>刑事诉讼法</em>的任务，是保证准确、及时地查明犯罪事实，正确应用法律，惩罚犯罪分子，保障无罪的人不受刑事追究，教育公民自觉遵守法律，积极同犯罪行为作斗争，维护社会主义法制，尊重和保障人权，保护公民的人身权利、财产权利、民主权利和其他权利，保障社会主义建设事业的顺利进行。</p><p><strong>第三条</strong></p><p>对刑事案件的侦查、拘留、执行逮捕、预审，由公安机关负责。检察、批准逮捕、检察机关直接受理的案件的侦查、提起公诉，由人民检察院负责。审判由人民法院负责。除法律特别规定的以外，其他任何机关、团体和个人都无权行使这些权力。 人民法院、人民检察院和公安机关进行刑事诉讼，必须严格遵守本法和其他法律的有关规定。</p><p><strong>第四条</strong></p><p>国家安全机关依照法律规定，办理危害国家安全的刑事案件，行使与公安机关相同的职权。</p><p><strong>第五条</strong></p><p>人民法院依照法律规定独立行使审判权，人民检察院依照法律规定独立行使检察权，不受行政机关、社会团体和个人的干涉。</p><p><strong>第六条</strong></p><p>人民法院、人民检察院和公安机关进行刑事诉讼，必须依靠群众，必须以事实为根据，以法律为准绳。对于一切公民，在适用法律上一律平等，在法律面前，不允许有任何特权。</p><p><strong>第七条</strong></p><p>人民法院、人民检察院和公安机关进行刑事诉讼，应当分工负责，互相配合，互相制约，以保证准确有效地执行法律。</p><p><strong>第八条</strong></p><p>人民检察院依法对刑事诉讼实行法律监督。</p><p><strong>第九条</strong></p><p>各民族公民都有用本民族语言文字进行诉讼的权利。人民法院、人民检察院和公安机关对于不通晓当地通用的语言文字的诉讼参与人，应当为他们翻译。 在少数民族聚居或者多民族杂居的地区，应当用当地通用的语言进行审讯，用当地通用的文字发布判决书、布告和其他文件。</p><p><strong>第十条</strong></p><p>人民法院审判案件，实行两审终审制。</p><p><strong>第十一条</strong></p><p>人民法院审判案件，除本法另有规定的以外，一律公开进行。被告人有权获得辩护，人民法院有义务保证被告人获得辩护。</p><p><strong>第十二条</strong></p><p>未经人民法院依法判决，对任何人都不得确定有罪。</p><p><strong>第十三条</strong></p><p>人民法院审判案件，依照本法实行人民陪审员陪审的制度。</p><p><strong>第十四条</strong></p><p>人民法院、人民检察院和公安机关应当保障犯罪嫌疑人、被告人和其他诉讼参与人依法享有的辩护权和其他诉讼权利。 诉讼参与人对于审判人员、检察人员和侦查人员侵犯公民诉讼权利和人身侮辱的行为，有权提出控告。</p><p><strong>第十五条</strong></p><p>犯罪嫌疑人、被告人自愿如实供述自己的罪行，承认指控的犯罪事实，愿意接受处罚的，可以依法从宽处理。</p><p><strong>第十六条</strong></p><p>有下列情形之一的，不追究刑事责任，已经追究的，应当撤销案件，或者不起诉，或者终止审理，或者宣告无罪： </p><ul><li>（一）情节显著轻微、危害不大，不认为是犯罪的；</li><li>（二）犯罪已过追诉时效期限的；</li><li>（三）经特赦令免除刑罚的；</li><li>（四）依照刑法告诉才处理的犯罪，没有告诉或者撤回告诉的；</li><li>（五）犯罪嫌疑人、被告人死亡的； </li><li>（六）其他法律规定免予追究刑事责任的。</li></ul><p><strong>第十七条</strong></p><p>对于外国人犯罪应当追究刑事责任的，适用本法的规定。 对于享有外交特权和豁免权的外国人犯罪应当追究刑事责任的，通过外交途径解决。</p><p><strong>第十八条</strong></p><p>根据中华人民共和国缔结或者参加的国际条约，或者按照互惠原则，我国司法机关和外国司法机关可以相互请求刑事司法协助。</p><h4 id="第二章-管-辖"><a href="#第二章-管-辖" class="headerlink" title="第二章　管　　辖"></a>第二章　管　　辖</h4><p><strong>第十九条</strong></p><p>刑事案件的侦查由公安机关进行，法律另有规定的除外。 人民检察院在对诉讼活动实行法律监督中发现的司法工作人员利用职权实施的非法拘禁、刑讯逼供、非法搜查等侵犯公民权利、损害司法公正的犯罪，可以由人民检察院立案侦查。对于公安机关管辖的国家机关工作人员利用职权实施的重大犯罪案件，需要由人民检察院直接受理的时候，经省级以上人民检察院决定，可以由人民检察院立案侦查。 自诉案件，由人民法院直接受理。</p><p><strong>第二十条</strong></p><p>基层人民法院管辖第一审普通刑事案件，但是依照本法由上级人民法院管辖的除外。</p><p><strong>第二十一条</strong></p><p>中级人民法院管辖下列第一审刑事案件：</p><ul><li>（一）危害国家安全、恐怖活动案件； </li><li>（二）可能判处无期徒刑、死刑的案件。</li></ul><p><strong>第二十二条</strong></p><p>高级人民法院管辖的第一审刑事案件，是全省（自治区、直辖市）性的重大刑事案件。</p><p><strong>第二十三条</strong></p><p>最高人民法院管辖的第一审刑事案件，是全国性的重大刑事案件。</p><p><strong>第二十四条</strong></p><p>上级人民法院在必要的时候，可以审判下级人民法院管辖的第一审刑事案件；下级人民法院认为案情重大、复杂需要由上级人民法院审判的第一审刑事案件，可以请求移送上一级人民法院审判。</p><p><strong>第二十五条</strong></p><p>刑事案件由犯罪地的人民法院管辖。如果由被告人居住地的人民法院审判更为适宜的，可以由被告人居住地的人民法院管辖。</p><p><strong>第二十六条</strong></p><p>几个同级人民法院都有权管辖的案件，由最初受理的人民法院审判。在必要的时候，可以移送主要犯罪地的人民法院审判。</p><p><strong>第二十七条</strong></p><p>上级人民法院可以指定下级人民法院审判管辖不明的案件，也可以指定下级人民法院将案件移送其他人民法院审判。</p><p><strong>第二十八条</strong></p><p>专门人民法院案件的管辖另行规定。</p><h4 id="第三章-回-避"><a href="#第三章-回-避" class="headerlink" title="第三章　回　　避"></a>第三章　回　　避</h4><p><strong>第二十九条</strong></p><p>审判人员、检察人员、侦查人员有下列情形之一的，应当自行回避，当事人及其法定代理人也有权要求他们回避：</p><ul><li>（一）是本案的当事人或者是当事人的近亲属的； </li><li>（二）本人或者他的近亲属和本案有利害关系的； </li><li>（三）担任过本案的证人、鉴定人、辩护人、诉讼代理人的； </li><li>（四）与本案当事人有其他关系，可能影响公正处理案件的。</li></ul><p><strong>第三十条</strong></p><p>审判人员、检察人员、侦查人员不得接受当事人及其委托的人的请客送礼，不得违反规定会见当事人及其委托的人。 审判人员、检察人员、侦查人员违反前款规定的，应当依法追究法律责任。当事人及其法定代理人有权要求他们回避。</p><p><strong>第三十一条</strong></p><p>审判人员、检察人员、侦查人员的回避，应当分别由院长、检察长、公安机关负责人决定；院长的回避，由本院审判委员会决定；检察长和公安机关负责人的回避，由同级人民检察院检察委员会决定。 对侦查人员的回避作出决定前，侦查人员不能停止对案件的侦查。 对驳回申请回避的决定，当事人及其法定代理人可以申请复议一次。</p><p><strong>第三十二条</strong></p><p>本章关于回避的规定适用于书记员、翻译人员和鉴定人。 辩护人、诉讼代理人可以依照本章的规定要求回避、申请复议。</p><h4 id="第四章-辩护与代理"><a href="#第四章-辩护与代理" class="headerlink" title="第四章　辩护与代理"></a>第四章　辩护与代理</h4><p><strong>第三十三条</strong></p><p>犯罪嫌疑人、被告人除自己行使辩护权以外，还可以委托一至二人作为辩护人。下列的人可以被委托为辩护人：</p><ul><li>（一）律师； </li><li>（二）人民团体或者犯罪嫌疑人、被告人所在单位推荐的人； </li><li>（三）犯罪嫌疑人、被告人的监护人、亲友。 正在被执行刑罚或者依法被剥夺、限制人身自由的人，不得担任辩护人。 被开除公职和被吊销律师、公证员执业证书的人，不得担任辩护人，但系犯罪嫌疑人、被告人的监护人、近亲属的除外。</li></ul><p><strong>第三十四条</strong></p><p>犯罪嫌疑人自被侦查机关第一次讯问或者采取强制措施之日起，有权委托辩护人；在侦查期间，只能委托律师作为辩护人。被告人有权随时委托辩护人。 侦查机关在第一次讯问犯罪嫌疑人或者对犯罪嫌疑人采取强制措施的时候，应当告知犯罪嫌疑人有权委托辩护人。人民检察院自收到移送审查起诉的案件材料之日起三日以内，应当告知犯罪嫌疑人有权委托辩护人。人民法院自受理案件之日起三日以内，应当告知被告人有权委托辩护人。犯罪嫌疑人、被告人在押期间要求委托辩护人的，人民法院、人民检察院和公安机关应当及时转达其要求。 犯罪嫌疑人、被告人在押的，也可以由其监护人、近亲属代为委托辩护人。 辩护人接受犯罪嫌疑人、被告人委托后，应当及时告知办理案件的机关。</p><p><strong>第三十五条</strong></p><p>犯罪嫌疑人、被告人因经济困难或者其他原因没有委托辩护人的，本人及其近亲属可以向法律援助机构提出申请。对符合法律援助条件的，法律援助机构应当指派律师为其提供辩护。 犯罪嫌疑人、被告人是盲、聋、哑人，或者是尚未完全丧失辨认或者控制自己行为能力的精神病人，没有委托辩护人的，人民法院、人民检察院和公安机关应当通知法律援助机构指派律师为其提供辩护。 犯罪嫌疑人、被告人可能被判处无期徒刑、死刑，没有委托辩护人的，人民法院、人民检察院和公安机关应当通知法律援助机构指派律师为其提供辩护。</p><p><strong>第三十六条</strong></p><p>法律援助机构可以在人民法院、看守所等场所派驻值班律师。犯罪嫌疑人、被告人没有委托辩护人，法律援助机构没有指派律师为其提供辩护的，由值班律师为犯罪嫌疑人、被告人提供法律咨询、程序选择建议、申请变更强制措施、对案件处理提出意见等法律帮助。 人民法院、人民检察院、看守所应当告知犯罪嫌疑人、被告人有权约见值班律师，并为犯罪嫌疑人、被告人约见值班律师提供便利。</p><p><strong>第三十七条</strong></p><p>辩护人的责任是根据事实和法律，提出犯罪嫌疑人、被告人无罪、罪轻或者减轻、免除其刑事责任的材料和意见，维护犯罪嫌疑人、被告人的诉讼权利和其他合法权益。</p><p><strong>第三十八条</strong></p><p>辩护律师在侦查期间可以为犯罪嫌疑人提供法律帮助；代理申诉、控告；申请变更强制措施；向侦查机关了解犯罪嫌疑人涉嫌的罪名和案件有关情况，提出意见。</p><p><strong>第三十九条</strong></p><p>辩护律师可以同在押的犯罪嫌疑人、被告人会见和通信。其他辩护人经人民法院、人民检察院许可，也可以同在押的犯罪嫌疑人、被告人会见和通信。 辩护律师持律师执业证书、律师事务所证明和委托书或者法律援助公函要求会见在押的犯罪嫌疑人、被告人的，看守所应当及时安排会见，至迟不得超过四十八小时。 危害国家安全犯罪、恐怖活动犯罪案件，在侦查期间辩护律师会见在押的犯罪嫌疑人，应当经侦查机关许可。上述案件，侦查机关应当事先通知看守所。 辩护律师会见在押的犯罪嫌疑人、被告人，可以了解案件有关情况，提供法律咨询等；自案件移送审查起诉之日起，可以向犯罪嫌疑人、被告人核实有关证据。辩护律师会见犯罪嫌疑人、被告人时不被监听。 辩护律师同被监视居住的犯罪嫌疑人、被告人会见、通信，适用第一款、第三款、第四款的规定。</p><p><strong>第四十条</strong></p><p>辩护律师自人民检察院对案件审查起诉之日起，可以查阅、摘抄、复制本案的案卷材料。其他辩护人经人民法院、人民检察院许可，也可以查阅、摘抄、复制上述材料。</p><p><strong>第四十一条</strong></p><p>辩护人认为在侦查、审查起诉期间公安机关、人民检察院收集的证明犯罪嫌疑人、被告人无罪或者罪轻的证据材料未提交的，有权申请人民检察院、人民法院调取。</p><p><strong>第四十二条</strong></p><p>辩护人收集的有关犯罪嫌疑人不在犯罪现场、未达到刑事责任年龄、属于依法不负刑事责任的精神病人的证据，应当及时告知公安机关、人民检察院。</p><p><strong>第四十三条</strong></p><p>辩护律师经证人或者其他有关单位和个人同意，可以向他们收集与本案有关的材料，也可以申请人民检察院、人民法院收集、调取证据，或者申请人民法院通知证人出庭作证。 辩护律师经人民检察院或者人民法院许可，并且经被害人或者其近亲属、被害人提供的证人同意，可以向他们收集与本案有关的材料。</p><p><strong>第四十四条</strong></p><p>辩护人或者其他任何人，不得帮助犯罪嫌疑人、被告人隐匿、毁灭、伪造证据或者串供，不得威胁、引诱证人作伪证以及进行其他干扰司法机关诉讼活动的行为。 违反前款规定的，应当依法追究法律责任，辩护人涉嫌犯罪的，应当由办理辩护人所承办案件的侦查机关以外的侦查机关办理。辩护人是律师的，应当及时通知其所在的律师事务所或者所属的律师协会。</p><p><strong>第四十五条</strong></p><p>在审判过程中，被告人可以拒绝辩护人继续为他辩护，也可以另行委托辩护人辩护。</p><p><strong>第四十六条</strong></p><p>公诉案件的被害人及其法定代理人或者近亲属，附带民事诉讼的当事人及其法定代理人，自案件移送审查起诉之日起，有权委托诉讼代理人。自诉案件的自诉人及其法定代理人，附带民事诉讼的当事人及其法定代理人，有权随时委托诉讼代理人。 人民检察院自收到移送审查起诉的案件材料之日起三日以内，应当告知被害人及其法定代理人或者其近亲属、附带民事诉讼的当事人及其法定代理人有权委托诉讼代理人。人民法院自受理自诉案件之日起三日以内，应当告知自诉人及其法定代理人、附带民事诉讼的当事人及其法定代理人有权委托诉讼代理人。</p><p><strong>第四十七条</strong></p><p>委托诉讼代理人，参照本法第三十三条的规定执行。</p><p><strong>第四十八条</strong></p><p>辩护律师对在执业活动中知悉的委托人的有关情况和信息，有权予以保密。但是，辩护律师在执业活动中知悉委托人或者其他人，准备或者正在实施危害国家安全、公共安全以及严重危害他人人身安全的犯罪的，应当及时告知司法机关。</p><p><strong>第四十九条</strong></p><p>辩护人、诉讼代理人认为公安机关、人民检察院、人民法院及其工作人员阻碍其依法行使诉讼权利的，有权向同级或者上一级人民检察院申诉或者控告。人民检察院对申诉或者控告应当及时进行审查，情况属实的，通知有关机关予以纠正。</p><h4 id="第五章-证-据"><a href="#第五章-证-据" class="headerlink" title="第五章　证　　据"></a>第五章　证　　据</h4><p><strong>第五十条</strong></p><p>可以用于证明案件事实的材料，都是证据。 证据包括：</p><ul><li>（一）物证； </li><li>（二）书证； </li><li>（三）证人证言； </li><li>（四）被害人陈述；</li><li>（五）犯罪嫌疑人、被告人供述和辩解； </li><li>（六）鉴定意见； </li><li>（七）勘验、检查、辨认、侦查实验等笔录； </li><li>（八）视听资料、电子数据。 证据必须经过查证属实，才能作为定案的根据。</li></ul><p><strong>第五十一条</strong></p><p>公诉案件中被告人有罪的举证责任由人民检察院承担，自诉案件中被告人有罪的举证责任由自诉人承担。</p><p><strong>第五十二条</strong></p><p>审判人员、检察人员、侦查人员必须依照法定程序，收集能够证实犯罪嫌疑人、被告人有罪或者无罪、犯罪情节轻重的各种证据。严禁刑讯逼供和以威胁、引诱、欺骗以及其他非法方法收集证据，不得强迫任何人证实自己有罪。必须保证一切与案件有关或者了解案情的公民，有客观地充分地提供证据的条件，除特殊情况外，可以吸收他们协助调查。</p><p><strong>第五十三条</strong></p><p>公安机关提请批准逮捕书、人民检察院起诉书、人民法院判决书，必须忠实于事实真象。故意隐瞒事实真象的，应当追究责任。</p><p><strong>第五十四条</strong></p><p>人民法院、人民检察院和公安机关有权向有关单位和个人收集、调取证据。有关单位和个人应当如实提供证据。 行政机关在行政执法和查办案件过程中收集的物证、书证、视听资料、电子数据等证据材料，在刑事诉讼中可以作为证据使用。 对涉及国家秘密、商业秘密、个人隐私的证据，应当保密。 凡是伪造证据、隐匿证据或者毁灭证据的，无论属于何方，必须受法律追究。</p><p><strong>第五十五条</strong></p><p>对一切案件的判处都要重证据，重调查研究，不轻信口供。只有被告人供述，没有其他证据的，不能认定被告人有罪和处以刑罚；没有被告人供述，证据确实、充分的，可以认定被告人有罪和处以刑罚。 证据确实、充分，应当符合以下条件： </p><ul><li>（一）定罪量刑的事实都有证据证明； </li><li>（二）据以定案的证据均经法定程序查证属实； </li><li>（三）综合全案证据，对所认定事实已排除合理怀疑。</li></ul><p><strong>第五十六条</strong></p><p>采用刑讯逼供等非法方法收集的犯罪嫌疑人、被告人供述和采用暴力、威胁等非法方法收集的证人证言、被害人陈述，应当予以排除。收集物证、书证不符合法定程序，可能严重影响司法公正的，应当予以补正或者作出合理解释；不能补正或者作出合理解释的，对该证据应当予以排除。 在侦查、审查起诉、审判时发现有应当排除的证据的，应当依法予以排除，不得作为起诉意见、起诉决定和判决的依据。</p><p><strong>第五十七条</strong></p><p>人民检察院接到报案、控告、举报或者发现侦查人员以非法方法收集证据的，应当进行调查核实。对于确有以非法方法收集证据情形的，应当提出纠正意见；构成犯罪的，依法追究刑事责任。</p><p><strong>第五十八条</strong></p><p>法庭审理过程中，审判人员认为可能存在本法第五十六条规定的以非法方法收集证据情形的，应当对证据收集的合法性进行法庭调查。 当事人及其辩护人、诉讼代理人有权申请人民法院对以非法方法收集的证据依法予以排除。申请排除以非法方法收集的证据的，应当提供相关线索或者材料。</p><p><strong>第五十九条</strong></p><p>在对证据收集的合法性进行法庭调查的过程中，人民检察院应当对证据收集的合法性加以证明。 现有证据材料不能证明证据收集的合法性的，人民检察院可以提请人民法院通知有关侦查人员或者其他人员出庭说明情况；人民法院可以通知有关侦查人员或者其他人员出庭说明情况。有关侦查人员或者其他人员也可以要求出庭说明情况。经人民法院通知，有关人员应当出庭。</p><p><strong>第六十条</strong></p><p>对于经过法庭审理，确认或者不能排除存在本法第五十六条规定的以非法方法收集证据情形的，对有关证据应当予以排除。</p><p><strong>第六十一条</strong></p><p>证人证言必须在法庭上经过公诉人、被害人和被告人、辩护人双方质证并且查实以后，才能作为定案的根据。法庭查明证人有意作伪证或者隐匿罪证的时候，应当依法处理。</p><p><strong>第六十二条</strong></p><p>凡是知道案件情况的人，都有作证的义务。 生理上、精神上有缺陷或者年幼，不能辨别是非、不能正确表达的人，不能作证人。</p><p><strong>第六十三条</strong></p><p>人民法院、人民检察院和公安机关应当保障证人及其近亲属的安全。 对证人及其近亲属进行威胁、侮辱、殴打或者打击报复，构成犯罪的，依法追究刑事责任；尚不够刑事处罚的，依法给予治安管理处罚。</p><p><strong>第六十四条</strong></p><p>对于危害国家安全犯罪、恐怖活动犯罪、黑社会性质的组织犯罪、毒品犯罪等案件，证人、鉴定人、被害人因在诉讼中作证，本人或者其近亲属的人身安全面临危险的，人民法院、人民检察院和公安机关应当采取以下一项或者多项保护措施： </p><ul><li>（一）不公开真实姓名、住址和工作单位等个人信息； </li><li>（二）采取不暴露外貌、真实声音等出庭作证措施； </li><li>（三）禁止特定的人员接触证人、鉴定人、被害人及其近亲属； </li><li>（四）对人身和住宅采取专门性保护措施； </li><li>（五）其他必要的保护措施。 证人、鉴定人、被害人认为因在诉讼中作证，本人或者其近亲属的人身安全面临危险的，可以向人民法院、人民检察院、公安机关请求予以保护。 人民法院、人民检察院、公安机关依法采取保护措施，有关单位和个人应当配合。</li></ul><p><strong>第六十五条</strong></p><p>证人因履行作证义务而支出的交通、住宿、就餐等费用，应当给予补助。证人作证的补助列入司法机关业务经费，由同级政府财政予以保障。 有工作单位的证人作证，所在单位不得克扣或者变相克扣其工资、奖金及其他福利待遇。</p><h4 id="第六章-强制措施"><a href="#第六章-强制措施" class="headerlink" title="第六章　强制措施"></a>第六章　强制措施</h4><p><strong>第六十六条</strong></p><p>人民法院、人民检察院和公安机关根据案件情况，对犯罪嫌疑人、被告人可以拘传、取保候审或者监视居住。</p><p><strong>第六十七条</strong></p><p>人民法院、人民检察院和公安机关对有下列情形之一的犯罪嫌疑人、被告人，可以取保候审：</p><ul><li>（一）可能判处管制、拘役或者独立适用附加刑的； </li><li>（二）可能判处有期徒刑以上刑罚，采取取保候审不致发生社会危险性的； </li><li>（三）患有严重疾病、生活不能自理，怀孕或者正在哺乳自己婴儿的妇女，采取取保候审不致发生社会危险性的； </li><li>（四）羁押期限届满，案件尚未办结，需要采取取保候审的。 取保候审由公安机关执行。</li></ul><p><strong>第六十八条</strong></p><p>人民法院、人民检察院和公安机关决定对犯罪嫌疑人、被告人取保候审，应当责令犯罪嫌疑人、被告人提出保证人或者交纳保证金。</p><p><strong>第六十九条</strong></p><p>保证人必须符合下列条件：</p><ul><li>（一）与本案无牵连；</li><li>（二）有能力履行保证义务； </li><li>（三）享有政治权利，人身自由未受到限制； </li><li>（四）有固定的住处和收入。</li></ul><p><strong>第七十条</strong></p><p>保证人应当履行以下义务： </p><ul><li>（一）监督被保证人遵守本法第七十一条的规定； </li><li>（二）发现被保证人可能发生或者已经发生违反本法第七十一条规定的行为的，应当及时向执行机关报告。 被保证人有违反本法第七十一条规定的行为，保证人未履行保证义务的，对保证人处以罚款，构成犯罪的，依法追究刑事责任。</li></ul><p><strong>第七十一条</strong></p><p>被取保候审的犯罪嫌疑人、被告人应当遵守以下规定： </p><ul><li><p>（一）未经执行机关批准不得离开所居住的市、县；</p></li><li><p>（二）住址、工作单位和联系方式发生变动的，在二十四小时以内向执行机关报告；</p></li><li><p>（三）在传讯的时候及时到案；</p></li><li><p>（四）不得以任何形式干扰证人作证；</p></li><li><p>（五）不得毁灭、伪造证据或者串供。 </p><p>人民法院、人民检察院和公安机关可以根据案件情况，责令被取保候审的犯嫌疑人、被告人遵守以下一项或者多项规定： </p></li><li><p>（一）不得进入特定的场所； </p></li><li><p>（二）不得与特定的人员会见或者通信； </p></li><li><p>（三）不得从事特定的活动；</p></li><li><p>（四）将护照等出入境证件、驾驶证件交执行机关保存。 被取保候审的犯罪嫌疑人、被告人违反前两款规定，已交纳保证金的，没收部分或者全部保证金，并且区别情形，责令犯罪嫌疑人、被告人具结悔过，重新交纳保证金、提出保证人，或者监视居住、予以逮捕。 对违反取保候审规定，需要予以逮捕的，可以对犯罪嫌疑人、被告人先行拘留。</p></li></ul><p><strong>第七十二条</strong></p><p>取保候审的决定机关应当综合考虑保证诉讼活动正常进行的需要，被取保候审人的社会危险性，案件的性质、情节，可能判处刑罚的轻重，被取保候审人的经济状况等情况，确定保证金的数额。 提供保证金的人应当将保证金存入执行机关指定银行的专门账户。</p><p><strong>第七十三条</strong></p><p>犯罪嫌疑人、被告人在取保候审期间未违反本法第七十一条规定的，取保候审结束的时候，凭解除取保候审的通知或者有关法律文书到银行领取退还的保证金。</p><p><strong>第七十四条</strong></p><p>人民法院、人民检察院和公安机关对符合逮捕条件，有下列情形之一的犯罪嫌疑人、被告人，可以监视居住： </p><ul><li>（一）患有严重疾病、生活不能自理的； </li><li>（二）怀孕或者正在哺乳自己婴儿的妇女； </li><li>（三）系生活不能自理的人的唯一扶养人； </li><li>（四）因为案件的特殊情况或者办理案件的需要，采取监视居住措施更为适宜的； </li><li>（五）羁押期限届满，案件尚未办结，需要采取监视居住措施的。 对符合取保候审条件，但犯罪嫌疑人、被告人不能提出保证人，也不交纳保证金的，可以监视居住。 监视居住由公安机关执行。</li></ul><p><strong>第七十五条</strong></p><p>监视居住应当在犯罪嫌疑人、被告人的住处执行；无固定住处的，可以在指定的居所执行。对于涉嫌危害国家安全犯罪、恐怖活动犯罪，在住处执行可能有碍侦查的，经上一级公安机关批准，也可以在指定的居所执行。但是，不得在羁押场所、专门的办案场所执行。 指定居所监视居住的，除无法通知的以外，应当在执行监视居住后二十四小时以内，通知被监视居住人的家属。 被监视居住的犯罪嫌疑人、被告人委托辩护人，适用本法第三十四条的规定。 人民检察院对指定居所监视居住的决定和执行是否合法实行监督。</p><p><strong>第七十六条</strong></p><p>指定居所监视居住的期限应当折抵刑期。被判处管制的，监视居住一日折抵刑期一日；被判处拘役、有期徒刑的，监视居住二日折抵刑期一日。</p><p><strong>第七十七条</strong></p><p>被监视居住的犯罪嫌疑人、被告人应当遵守以下规定： </p><ul><li>（一）未经执行机关批准不得离开执行监视居住的处所； </li><li>（二）未经执行机关批准不得会见他人或者通信； </li><li>（三）在传讯的时候及时到案； </li><li>（四）不得以任何形式干扰证人作证； </li><li>（五）不得毁灭、伪造证据或者串供； </li><li>（六）将护照等出入境证件、身份证件、驾驶证件交执行机关保存。 被监视居住的犯罪嫌疑人、被告人违反前款规定，情节严重的，可以予以逮捕；需要予以逮捕的，可以对犯罪嫌疑人、被告人先行拘留。</li></ul><p><strong>第七十八条</strong></p><p>执行机关对被监视居住的犯罪嫌疑人、被告人，可以采取电子监控、不定期检查等监视方法对其遵守监视居住规定的情况进行监督；在侦查期间，可以对被监视居住的犯罪嫌疑人的通信进行监控。</p><p><strong>第七十九条</strong></p><p>人民法院、人民检察院和公安机关对犯罪嫌疑人、被告人取保候审最长不得超过十二个月，监视居住最长不得超过六个月。 在取保候审、监视居住期间，不得中断对案件的侦查、起诉和审理。对于发现不应当追究刑事责任或者取保候审、监视居住期限届满的，应当及时解除取保候审、监视居住。解除取保候审、监视居住，应当及时通知被取保候审、监视居住人和有关单位。</p><p><strong>第八十条</strong></p><p>逮捕犯罪嫌疑人、被告人，必须经过人民检察院批准或者人民法院决定，由公安机关执行。</p><p><strong>第八十一条</strong></p><p>对有证据证明有犯罪事实，可能判处徒刑以上刑罚的犯罪嫌疑人、被告人，采取取保候审尚不足以防止发生下列社会危险性的，应当予以逮捕： </p><ul><li>（一）可能实施新的犯罪的； </li><li>（二）有危害国家安全、公共安全或者社会秩序的现实危险的； </li><li>（三）可能毁灭、伪造证据，干扰证人作证或者串供的； </li><li>（四）可能对被害人、举报人、控告人实施打击报复的； </li><li>（五）企图自杀或者逃跑的。 批准或者决定逮捕，应当将犯罪嫌疑人、被告人涉嫌犯罪的性质、情节，认罪认罚等情况，作为是否可能发生社会危险性的考虑因素。 对有证据证明有犯罪事实，可能判处十年有期徒刑以上刑罚的，或者有证据证明有犯罪事实，可能判处徒刑以上刑罚，曾经故意犯罪或者身份不明的，应当予以逮捕。 被取保候审、监视居住的犯罪嫌疑人、被告人违反取保候审、监视居住规定，情节严重的，可以予以逮捕。</li></ul><p><strong>第八十二条</strong></p><p>公安机关对于现行犯或者重大嫌疑分子，如果有下列情形之一的，可以先行拘留： </p><ul><li>（一）正在预备犯罪、实行犯罪或者在犯罪后即时被发觉的； </li><li>（二）被害人或者在场亲眼看见的人指认他犯罪的； </li><li>（三）在身边或者住处发现有犯罪证据的； </li><li>（四）犯罪后企图自杀、逃跑或者在逃的； </li><li>（五）有毁灭、伪造证据或者串供可能的； </li><li>（六）不讲真实姓名、住址，身份不明的； </li><li>（七）有流窜作案、多次作案、结伙作案重大嫌疑的。</li></ul><p><strong>第八十三条</strong></p><p>公安机关在异地执行拘留、逮捕的时候，应当通知被拘留、逮捕人所在地的公安机关，被拘留、逮捕人所在地的公安机关应当予以配合。</p><p><strong>第八十四条</strong></p><p>对于有下列情形的人，任何公民都可以立即扭送公安机关、人民检察院或者人民法院处理： </p><ul><li>（一）正在实行犯罪或者在犯罪后即时被发觉的；</li><li>（二）通缉在案的； </li><li>（三）越狱逃跑的； </li><li>（四）正在被追捕的。</li></ul><p><strong>第八十五条</strong></p><p>公安机关拘留人的时候，必须出示拘留证。 拘留后，应当立即将被拘留人送看守所羁押，至迟不得超过二十四小时。除无法通知或者涉嫌危害国家安全犯罪、恐怖活动犯罪通知可能有碍侦查的情形以外，应当在拘留后二十四小时以内，通知被拘留人的家属。有碍侦查的情形消失以后，应当立即通知被拘留人的家属。</p><p><strong>第八十六条</strong></p><p>公安机关对被拘留的人，应当在拘留后的二十四小时以内进行讯问。在发现不应当拘留的时候，必须立即释放，发给释放证明。</p><p><strong>第八十七条</strong></p><p>公安机关要求逮捕犯罪嫌疑人的时候，应当写出提请批准逮捕书，连同案卷材料、证据，一并移送同级人民检察院审查批准。必要的时候，人民检察院可以派人参加公安机关对于重大案件的讨论。</p><p><strong>第八十八条</strong></p><p>人民检察院审查批准逮捕，可以讯问犯罪嫌疑人；有下列情形之一的，应当讯问犯罪嫌疑人：</p><ul><li>（一）对是否符合逮捕条件有疑问的； </li><li>（二）犯罪嫌疑人要求向检察人员当面陈述的；</li><li>（三）侦查活动可能有重大违法行为的。 人民检察院审查批准逮捕，可以询问证人等诉讼参与人，听取辩护律师的意见；辩护律师提出要求的，应当听取辩护律师的意见。</li></ul><p><strong>第八十九条</strong></p><p>人民检察院审查批准逮捕犯罪嫌疑人由检察长决定。重大案件应当提交检察委员会讨论决定。</p><p><strong>第九十条</strong></p><p>人民检察院对于公安机关提请批准逮捕的案件进行审查后，应当根据情况分别作出批准逮捕或者不批准逮捕的决定。对于批准逮捕的决定，公安机关应当立即执行，并且将执行情况及时通知人民检察院。对于不批准逮捕的，人民检察院应当说明理由，需要补充侦查的，应当同时通知公安机关。</p><p><strong>第九十一条</strong></p><p>公安机关对被拘留的人，认为需要逮捕的，应当在拘留后的三日以内，提请人民检察院审查批准。在特殊情况下，提请审查批准的时间可以延长一日至四日。 对于流窜作案、多次作案、结伙作案的重大嫌疑分子，提请审查批准的时间可以延长至三十日。 人民检察院应当自接到公安机关提请批准逮捕书后的七日以内，作出批准逮捕或者不批准逮捕的决定。人民检察院不批准逮捕的，公安机关应当在接到通知后立即释放，并且将执行情况及时通知人民检察院。对于需要继续侦查，并且符合取保候审、监视居住条件的，依法取保候审或者监视居住。</p><p><strong>第九十二条</strong></p><p>公安机关对人民检察院不批准逮捕的决定，认为有错误的时候，可以要求复议，但是必须将被拘留的人立即释放。如果意见不被接受，可以向上一级人民检察院提请复核。上级人民检察院应当立即复核，作出是否变更的决定，通知下级人民检察院和公安机关执行。</p><p><strong>第九十三条</strong></p><p>公安机关逮捕人的时候，必须出示逮捕证。 逮捕后，应当立即将被逮捕人送看守所羁押。除无法通知的以外，应当在逮捕后二十四小时以内，通知被逮捕人的家属。</p><p><strong>第九十四条</strong></p><p>人民法院、人民检察院对于各自决定逮捕的人，公安机关对于经人民检察院批准逮捕的人，都必须在逮捕后的二十四小时以内进行讯问。在发现不应当逮捕的时候，必须立即释放，发给释放证明。</p><p><strong>第九十五条</strong></p><p>犯罪嫌疑人、被告人被逮捕后，人民检察院仍应当对羁押的必要性进行审查。对不需要继续羁押的，应当建议予以释放或者变更强制措施。有关机关应当在十日以内将处理情况通知人民检察院。</p><p><strong>第九十六条</strong></p><p>人民法院、人民检察院和公安机关如果发现对犯罪嫌疑人、被告人采取强制措施不当的，应当及时撤销或者变更。公安机关释放被逮捕的人或者变更逮捕措施的，应当通知原批准的人民检察院。</p><p><strong>第九十七条</strong></p><p>犯罪嫌疑人、被告人及其法定代理人、近亲属或者辩护人有权申请变更强制措施。人民法院、人民检察院和公安机关收到申请后，应当在三日以内作出决定；不同意变更强制措施的，应当告知申请人，并说明不同意的理由。</p><p><strong>第九十八条</strong></p><p>犯罪嫌疑人、被告人被羁押的案件，不能在本法规定的侦查羁押、审查起诉、一审、二审期限内办结的，对犯罪嫌疑人、被告人应当予以释放；需要继续查证、审理的，对犯罪嫌疑人、被告人可以取保候审或者监视居住。</p><p><strong>第九十九条</strong></p><p>人民法院、人民检察院或者公安机关对被采取强制措施法定期限届满的犯罪嫌疑人、被告人，应当予以释放、解除取保候审、监视居住或者依法变更强制措施。犯罪嫌疑人、被告人及其法定代理人、近亲属或者辩护人对于人民法院、人民检察院或者公安机关采取强制措施法定期限届满的，有权要求解除强制措施。</p><p><strong>第一百条</strong></p><p>人民检察院在审查批准逮捕工作中，如果发现公安机关的侦查活动有违法情况，应当通知公安机关予以纠正，公安机关应当将纠正情况通知人民检察院。</p><h4 id="第七章-附带民事诉讼"><a href="#第七章-附带民事诉讼" class="headerlink" title="第七章　附带民事诉讼"></a>第七章　附带民事诉讼</h4><p><strong>第一百零一条</strong></p><p>被害人由于被告人的犯罪行为而遭受物质损失的，在刑事诉讼过程中，有权提起附带民事诉讼。被害人死亡或者丧失行为能力的，被害人的法定代理人、近亲属有权提起附带民事诉讼。 如果是国家财产、集体财产遭受损失的，人民检察院在提起公诉的时候，可以提起附带民事诉讼。</p><p><strong>第一百零二条</strong></p><p>人民法院在必要的时候，可以采取保全措施，查封、扣押或者冻结被告人的财产。附带民事诉讼原告人或者人民检察院可以申请人民法院采取保全措施。人民法院采取保全措施，适用民事诉讼法的有关规定。</p><p><strong>第一百零三条</strong></p><p>人民法院审理附带民事诉讼案件，可以进行调解，或者根据物质损失情况作出判决、裁定。</p><p><strong>第一百零四条</strong></p><p>附带民事诉讼应当同刑事案件一并审判，只有为了防止刑事案件审判的过分迟延，才可以在刑事案件审判后，由同一审判组织继续审理附带民事诉讼。</p><h4 id="第八章-期间、送达"><a href="#第八章-期间、送达" class="headerlink" title="第八章　期间、送达"></a>第八章　期间、送达</h4><p><strong>第一百零五条</strong></p><p>期间以时、日、月计算。 期间开始的时和日不算在期间以内。 法定期间不包括路途上的时间。上诉状或者其他文件在期满前已经交邮的，不算过期。 期间的最后一日为节假日的，以节假日后的第一日为期满日期，但犯罪嫌疑人、被告人或者罪犯在押期间，应当至期满之日为止，不得因节假日而延长。</p><p><strong>第一百零六条</strong></p><p>当事人由于不能抗拒的原因或者有其他正当理由而耽误期限的，在障碍消除后五日以内，可以申请继续进行应当在期满以前完成的诉讼活动。 前款申请是否准许，由人民法院裁定。</p><p><strong>第一百零七条</strong></p><p>送达传票、通知书和其他诉讼文件应当交给收件人本人；如果本人不在，可以交给他的成年家属或者所在单位的负责人员代收。 收件人本人或者代收人拒绝接收或者拒绝签名、盖章的时候，送达人可以邀请他的邻居或者其他见证人到场，说明情况，把文件留在他的住处，在送达证上记明拒绝的事由、送达的日期，由送达人签名，即认为已经送达。</p><h4 id="第九章-其他规定"><a href="#第九章-其他规定" class="headerlink" title="第九章　其他规定"></a>第九章　其他规定</h4><p><strong>第一百零八条</strong></p><p>本法下列用语的含意是：</p><ul><li>（一）“侦查”是指公安机关、人民检察院对于刑事案件，依照法律进行的收集证据、查明案情的工作和有关的强制性措施；</li><li>（二）“当事人”是指被害人、自诉人、犯罪嫌疑人、被告人、附带民事诉讼的原告人和被告人；</li><li>（三）“法定代理人”是指被代理人的父母、养父母、监护人和负有保护责任的机关、团体的代表； </li><li>（四）“诉讼参与人”是指当事人、法定代理人、诉讼代理人、辩护人、证人、鉴定人和翻译人员；</li><li>（五）“诉讼代理人”是指公诉案件的被害人及其法定代理人或者近亲属、自诉案件的自诉人及其法定代理人委托代为参加诉讼的人和附带民事诉讼的当事人及其法定代理人委托代为参加诉讼的人；</li><li>（六）“近亲属”是指夫、妻、父、母、子、女、同胞兄弟姊妹。</li></ul><h3 id="第二编-立案、侦查和提起公诉"><a href="#第二编-立案、侦查和提起公诉" class="headerlink" title="第二编　立案、侦查和提起公诉"></a>第二编　立案、侦查和提起公诉</h3><h4 id="第一章-立案"><a href="#第一章-立案" class="headerlink" title="第一章　立案"></a>第一章　立案</h4><p><strong>第一百零九条</strong></p><p>公安机关或者人民检察院发现犯罪事实或者犯罪嫌疑人，应当按照管辖范围，立案侦查。</p><p><strong>第一百一十条</strong></p><p>任何单位和个人发现有犯罪事实或者犯罪嫌疑人，有权利也有义务向公安机关、人民检察院或者人民法院报案或者举报。 被害人对侵犯其人身、财产权利的犯罪事实或者犯罪嫌疑人，有权向公安机关、人民检察院或者人民法院报案或者控告。 公安机关、人民检察院或者人民法院对于报案、控告、举报，都应当接受。对于不属于自己管辖的，应当移送主管机关处理，并且通知报案人、控告人、举报人；对于不属于自己管辖而又必须采取紧急措施的，应当先采取紧急措施，然后移送主管机关。 犯罪人向公安机关、人民检察院或者人民法院自首的，适用第三款规定。</p><p><strong>第一百一十一条</strong></p><p>报案、控告、举报可以用书面或者口头提出。接受口头报案、控告、举报的工作人员，应当写成笔录，经宣读无误后，由报案人、控告人、举报人签名或者盖章。 接受控告、举报的工作人员，应当向控告人、举报人说明诬告应负的法律责任。但是，只要不是捏造事实，伪造证据，即使控告、举报的事实有出入，甚至是错告的，也要和诬告严格加以区别。 公安机关、人民检察院或者人民法院应当保障报案人、控告人、举报人及其近亲属的安全。报案人、控告人、举报人如果不愿公开自己的姓名和报案、控告、举报的行为，应当为他保守秘密。</p><p><strong>第一百一十二条</strong></p><p>人民法院、人民检察院或者公安机关对于报案、控告、举报和自首的材料，应当按照管辖范围，迅速进行审查，认为有犯罪事实需要追究刑事责任的时候，应当立案；认为没有犯罪事实，或者犯罪事实显著轻微，不需要追究刑事责任的时候，不予立案，并且将不立案的原因通知控告人。控告人如果不服，可以申请复议。</p><p><strong>第一百一十三条</strong></p><p>人民检察院认为公安机关对应当立案侦查的案件而不立案侦查的，或者被害人认为公安机关对应当立案侦查的案件而不立案侦查，向人民检察院提出的，人民检察院应当要求公安机关说明不立案的理由。人民检察院认为公安机关不立案理由不能成立的，应当通知公安机关立案，公安机关接到通知后应当立案。</p><p><strong>第一百一十四条</strong></p><p>对于自诉案件，被害人有权向人民法院直接起诉。被害人死亡或者丧失行为能力的，被害人的法定代理人、近亲属有权向人民法院起诉。人民法院应当依法受理。</p><h4 id="第二章-侦查"><a href="#第二章-侦查" class="headerlink" title="第二章　侦查"></a>第二章　侦查</h4><p><strong>第一百一十五条</strong></p><p>公安机关对已经立案的刑事案件，应当进行侦查，收集、调取犯罪嫌疑人有罪或者无罪、罪轻或者罪重的证据材料。对现行犯或者重大嫌疑分子可以依法先行拘留，对符合逮捕条件的犯罪嫌疑人，应当依法逮捕。</p><p><strong>第一百一十六条</strong></p><p>公安机关经过侦查，对有证据证明有犯罪事实的案件，应当进行预审，对收集、调取的证据材料予以核实。</p><p><strong>第一百一十七条</strong></p><p>当事人和辩护人、诉讼代理人、利害关系人对于司法机关及其工作人员有下列行为之一的，有权向该机关申诉或者控告</p><ul><li><p>（一）采取强制措施法定期限届满，不予以释放、解除或者变更的； </p></li><li><p>（二）应当退还取保候审保证金不退还的； </p></li><li>（三）对与案件无关的财物采取查封、扣押、冻结措施的； </li><li>（四）应当解除查封、扣押、冻结不解除的； </li><li>（五）贪污、挪用、私分、调换、违反规定使用查封、扣押、冻结的财物的。 受理申诉或者控告的机关应当及时处理。对处理不服的，可以向同级人民检察院申诉；人民检察院直接受理的案件，可以向上一级人民检察院申诉。人民检察院对申诉应当及时进行审查，情况属实的，通知有关机关予以纠正。</li></ul><p><strong>第一百一十八条</strong></p><p>讯问犯罪嫌疑人必须由人民检察院或者公安机关的侦查人员负责进行。讯问的时候，侦查人员不得少于二人。 犯罪嫌疑人被送交看守所羁押以后，侦查人员对其进行讯问，应当在看守所内进行。</p><p><strong>第一百一十九条</strong></p><p>对不需要逮捕、拘留的犯罪嫌疑人，可以传唤到犯罪嫌疑人所在市、县内的指定地点或者到他的住处进行讯问，但是应当出示人民检察院或者公安机关的证明文件。对在现场发现的犯罪嫌疑人，经出示工作证件，可以口头传唤，但应当在讯问笔录中注明。 传唤、拘传持续的时间不得超过十二小时；案情特别重大、复杂，需要采取拘留、逮捕措施的，传唤、拘传持续的时间不得超过二十四小时。 不得以连续传唤、拘传的形式变相拘禁犯罪嫌疑人。传唤、拘传犯罪嫌疑人，应当保证犯罪嫌疑人的饮食和必要的休息时间。</p><p><strong>第一百二十条</strong></p><p>侦查人员在讯问犯罪嫌疑人的时候，应当首先讯问犯罪嫌疑人是否有犯罪行为，让他陈述有罪的情节或者无罪的辩解，然后向他提出问题。犯罪嫌疑人对侦查人员的提问，应当如实回答。但是对与本案无关的问题，有拒绝回答的权利。 侦查人员在讯问犯罪嫌疑人的时候，应当告知犯罪嫌疑人享有的诉讼权利，如实供述自己罪行可以从宽处理和认罪认罚的法律规定。</p><p><strong>第一百二十一条</strong></p><p>讯问聋、哑的犯罪嫌疑人，应当有通晓聋、哑手势的人参加，并且将这种情况记明笔录。</p><p><strong>第一百二十二条</strong></p><p>讯问笔录应当交犯罪嫌疑人核对，对于没有阅读能力的，应当向他宣读。如果记载有遗漏或者差错，犯罪嫌疑人可以提出补充或者改正。犯罪嫌疑人承认笔录没有错误后，应当签名或者盖章。侦查人员也应当在笔录上签名。犯罪嫌疑人请求自行书写供述的，应当准许。必要的时候，侦查人员也可以要犯罪嫌疑人亲笔书写供词。</p><p><strong>第一百二十三条</strong></p><p>侦查人员在讯问犯罪嫌疑人的时候，可以对讯问过程进行录音或者录像；对于可能判处无期徒刑、死刑的案件或者其他重大犯罪案件，应当对讯问过程进行录音或者录像。 录音或者录像应当全程进行，保持完整性。</p><p><strong>第一百二十四条</strong></p><p>侦查人员询问证人，可以在现场进行，也可以到证人所在单位、住处或者证人提出的地点进行，在必要的时候，可以通知证人到人民检察院或者公安机关提供证言。在现场询问证人，应当出示工作证件，到证人所在单位、住处或者证人提出的地点询问证人，应当出示人民检察院或者公安机关的证明文件。 询问证人应当个别进行。</p><p><strong>第一百二十五条</strong></p><p>询问证人，应当告知他应当如实地提供证据、证言和有意作伪证或者隐匿罪证要负的法律责任。</p><p><strong>第一百二十六条</strong></p><p>本法第一百二十二条的规定，也适用于询问证人。</p><p><strong>第一百二十七条</strong></p><p>询问被害人，适用本节各条规定。</p><p><strong>第一百二十八条</strong></p><p>侦查人员对于与犯罪有关的场所、物品、人身、尸体应当进行勘验或者检查。在必要的时候，可以指派或者聘请具有专门知识的人，在侦查人员的主持下进行勘验、检查。</p><p><strong>第一百二十九条</strong></p><p>任何单位和个人，都有义务保护犯罪现场，并且立即通知公安机关派员勘验。</p><p><strong>第一百三十条</strong></p><p>侦查人员执行勘验、检查，必须持有人民检察院或者公安机关的证明文件。</p><p><strong>第一百三十一条</strong></p><p>对于死因不明的尸体，公安机关有权决定解剖，并且通知死者家属到场。</p><p><strong>第一百三十二条</strong></p><p>为了确定被害人、犯罪嫌疑人的某些特征、伤害情况或者生理状态，可以对人身进行检查，可以提取指纹信息，采集血液、尿液等生物样本。 犯罪嫌疑人如果拒绝检查，侦查人员认为必要的时候，可以强制检查。 检查妇女的身体，应当由女工作人员或者医师进行。</p><p><strong>第一百三十三条</strong></p><p>勘验、检查的情况应当写成笔录，由参加勘验、检查的人和见证人签名或者盖章。</p><p><strong>第一百三十四条</strong></p><p>人民检察院审查案件的时候，对公安机关的勘验、检查，认为需要复验、复查时，可以要求公安机关复验、复查，并且可以派检察人员参加。</p><p><strong>第一百三十五条</strong></p><p>为了查明案情，在必要的时候，经公安机关负责人批准，可以进行侦查实验。 侦查实验的情况应当写成笔录，由参加实验的人签名或者盖章。 侦查实验，禁止一切足以造成危险、侮辱人格或者有伤风化的行为。</p><p><strong>第一百三十六条</strong></p><p>为了收集犯罪证据、查获犯罪人，侦查人员可以对犯罪嫌疑人以及可能隐藏罪犯或者犯罪证据的人的身体、物品、住处和其他有关的地方进行搜查。</p><p><strong>第一百三十七条</strong></p><p>任何单位和个人，有义务按照人民检察院和公安机关的要求，交出可以证明犯罪嫌疑人有罪或者无罪的物证、书证、视听资料等证据。</p><p><strong>第一百三十八条</strong></p><p>进行搜查，必须向被搜查人出示搜查证。 在执行逮捕、拘留的时候，遇有紧急情况，不另用搜查证也可以进行搜查。</p><p><strong>第一百三十九条</strong></p><p>在搜查的时候，应当有被搜查人或者他的家属，邻居或者其他见证人在场。 搜查妇女的身体，应当由女工作人员进行。</p><p><strong>第一百四十条</strong></p><p>搜查的情况应当写成笔录，由侦查人员和被搜查人或者他的家属，邻居或者其他见证人签名或者盖章。如果被搜查人或者他的家属在逃或者拒绝签名、盖章，应当在笔录上注明。</p><p><strong>第一百四十一条</strong></p><p>在侦查活动中发现的可用以证明犯罪嫌疑人有罪或者无罪的各种财物、文件，应当查封、扣押；与案件无关的财物、文件，不得查封、扣押。 对查封、扣押的财物、文件，要妥善保管或者封存，不得使用、调换或者损毁。</p><p><strong>第一百四十二条</strong></p><p>对查封、扣押的财物、文件，应当会同在场见证人和被查封、扣押财物、文件持有人查点清楚，当场开列清单一式二份，由侦查人员、见证人和持有人签名或者盖章，一份交给持有人，另一份附卷备查。</p><p><strong>第一百四十三条</strong></p><p>侦查人员认为需要扣押犯罪嫌疑人的邮件、电报的时候，经公安机关或者人民检察院批准，即可通知邮电机关将有关的邮件、电报检交扣押。 不需要继续扣押的时候，应即通知邮电机关。</p><p><strong>第一百四十四条</strong></p><p>人民检察院、公安机关根据侦查犯罪的需要，可以依照规定查询、冻结犯罪嫌疑人的存款、汇款、债券、股票、基金份额等财产。有关单位和个人应当配合。 犯罪嫌疑人的存款、汇款、债券、股票、基金份额等财产已被冻结的，不得重复冻结。</p><p><strong>第一百四十五条</strong></p><p>对查封、扣押的财物、文件、邮件、电报或者冻结的存款、汇款、债券、股票、基金份额等财产，经查明确实与案件无关的，应当在三日以内解除查封、扣押、冻结，予以退还。</p><p><strong>第一百四十六条</strong></p><p>为了查明案情，需要解决案件中某些专门性问题的时候，应当指派、聘请有专门知识的人进行鉴定。</p><p><strong>第一百四十七条</strong></p><p>鉴定人进行鉴定后，应当写出鉴定意见，并且签名。 鉴定人故意作虚假鉴定的，应当承担法律责任。</p><p><strong>第一百四十八条</strong></p><p>侦查机关应当将用作证据的鉴定意见告知犯罪嫌疑人、被害人。如果犯罪嫌疑人、被害人提出申请，可以补充鉴定或者重新鉴定。</p><p><strong>第一百四十九条</strong></p><p>对犯罪嫌疑人作精神病鉴定的期间不计入办案期限。</p><p><strong>第一百五十条</strong></p><p>公安机关在立案后，对于危害国家安全犯罪、恐怖活动犯罪、黑社会性质的组织犯罪、重大毒品犯罪或者其他严重危害社会的犯罪案件，根据侦查犯罪的需要，经过严格的批准手续，可以采取技术侦查措施。 人民检察院在立案后，对于利用职权实施的严重侵犯公民人身权利的重大犯罪案件，根据侦查犯罪的需要，经过严格的批准手续，可以采取技术侦查措施，按照规定交有关机关执行。 追捕被通缉或者批准、决定逮捕的在逃的犯罪嫌疑人、被告人，经过批准，可以采取追捕所必需的技术侦查措施。</p><p><strong>第一百五十一条</strong></p><p>批准决定应当根据侦查犯罪的需要，确定采取技术侦查措施的种类和适用对象。批准决定自签发之日起三个月以内有效。对于不需要继续采取技术侦查措施的，应当及时解除；对于复杂、疑难案件，期限届满仍有必要继续采取技术侦查措施的，经过批准，有效期可以延长，每次不得超过三个月。</p><p><strong>第一百五十二条</strong></p><p>采取技术侦查措施，必须严格按照批准的措施种类、适用对象和期限执行。 侦查人员对采取技术侦查措施过程中知悉的国家秘密、商业秘密和个人隐私，应当保密；对采取技术侦查措施获取的与案件无关的材料，必须及时销毁。 采取技术侦查措施获取的材料，只能用于对犯罪的侦查、起诉和审判，不得用于其他用途。 公安机关依法采取技术侦查措施，有关单位和个人应当配合，并对有关情况予以保密。</p><p><strong>第一百五十三条</strong></p><p>为了查明案情，在必要的时候，经公安机关负责人决定，可以由有关人员隐匿其身份实施侦查。但是，不得诱使他人犯罪，不得采用可能危害公共安全或者发生重大人身危险的方法。 对涉及给付毒品等违禁品或者财物的犯罪活动，公安机关根据侦查犯罪的需要，可以依照规定实施控制下交付。</p><p><strong>第一百五十四条</strong></p><p>依照本节规定采取侦查措施收集的材料在刑事诉讼中可以作为证据使用。如果使用该证据可能危及有关人员的人身安全，或者可能产生其他严重后果的，应当采取不暴露有关人员身份、技术方法等保护措施，必要的时候，可以由审判人员在庭外对证据进行核实。</p><p><strong>第一百五十五条</strong></p><p>应当逮捕的犯罪嫌疑人如果在逃，公安机关可以发布通缉令，采取有效措施，追捕归案。 各级公安机关在自己管辖的地区以内，可以直接发布通缉令；超出自己管辖的地区，应当报请有权决定的上级机关发布。</p><p><strong>第一百五十六条</strong></p><p>对犯罪嫌疑人逮捕后的侦查羁押期限不得超过二个月。案情复杂、期限届满不能终结的案件，可以经上一级人民检察院批准延长一个月。</p><p><strong>第一百五十七条</strong></p><p>因为特殊原因，在较长时间内不宜交付审判的特别重大复杂的案件，由最高人民检察院报请全国人民代表大会常务委员会批准延期审理。</p><p><strong>第一百五十八条</strong></p><p>下列案件在本法第一百五十六条规定的期限届满不能侦查终结的，经省、自治区、直辖市人民检察院批准或者决定，可以延长二个月： </p><ul><li>（一）交通十分不便的边远地区的重大复杂案件； </li><li>（二）重大的犯罪集团案件； </li><li>（三）流窜作案的重大复杂案件； </li><li>（四）犯罪涉及面广，取证困难的重大复杂案件。</li></ul><p><strong>第一百五十九条</strong></p><p>对犯罪嫌疑人可能判处十年有期徒刑以上刑罚，依照本法第一百五十八条规定延长期限届满，仍不能侦查终结的，经省、自治区、直辖市人民检察院批准或者决定，可以再延长二个月。</p><p><strong>第一百六十条</strong></p><p>在侦查期间，发现犯罪嫌疑人另有重要罪行的，自发现之日起依照本法第一百五十六条的规定重新计算侦查羁押期限。 犯罪嫌疑人不讲真实姓名、住址，身份不明的，应当对其身份进行调查，侦查羁押期限自查清其身份之日起计算，但是不得停止对其犯罪行为的侦查取证。对于犯罪事实清楚，证据确实、充分，确实无法查明其身份的，也可以按其自报的姓名起诉、审判。</p><p><strong>第一百六十一条</strong></p><p>在案件侦查终结前，辩护律师提出要求的，侦查机关应当听取辩护律师的意见，并记录在案。辩护律师提出书面意见的，应当附卷。</p><p><strong>第一百六十二条</strong></p><p>公安机关侦查终结的案件，应当做到犯罪事实清楚，证据确实、充分，并且写出起诉意见书，连同案卷材料、证据一并移送同级人民检察院审查决定；同时将案件移送情况告知犯罪嫌疑人及其辩护律师。 犯罪嫌疑人自愿认罪的，应当记录在案，随案移送，并在起诉意见书中写明有关情况。</p><p><strong>第一百六十三条</strong></p><p>在侦查过程中，发现不应对犯罪嫌疑人追究刑事责任的，应当撤销案件；犯罪嫌疑人已被逮捕的，应当立即释放，发给释放证明，并且通知原批准逮捕的人民检察院。</p><p><strong>第一百六十四条</strong></p><p>人民检察院对直接受理的案件的侦查适用本章规定。</p><p><strong>第一百六十五条</strong></p><p>人民检察院直接受理的案件中符合本法第八十一条、第八十二条第四项、第五项规定情形，需要逮捕、拘留犯罪嫌疑人的，由人民检察院作出决定，由公安机关执行。</p><p><strong>第一百六十六条</strong></p><p>人民检察院对直接受理的案件中被拘留的人，应当在拘留后的二十四小时以内进行讯问。在发现不应当拘留的时候，必须立即释放，发给释放证明。</p><p><strong>第一百六十七条</strong></p><p>人民检察院对直接受理的案件中被拘留的人，认为需要逮捕的，应当在十四日以内作出决定。在特殊情况下，决定逮捕的时间可以延长一日至三日。对不需要逮捕的，应当立即释放；对需要继续侦查，并且符合取保候审、监视居住条件的，依法取保候审或者监视居住。</p><p><strong>第一百六十八条</strong></p><p>人民检察院侦查终结的案件，应当作出提起公诉、不起诉或者撤销案件的决定。</p><h4 id="第三章-提起公诉"><a href="#第三章-提起公诉" class="headerlink" title="第三章　提起公诉"></a>第三章　提起公诉</h4><p><strong>第一百六十九条</strong></p><p>凡需要提起公诉的案件，一律由人民检察院审查决定。</p><p><strong>第一百七十条</strong></p><p>人民检察院对于监察机关移送起诉的案件，依照本法和监察法的有关规定进行审查。人民检察院经审查，认为需要补充核实的，应当退回监察机关补充调查，必要时可以自行补充侦查。 对于监察机关移送起诉的已采取留置措施的案件，人民检察院应当对犯罪嫌疑人先行拘留，留置措施自动解除。人民检察院应当在拘留后的十日以内作出是否逮捕、取保候审或者监视居住的决定。在特殊情况下，决定的时间可以延长一日至四日。人民检察院决定采取强制措施的期间不计入审查起诉期限。</p><p><strong>第一百七十一条</strong></p><p>人民检察院审查案件的时候，必须查明： </p><ul><li>（一）犯罪事实、情节是否清楚，证据是否确实、充分，犯罪性质和罪名的认定是否正确；</li><li>（二）有无遗漏罪行和其他应当追究刑事责任的人；</li><li>（三）是否属于不应追究刑事责任的； </li><li>（四）有无附带民事诉讼； </li><li>（五）侦查活动是否合法。</li></ul><p><strong>第一百七十二条</strong></p><p>人民检察院对于监察机关、公安机关移送起诉的案件，应当在一个月以内作出决定，重大、复杂的案件，可以延长十五日；犯罪嫌疑人认罪认罚，符合速裁程序适用条件的，应当在十日以内作出决定，对可能判处的有期徒刑超过一年的，可以延长至十五日。 人民检察院审查起诉的案件，改变管辖的，从改变后的人民检察院收到案件之日起计算审查起诉期限。</p><p><strong>第一百七十三条</strong></p><p>人民检察院审查案件，应当讯问犯罪嫌疑人，听取辩护人或者值班律师、被害人及其诉讼代理人的意见，并记录在案。辩护人或者值班律师、被害人及其诉讼代理人提出书面意见的，应当附卷。 犯罪嫌疑人认罪认罚的，人民检察院应当告知其享有的诉讼权利和认罪认罚的法律规定，听取犯罪嫌疑人、辩护人或者值班律师、被害人及其诉讼代理人对下列事项的意见，并记录在案： </p><ul><li>（一）涉嫌的犯罪事实、罪名及适用的法律规定； </li><li>（二）从轻、减轻或者免除处罚等从宽处罚的建议； </li><li>（三）认罪认罚后案件审理适用的程序；</li><li>（四）其他需要听取意见的事项。 人民检察院依照前两款规定听取值班律师意见的，应当提前为值班律师了解案件有关情况提供必要的便利。</li></ul><p><strong>第一百七十四条</strong></p><p>犯罪嫌疑人自愿认罪，同意量刑建议和程序适用的，应当在辩护人或者值班律师在场的情况下签署认罪认罚具结书。 犯罪嫌疑人认罪认罚，有下列情形之一的，不需要签署认罪认罚具结书： </p><ul><li>（一）犯罪嫌疑人是盲、聋、哑人，或者是尚未完全丧失辨认或者控制自己行为能力的精神病人的；</li><li>（二）未成年犯罪嫌疑人的法定代理人、辩护人对未成年人认罪认罚有异议的； </li><li>（三）其他不需要签署认罪认罚具结书的情形。</li></ul><p><strong>第一百七十五条</strong></p><p>人民检察院审查案件，可以要求公安机关提供法庭审判所必需的证据材料；认为可能存在本法第五十六条规定的以非法方法收集证据情形的，可以要求其对证据收集的合法性作出说明。 人民检察院审查案件，对于需要补充侦查的，可以退回公安机关补充侦查，也可以自行侦查。 对于补充侦查的案件，应当在一个月以内补充侦查完毕。补充侦查以二次为限。补充侦查完毕移送人民检察院后，人民检察院重新计算审查起诉期限。 对于二次补充侦查的案件，人民检察院仍然认为证据不足，不符合起诉条件的，应当作出不起诉的决定。</p><p><strong>第一百七十六条</strong></p><p>人民检察院认为犯罪嫌疑人的犯罪事实已经查清，证据确实、充分，依法应当追究刑事责任的，应当作出起诉决定，按照审判管辖的规定，向人民法院提起公诉，并将案卷材料、证据移送人民法院。 犯罪嫌疑人认罪认罚的，人民检察院应当就主刑、附加刑、是否适用缓刑等提出量刑建议，并随案移送认罪认罚具结书等材料。</p><p><strong>第一百七十七条</strong></p><p>犯罪嫌疑人没有犯罪事实，或者有本法第十六条规定的情形之一的，人民检察院应当作出不起诉决定。 对于犯罪情节轻微，依照刑法规定不需要判处刑罚或者免除刑罚的，人民检察院可以作出不起诉决定。 人民检察院决定不起诉的案件，应当同时对侦查中查封、扣押、冻结的财物解除查封、扣押、冻结。对被不起诉人需要给予行政处罚、处分或者需要没收其违法所得的，人民检察院应当提出检察意见，移送有关主管机关处理。有关主管机关应当将处理结果及时通知人民检察院。</p><p><strong>第一百七十八条</strong></p><p>不起诉的决定，应当公开宣布，并且将不起诉决定书送达被不起诉人和他的所在单位。如果被不起诉人在押，应当立即释放。</p><p><strong>第一百七十九条</strong></p><p>对于公安机关移送起诉的案件，人民检察院决定不起诉的，应当将不起诉决定书送达公安机关。公安机关认为不起诉的决定有错误的时候，可以要求复议，如果意见不被接受，可以向上一级人民检察院提请复核。</p><p><strong>第一百八十条</strong></p><p>对于有被害人的案件，决定不起诉的，人民检察院应当将不起诉决定书送达被害人。被害人如果不服，可以自收到决定书后七日以内向上一级人民检察院申诉，请求提起公诉。人民检察院应当将复查决定告知被害人。对人民检察院维持不起诉决定的，被害人可以向人民法院起诉。被害人也可以不经申诉，直接向人民法院起诉。人民法院受理案件后，人民检察院应当将有关案件材料移送人民法院。</p><p><strong>第一百八十一条</strong></p><p>对于人民检察院依照本法第一百七十七条第二款规定作出的不起诉决定，被不起诉人如果不服，可以自收到决定书后七日以内向人民检察院申诉。人民检察院应当作出复查决定，通知被不起诉的人，同时抄送公安机关。</p><p><strong>第一百八十二条</strong></p><p>犯罪嫌疑人自愿如实供述涉嫌犯罪的事实，有重大立功或者案件涉及国家重大利益的，经最高人民检察院核准，公安机关可以撤销案件，人民检察院可以作出不起诉决定，也可以对涉嫌数罪中的一项或者多项不起诉。 根据前款规定不起诉或者撤销案件的，人民检察院、公安机关应当及时对查封、扣押、冻结的财物及其孳息作出处理。</p><h3 id="第三编-审-判"><a href="#第三编-审-判" class="headerlink" title="第三编　审　　判"></a>第三编　审　　判</h3><h4 id="第一章-审判组织"><a href="#第一章-审判组织" class="headerlink" title="第一章　审判组织"></a>第一章　审判组织</h4><p><strong>第一百八十三条</strong></p><p>基层人民法院、中级人民法院审判第一审案件，应当由审判员三人或者由审判员和人民陪审员共三人或者七人组成合议庭进行，但是基层人民法院适用简易程序、速裁程序的案件可以由审判员一人独任审判。 高级人民法院审判第一审案件，应当由审判员三人至七人或者由审判员和人民陪审员共三人或者七人组成合议庭进行。 最高人民法院审判第一审案件，应当由审判员三人至七人组成合议庭进行。 人民法院审判上诉和抗诉案件，由审判员三人或者五人组成合议庭进行。 合议庭的成员人数应当是单数。</p><p><strong>第一百八十四条</strong></p><p>合议庭进行评议的时候，如果意见分歧，应当按多数人的意见作出决定，但是少数人的意见应当写入笔录。评议笔录由合议庭的组成人员签名。</p><p><strong>第一百八十五条</strong></p><p>合议庭开庭审理并且评议后，应当作出判决。对于疑难、复杂、重大的案件，合议庭认为难以作出决定的，由合议庭提请院长决定提交审判委员会讨论决定。审判委员会的决定，合议庭应当执行。</p><h4 id="第二章-第一审程序"><a href="#第二章-第一审程序" class="headerlink" title="第二章　第一审程序"></a>第二章　第一审程序</h4><p><strong>第一百八十六条</strong></p><p>人民法院对提起公诉的案件进行审查后，对于起诉书中有明确的指控犯罪事实的，应当决定开庭审判。</p><p><strong>第一百八十七条</strong></p><p>人民法院决定开庭审判后，应当确定合议庭的组成人员，将人民检察院的起诉书副本至迟在开庭十日以前送达被告人及其辩护人。 在开庭以前，审判人员可以召集公诉人、当事人和辩护人、诉讼代理人，对回避、出庭证人名单、非法证据排除等与审判相关的问题，了解情况，听取意见。 人民法院确定开庭日期后，应当将开庭的时间、地点通知人民检察院，传唤当事人，通知辩护人、诉讼代理人、证人、鉴定人和翻译人员，传票和通知书至迟在开庭三日以前送达。公开审判的案件，应当在开庭三日以前先期公布案由、被告人姓名、开庭时间和地点。 上述活动情形应当写入笔录，由审判人员和书记员签名。</p><p><strong>第一百八十八条</strong></p><p>人民法院审判第一审案件应当公开进行。但是有关国家秘密或者个人隐私的案件，不公开审理；涉及商业秘密的案件，当事人申请不公开审理的，可以不公开审理。 不公开审理的案件，应当当庭宣布不公开审理的理由。</p><p><strong>第一百八十九条</strong></p><p>人民法院审判公诉案件，人民检察院应当派员出席法庭支持公诉。</p><p><strong>第一百九十条</strong></p><p>开庭的时候，审判长查明当事人是否到庭，宣布案由；宣布合议庭的组成人员、书记员、公诉人、辩护人、诉讼代理人、鉴定人和翻译人员的名单；告知当事人有权对合议庭组成人员、书记员、公诉人、鉴定人和翻译人员申请回避；告知被告人享有辩护权利。 被告人认罪认罚的，审判长应当告知被告人享有的诉讼权利和认罪认罚的法律规定，审查认罪认罚的自愿性和认罪认罚具结书内容的真实性、合法性。</p><p><strong>第一百九十一条</strong></p><p>公诉人在法庭上宣读起诉书后，被告人、被害人可以就起诉书指控的犯罪进行陈述，公诉人可以讯问被告人。 被害人、附带民事诉讼的原告人和辩护人、诉讼代理人，经审判长许可，可以向被告人发问。 审判人员可以讯问被告人。</p><p><strong>第一百九十二条</strong></p><p>公诉人、当事人或者辩护人、诉讼代理人对证人证言有异议，且该证人证言对案件定罪量刑有重大影响，人民法院认为证人有必要出庭作证的，证人应当出庭作证。 人民警察就其执行职务时目击的犯罪情况作为证人出庭作证，适用前款规定。 公诉人、当事人或者辩护人、诉讼代理人对鉴定意见有异议，人民法院认为鉴定人有必要出庭的，鉴定人应当出庭作证。经人民法院通知，鉴定人拒不出庭作证的，鉴定意见不得作为定案的根据。</p><p><strong>第一百九十三条</strong></p><p>经人民法院通知，证人没有正当理由不出庭作证的，人民法院可以强制其到庭，但是被告人的配偶、父母、子女除外。 证人没有正当理由拒绝出庭或者出庭后拒绝作证的，予以训诫，情节严重的，经院长批准，处以十日以下的拘留。被处罚人对拘留决定不服的，可以向上一级人民法院申请复议。复议期间不停止执行。</p><p><strong>第一百九十四条</strong></p><p>证人作证，审判人员应当告知他要如实地提供证言和有意作伪证或者隐匿罪证要负的法律责任。公诉人、当事人和辩护人、诉讼代理人经审判长许可，可以对证人、鉴定人发问。审判长认为发问的内容与案件无关的时候，应当制止。 审判人员可以询问证人、鉴定人。</p><p><strong>第一百九十五条</strong></p><p>公诉人、辩护人应当向法庭出示物证，让当事人辨认，对未到庭的证人的证言笔录、鉴定人的鉴定意见、勘验笔录和其他作为证据的文书，应当当庭宣读。审判人员应当听取公诉人、当事人和辩护人、诉讼代理人的意见。</p><p><strong>第一百九十六条</strong></p><p>法庭审理过程中，合议庭对证据有疑问的，可以宣布休庭，对证据进行调查核实。 人民法院调查核实证据，可以进行勘验、检查、查封、扣押、鉴定和查询、冻结。</p><p><strong>第一百九十七条</strong></p><p>法庭审理过程中，当事人和辩护人、诉讼代理人有权申请通知新的证人到庭，调取新的物证，申请重新鉴定或者勘验。 公诉人、当事人和辩护人、诉讼代理人可以申请法庭通知有专门知识的人出庭，就鉴定人作出的鉴定意见提出意见。 法庭对于上述申请，应当作出是否同意的决定。 第二款规定的有专门知识的人出庭，适用鉴定人的有关规定。</p><p><strong>第一百九十八条</strong></p><p>法庭审理过程中，对与定罪、量刑有关的事实、证据都应当进行调查、辩论。 经审判长许可，公诉人、当事人和辩护人、诉讼代理人可以对证据和案件情况发表意见并且可以互相辩论。 审判长在宣布辩论终结后，被告人有最后陈述的权利。</p><p><strong>第一百九十九条</strong></p><p>在法庭审判过程中，如果诉讼参与人或者旁听人员违反法庭秩序，审判长应当警告制止。对不听制止的，可以强行带出法庭；情节严重的，处以一千元以下的罚款或者十五日以下的拘留。罚款、拘留必须经院长批准。被处罚人对罚款、拘留的决定不服的，可以向上一级人民法院申请复议。复议期间不停止执行。 对聚众哄闹、冲击法庭或者侮辱、诽谤、威胁、殴打司法工作人员或者诉讼参与人，严重扰乱法庭秩序，构成犯罪的，依法追究刑事责任。</p><p><strong>第二百条</strong></p><p>在被告人最后陈述后，审判长宣布休庭，合议庭进行评议，根据已经查明的事实、证据和有关的法律规定，分别作出以下判决： </p><ul><li>（一）案件事实清楚，证据确实、充分，依据法律认定被告人有罪的，应当作出有罪判决；</li><li>（二）依据法律认定被告人无罪的，应当作出无罪判决；</li><li>（三）证据不足，不能认定被告人有罪的，应当作出证据不足、指控的犯罪不能成立的无罪判决。</li></ul><p><strong>第二百零一条</strong></p><p>对于认罪认罚案件，人民法院依法作出判决时，一般应当采纳人民检察院指控的罪名和量刑建议，但有下列情形的除外： </p><ul><li>（一）被告人的行为不构成犯罪或者不应当追究其刑事责任的； </li><li>（二）被告人违背意愿认罪认罚的；</li><li>（三）被告人否认指控的犯罪事实的；</li><li>（四）起诉指控的罪名与审理认定的罪名不一致的；</li><li>（五）其他可能影响公正审判的情形。 人民法院经审理认为量刑建议明显不当，或者被告人、辩护人对量刑建议提出异议的，人民检察院可以调整量刑建议。人民检察院不调整量刑建议或者调整量刑建议后仍然明显不当的，人民法院应当依法作出判决。</li></ul><p><strong>第二百零二条</strong></p><p>宣告判决，一律公开进行。 当庭宣告判决的，应当在五日以内将判决书送达当事人和提起公诉的人民检察院；定期宣告判决的，应当在宣告后立即将判决书送达当事人和提起公诉的人民检察院。判决书应当同时送达辩护人、诉讼代理人。</p><p><strong>第二百零三条</strong></p><p>判决书应当由审判人员和书记员署名，并且写明上诉的期限和上诉的法院。</p><p><strong>第二百零四条</strong></p><p>在法庭审判过程中，遇有下列情形之一，影响审判进行的，可以延期审理： </p><ul><li>（一）需要通知新的证人到庭，调取新的物证，重新鉴定或者勘验的； </li><li>（二）检察人员发现提起公诉的案件需要补充侦查，提出建议的； </li><li>（三）由于申请回避而不能进行审判的。</li></ul><p><strong>第二百零五条</strong></p><p>依照本法第二百零四条第二项的规定延期审理的案件，人民检察院应当在一个月以内补充侦查完毕。</p><p><strong>第二百零六条</strong></p><p>在审判过程中，有下列情形之一，致使案件在较长时间内无法继续审理的，可以中止审理：</p><ul><li>（一）被告人患有严重疾病，无法出庭的； </li><li>（二）被告人脱逃的； </li><li>（三）自诉人患有严重疾病，无法出庭，未委托诉讼代理人出庭的；</li><li>（四）由于不能抗拒的原因。 中止审理的原因消失后，应当恢复审理。中止审理的期间不计入审理期限。</li></ul><p><strong>第二百零七条</strong></p><p>法庭审判的全部活动，应当由书记员写成笔录，经审判长审阅后，由审判长和书记员签名。 法庭笔录中的证人证言部分，应当当庭宣读或者交给证人阅读。证人在承认没有错误后，应当签名或者盖章。 法庭笔录应当交给当事人阅读或者向他宣读。当事人认为记载有遗漏或者差错的，可以请求补充或者改正。当事人承认没有错误后，应当签名或者盖章。</p><p><strong>第二百零八条</strong></p><p>人民法院审理公诉案件，应当在受理后二个月以内宣判，至迟不得超过三个月。对于可能判处死刑的案件或者附带民事诉讼的案件，以及有本法第一百五十八条规定情形之一的，经上一级人民法院批准，可以延长三个月；因特殊情况还需要延长的，报请最高人民法院批准。 人民法院改变管辖的案件，从改变后的人民法院收到案件之日起计算审理期限。 人民检察院补充侦查的案件，补充侦查完毕移送人民法院后，人民法院重新计算审理期限。</p><p><strong>第二百零九条</strong></p><p>人民检察院发现人民法院审理案件违反法律规定的诉讼程序，有权向人民法院提出纠正意见。</p><p><strong>第二百一十条</strong></p><p>自诉案件包括下列案件： </p><ul><li>（一）告诉才处理的案件； </li><li>（二）被害人有证据证明的轻微刑事案件； </li><li>（三）被害人有证据证明对被告人侵犯自己人身、财产权利的行为应当依法追究刑事责任，而公安机关或者人民检察院不予追究被告人刑事责任的案件。</li></ul><p><strong>第二百一十一条</strong></p><p>人民法院对于自诉案件进行审查后，按照下列情形分别处理： </p><ul><li>（一）犯罪事实清楚，有足够证据的案件，应当开庭审判；</li><li>（二）缺乏罪证的自诉案件，如果自诉人提不出补充证据，应当说服自诉人撤回自诉，或者裁定驳回。 自诉人经两次依法传唤，无正当理由拒不到庭的，或者未经法庭许可中途退庭的，按撤诉处理。 法庭审理过程中，审判人员对证据有疑问，需要调查核实的，适用本法第一百九十六条的规定。</li></ul><p><strong>第二百一十二条</strong></p><p>人民法院对自诉案件，可以进行调解；自诉人在宣告判决前，可以同被告人自行和解或者撤回自诉。本法第二百一十条第三项规定的案件不适用调解。 人民法院审理自诉案件的期限，被告人被羁押的，适用本法第二百零八条第一款、第二款的规定；未被羁押的，应当在受理后六个月以内宣判。</p><p><strong>第二百一十三条</strong></p><p>自诉案件的被告人在诉讼过程中，可以对自诉人提起反诉。反诉适用自诉的规定。</p><p><strong>第二百一十四条</strong></p><p>基层人民法院管辖的案件，符合下列条件的，可以适用简易程序审判： </p><ul><li>（一）案件事实清楚、证据充分的； </li><li>（二）被告人承认自己所犯罪行，对指控的犯罪事实没有异议的；</li><li>（三）被告人对适用简易程序没有异议的。 人民检察院在提起公诉的时候，可以建议人民法院适用简易程序。</li></ul><p><strong>第二百一十五条</strong></p><p>有下列情形之一的，不适用简易程序： </p><ul><li>（一）被告人是盲、聋、哑人，或者是尚未完全丧失辨认或者控制自己行为能力的精神病人的；</li><li>（二）有重大社会影响的；</li><li>（三）共同犯罪案件中部分被告人不认罪或者对适用简易程序有异议的；</li><li>（四）其他不宜适用简易程序审理的。</li></ul><p><strong>第二百一十六条</strong></p><p>适用简易程序审理案件，对可能判处三年有期徒刑以下刑罚的，可以组成合议庭进行审判，也可以由审判员一人独任审判；对可能判处的有期徒刑超过三年的，应当组成合议庭进行审判。 适用简易程序审理公诉案件，人民检察院应当派员出席法庭。</p><p><strong>第二百一十七条</strong></p><p>适用简易程序审理案件，审判人员应当询问被告人对指控的犯罪事实的意见，告知被告人适用简易程序审理的法律规定，确认被告人是否同意适用简易程序审理。</p><p><strong>第二百一十八条</strong></p><p>适用简易程序审理案件，经审判人员许可，被告人及其辩护人可以同公诉人、自诉人及其诉讼代理人互相辩论。</p><p><strong>第二百一十九条</strong></p><p>适用简易程序审理案件，不受本章第一节关于送达期限、讯问被告人、询问证人、鉴定人、出示证据、法庭辩论程序规定的限制。但在判决宣告前应当听取被告人的最后陈述意见。</p><p><strong>第二百二十条</strong></p><p>适用简易程序审理案件，人民法院应当在受理后二十日以内审结；对可能判处的有期徒刑超过三年的，可以延长至一个半月。</p><p><strong>第二百二十一条</strong></p><p>人民法院在审理过程中，发现不宜适用简易程序的，应当按照本章第一节或者第二节的规定重新审理。</p><p><strong>第二百二十二条</strong></p><p>基层人民法院管辖的可能判处三年有期徒刑以下刑罚的案件，案件事实清楚，证据确实、充分，被告人认罪认罚并同意适用速裁程序的，可以适用速裁程序，由审判员一人独任审判。 人民检察院在提起公诉的时候，可以建议人民法院适用速裁程序。</p><p><strong>第二百二十三条</strong></p><p>有下列情形之一的，不适用速裁程序：</p><ul><li>（一）被告人是盲、聋、哑人，或者是尚未完全丧失辨认或者控制自己行为能力的精神病人的；</li><li>（二）被告人是未成年人的；</li><li>（三）案件有重大社会影响的； </li><li>（四）共同犯罪案件中部分被告人对指控的犯罪事实、罪名、量刑建议或者适用速裁程序有异议的；</li><li>（五）被告人与被害人或者其法定代理人没有就附带民事诉讼赔偿等事项达成调解或者和解协议的；</li><li>（六）其他不宜适用速裁程序审理的。</li></ul><p><strong>第二百二十四条</strong></p><p>适用速裁程序审理案件，不受本章第一节规定的送达期限的限制，一般不进行法庭调查、法庭辩论，但在判决宣告前应当听取辩护人的意见和被告人的最后陈述意见。 适用速裁程序审理案件，应当当庭宣判。</p><p><strong>第二百二十五条</strong></p><p>适用速裁程序审理案件，人民法院应当在受理后十日以内审结；对可能判处的有期徒刑超过一年的，可以延长至十五日。</p><p><strong>第二百二十六条</strong></p><p>人民法院在审理过程中，发现有被告人的行为不构成犯罪或者不应当追究其刑事责任、被告人违背意愿认罪认罚、被告人否认指控的犯罪事实或者其他不宜适用速裁程序审理的情形的，应当按照本章第一节或者第三节的规定重新审理。</p><h4 id="第三章-第二审程序"><a href="#第三章-第二审程序" class="headerlink" title="第三章　第二审程序"></a>第三章　第二审程序</h4><p><strong>第二百二十七条</strong></p><p>被告人、自诉人和他们的法定代理人，不服地方各级人民法院第一审的判决、裁定，有权用书状或者口头向上一级人民法院上诉。被告人的辩护人和近亲属，经被告人同意，可以提出上诉。 附带民事诉讼的当事人和他们的法定代理人，可以对地方各级人民法院第一审的判决、裁定中的附带民事诉讼部分，提出上诉。 对被告人的上诉权，不得以任何借口加以剥夺。</p><p><strong>第二百二十八条</strong></p><p>地方各级人民检察院认为本级人民法院第一审的判决、裁定确有错误的时候，应当向上一级人民法院提出抗诉。</p><p><strong>第二百二十九条</strong></p><p>被害人及其法定代理人不服地方各级人民法院第一审的判决的，自收到判决书后五日以内，有权请求人民检察院提出抗诉。人民检察院自收到被害人及其法定代理人的请求后五日以内，应当作出是否抗诉的决定并且答复请求人。</p><p><strong>第二百三十条</strong></p><p>不服判决的上诉和抗诉的期限为十日，不服裁定的上诉和抗诉的期限为五日，从接到判决书、裁定书的第二日起算。</p><p><strong>第二百三十一条</strong></p><p>被告人、自诉人、附带民事诉讼的原告人和被告人通过原审人民法院提出上诉的，原审人民法院应当在三日以内将上诉状连同案卷、证据移送上一级人民法院，同时将上诉状副本送交同级人民检察院和对方当事人。 被告人、自诉人、附带民事诉讼的原告人和被告人直接向第二审人民法院提出上诉的，第二审人民法院应当在三日以内将上诉状交原审人民法院送交同级人民检察院和对方当事人。</p><p><strong>第二百三十二条</strong></p><p>地方各级人民检察院对同级人民法院第一审判决、裁定的抗诉，应当通过原审人民法院提出抗诉书，并且将抗诉书抄送上一级人民检察院。原审人民法院应当将抗诉书连同案卷、证据移送上一级人民法院，并且将抗诉书副本送交当事人。 上级人民检察院如果认为抗诉不当，可以向同级人民法院撤回抗诉，并且通知下级人民检察院。</p><p><strong>第二百三十三条</strong></p><p>第二审人民法院应当就第一审判决认定的事实和适用法律进行全面审查，不受上诉或者抗诉范围的限制。 共同犯罪的案件只有部分被告人上诉的，应当对全案进行审查，一并处理。</p><p><strong>第二百三十四条</strong></p><p>第二审人民法院对于下列案件，应当组成合议庭，开庭审理： </p><ul><li>（一）被告人、自诉人及其法定代理人对第一审认定的事实、证据提出异议，可能影响定罪量刑的上诉案件； </li><li>（二）被告人被判处死刑的上诉案件； </li><li>（三）人民检察院抗诉的案件； </li><li>（四）其他应当开庭审理的案件。 第二审人民法院决定不开庭审理的，应当讯问被告人，听取其他当事人、辩护人、诉讼代理人的意见。 第二审人民法院开庭审理上诉、抗诉案件，可以到案件发生地或者原审人民法院所在地进行。</li></ul><p><strong>第二百三十五条</strong></p><p>人民检察院提出抗诉的案件或者第二审人民法院开庭审理的公诉案件，同级人民检察院都应当派员出席法庭。第二审人民法院应当在决定开庭审理后及时通知人民检察院查阅案卷。人民检察院应当在一个月以内查阅完毕。人民检察院查阅案卷的时间不计入审理期限。</p><p><strong>第二百三十六条</strong></p><p>第二审人民法院对不服第一审判决的上诉、抗诉案件，经过审理后，应当按照下列情形分别处理： </p><ul><li>（一）原判决认定事实和适用法律正确、量刑适当的，应当裁定驳回上诉或者抗诉，维持原判；</li><li>（二）原判决认定事实没有错误，但适用法律有错误，或者量刑不当的，应当改判；</li><li>（三）原判决事实不清楚或者证据不足的，可以在查清事实后改判；也可以裁定撤销原判，发回原审人民法院重新审判。 原审人民法院对于依照前款第三项规定发回重新审判的案件作出判决后，被告人提出上诉或者人民检察院提出抗诉的，第二审人民法院应当依法作出判决或者裁定，不得再发回原审人民法院重新审判。</li></ul><p><strong>第二百三十七条</strong></p><p>第二审人民法院审理被告人或者他的法定代理人、辩护人、近亲属上诉的案件，不得加重被告人的刑罚。第二审人民法院发回原审人民法院重新审判的案件，除有新的犯罪事实，人民检察院补充起诉的以外，原审人民法院也不得加重被告人的刑罚。 人民检察院提出抗诉或者自诉人提出上诉的，不受前款规定的限制。</p><p><strong>第二百三十八条</strong></p><p>第二审人民法院发现第一审人民法院的审理有下列违反法律规定的诉讼程序的情形之一的，应当裁定撤销原判，发回原审人民法院重新审判： </p><ul><li>（一）违反本法有关公开审判的规定的； </li><li>（二）违反回避制度的； </li><li>（三）剥夺或者限制了当事人的法定诉讼权利，可能影响公正审判的； </li><li>（四）审判组织的组成不合法的； （五）其他违反法律规定的诉讼程序，可能影响公正审判的。</li></ul><p><strong>第二百三十九条</strong></p><p>原审人民法院对于发回重新审判的案件，应当另行组成合议庭，依照第一审程序进行审判。对于重新审判后的判决，依照本法第二百二十七条、第二百二十八条、第二百二十九条的规定可以上诉、抗诉。</p><p><strong>第二百四十条</strong></p><p>第二审人民法院对不服第一审裁定的上诉或者抗诉，经过审查后，应当参照本法第二百三十六条、第二百三十八条和第二百三十九条的规定，分别情形用裁定驳回上诉、抗诉，或者撤销、变更原裁定。</p><p><strong>第二百四十一条</strong></p><p>第二审人民法院发回原审人民法院重新审判的案件，原审人民法院从收到发回的案件之日起，重新计算审理期限。</p><p><strong>第二百四十二条</strong></p><p>第二审人民法院审判上诉或者抗诉案件的程序，除本章已有规定的以外，参照第一审程序的规定进行。</p><p><strong>第二百四十三条</strong></p><p>第二审人民法院受理上诉、抗诉案件，应当在二个月以内审结。对于可能判处死刑的案件或者附带民事诉讼的案件，以及有本法第一百五十八条规定情形之一的，经省、自治区、直辖市高级人民法院批准或者决定，可以延长二个月；因特殊情况还需要延长的，报请最高人民法院批准。 最高人民法院受理上诉、抗诉案件的审理期限，由最高人民法院决定。</p><p><strong>第二百四十四条</strong></p><p>第二审的判决、裁定和最高人民法院的判决、裁定，都是终审的判决、裁定。</p><p><strong>第二百四十五条</strong></p><p>公安机关、人民检察院和人民法院对查封、扣押、冻结的犯罪嫌疑人、被告人的财物及其孳息，应当妥善保管，以供核查，并制作清单，随案移送。任何单位和个人不得挪用或者自行处理。对被害人的合法财产，应当及时返还。对违禁品或者不宜长期保存的物品，应当依照国家有关规定处理。 对作为证据使用的实物应当随案移送，对不宜移送的，应当将其清单、照片或者其他证明文件随案移送。 人民法院作出的判决，应当对查封、扣押、冻结的财物及其孳息作出处理。 人民法院作出的判决生效以后，有关机关应当根据判决对查封、扣押、冻结的财物及其孳息进行处理。对查封、扣押、冻结的赃款赃物及其孳息，除依法返还被害人的以外，一律上缴国库。 司法工作人员贪污、挪用或者私自处理查封、扣押、冻结的财物及其孳息的，依法追究刑事责任；不构成犯罪的，给予处分。</p><h4 id="第四章-死刑复核程序"><a href="#第四章-死刑复核程序" class="headerlink" title="第四章　死刑复核程序"></a>第四章　死刑复核程序</h4><p><strong>第二百四十六条</strong></p><p>死刑由最高人民法院核准。</p><p><strong>第二百四十七条</strong></p><p>中级人民法院判处死刑的第一审案件，被告人不上诉的，应当由高级人民法院复核后，报请最高人民法院核准。高级人民法院不同意判处死刑的，可以提审或者发回重新审判。 高级人民法院判处死刑的第一审案件被告人不上诉的，和判处死刑的第二审案件，都应当报请最高人民法院核准。</p><p><strong>第二百四十八条</strong></p><p>中级人民法院判处死刑缓期二年执行的案件，由高级人民法院核准。</p><p><strong>第二百四十九条</strong></p><p>最高人民法院复核死刑案件，高级人民法院复核死刑缓期执行的案件，应当由审判员三人组成合议庭进行。</p><p><strong>第二百五十条</strong></p><p>最高人民法院复核死刑案件，应当作出核准或者不核准死刑的裁定。对于不核准死刑的，最高人民法院可以发回重新审判或者予以改判。</p><p><strong>第二百五十一条</strong></p><p>最高人民法院复核死刑案件，应当讯问被告人，辩护律师提出要求的，应当听取辩护律师的意见。 在复核死刑案件过程中，最高人民检察院可以向最高人民法院提出意见。最高人民法院应当将死刑复核结果通报最高人民检察院。</p><h4 id="第五章-审判监督程序"><a href="#第五章-审判监督程序" class="headerlink" title="第五章　审判监督程序"></a>第五章　审判监督程序</h4><p><strong>第二百五十二条</strong></p><p>当事人及其法定代理人、近亲属，对已经发生法律效力的判决、裁定，可以向人民法院或者人民检察院提出申诉，但是不能停止判决、裁定的执行。</p><p><strong>第二百五十三条</strong></p><p>当事人及其法定代理人、近亲属的申诉符合下列情形之一的，人民法院应当重新审判： </p><ul><li>（一）有新的证据证明原判决、裁定认定的事实确有错误，可能影响定罪量刑的； </li><li>（二）据以定罪量刑的证据不确实、不充分、依法应当予以排除，或者证明案件事实的主要证据之间存在矛盾的； </li><li>（三）原判决、裁定适用法律确有错误的；</li><li>（四）违反法律规定的诉讼程序，可能影响公正审判的； （五）审判人员在审理该案件的时候，有贪污受贿，徇私舞弊，枉法裁判行为的。</li></ul><p><strong>第二百五十四条</strong></p><p>各级人民法院院长对本院已经发生法律效力的判决和裁定，如果发现在认定事实上或者在适用法律上确有错误，必须提交审判委员会处理。 最高人民法院对各级人民法院已经发生法律效力的判决和裁定，上级人民法院对下级人民法院已经发生法律效力的判决和裁定，如果发现确有错误，有权提审或者指令下级人民法院再审。 最高人民检察院对各级人民法院已经发生法律效力的判决和裁定，上级人民检察院对下级人民法院已经发生法律效力的判决和裁定，如果发现确有错误，有权按照审判监督程序向同级人民法院提出抗诉。 人民检察院抗诉的案件，接受抗诉的人民法院应当组成合议庭重新审理，对于原判决事实不清楚或者证据不足的，可以指令下级人民法院再审。</p><p><strong>第二百五十五条</strong></p><p>上级人民法院指令下级人民法院再审的，应当指令原审人民法院以外的下级人民法院审理；由原审人民法院审理更为适宜的，也可以指令原审人民法院审理。</p><p><strong>第二百五十六条</strong></p><p>人民法院按照审判监督程序重新审判的案件，由原审人民法院审理的，应当另行组成合议庭进行。如果原来是第一审案件，应当依照第一审程序进行审判，所作的判决、裁定，可以上诉、抗诉；如果原来是第二审案件，或者是上级人民法院提审的案件，应当依照第二审程序进行审判，所作的判决、裁定，是终审的判决、裁定。 人民法院开庭审理的再审案件，同级人民检察院应当派员出席法庭。</p><p><strong>第二百五十七条</strong></p><p>人民法院决定再审的案件，需要对被告人采取强制措施的，由人民法院依法决定；人民检察院提出抗诉的再审案件，需要对被告人采取强制措施的，由人民检察院依法决定。 人民法院按照审判监督程序审判的案件，可以决定中止原判决、裁定的执行。</p><p><strong>第二百五十八条</strong></p><p>人民法院按照审判监督程序重新审判的案件，应当在作出提审、再审决定之日起三个月以内审结，需要延长期限的，不得超过六个月。 接受抗诉的人民法院按照审判监督程序审判抗诉的案件，审理期限适用前款规定；对需要指令下级人民法院再审的，应当自接受抗诉之日起一个月以内作出决定，下级人民法院审理案件的期限适用前款规定。</p><h3 id="第四编-执-行"><a href="#第四编-执-行" class="headerlink" title="第四编　执　　行"></a>第四编　执　　行</h3><p><strong>第二百五十九条</strong></p><p>判决和裁定在发生法律效力后执行。 下列判决和裁定是发生法律效力的判决和裁定： （一）已过法定期限没有上诉、抗诉的判决和裁定； （二）终审的判决和裁定； （三）最高人民法院核准的死刑的判决和高级人民法院核准的死刑缓期二年执行的判决。</p><p><strong>第二百六十条</strong></p><p>第一审人民法院判决被告人无罪、免除刑事处罚的，如果被告人在押，在宣判后应当立即释放。</p><p><strong>第二百六十一条</strong></p><p>最高人民法院判处和核准的死刑立即执行的判决，应当由最高人民法院院长签发执行死刑的命令。 被判处死刑缓期二年执行的罪犯，在死刑缓期执行期间，如果没有故意犯罪，死刑缓期执行期满，应当予以减刑的，由执行机关提出书面意见，报请高级人民法院裁定；如果故意犯罪，情节恶劣，查证属实，应当执行死刑的，由高级人民法院报请最高人民法院核准；对于故意犯罪未执行死刑的，死刑缓期执行的期间重新计算，并报最高人民法院备案。</p><p><strong>第二百六十二条</strong></p><p>下级人民法院接到最高人民法院执行死刑的命令后，应当在七日以内交付执行。但是发现有下列情形之一的，应当停止执行，并且立即报告最高人民法院，由最高人民法院作出裁定： </p><ul><li>（一）在执行前发现判决可能有错误的；</li><li>（二）在执行前罪犯揭发重大犯罪事实或者有其他重大立功表现，可能需要改判的；</li><li>（三）罪犯正在怀孕。 前款第一项、第二项停止执行的原因消失后，必须报请最高人民法院院长再签发执行死刑的命令才能执行；由于前款第三项原因停止执行的，应当报请最高人民法院依法改判。</li></ul><p><strong>第二百六十三条</strong></p><p>人民法院在交付执行死刑前，应当通知同级人民检察院派员临场监督。 死刑采用枪决或者注射等方法执行。 死刑可以在刑场或者指定的羁押场所内执行。 指挥执行的审判人员，对罪犯应当验明正身，讯问有无遗言、信札，然后交付执行人员执行死刑。在执行前，如果发现可能有错误，应当暂停执行，报请最高人民法院裁定。 执行死刑应当公布，不应示众。 执行死刑后，在场书记员应当写成笔录。交付执行的人民法院应当将执行死刑情况报告最高人民法院。 执行死刑后，交付执行的人民法院应当通知罪犯家属。</p><p><strong>第二百六十四条</strong></p><p>罪犯被交付执行刑罚的时候，应当由交付执行的人民法院在判决生效后十日以内将有关的法律文书送达公安机关、监狱或者其他执行机关。 对被判处死刑缓期二年执行、无期徒刑、有期徒刑的罪犯，由公安机关依法将该罪犯送交监狱执行刑罚。对被判处有期徒刑的罪犯，在被交付执行刑罚前，剩余刑期在三个月以下的，由看守所代为执行。对被判处拘役的罪犯，由公安机关执行。 对未成年犯应当在未成年犯管教所执行刑罚。 执行机关应当将罪犯及时收押，并且通知罪犯家属。 判处有期徒刑、拘役的罪犯，执行期满，应当由执行机关发给释放证明书。</p><p><strong>第二百六十五条</strong></p><p>对被判处有期徒刑或者拘役的罪犯，有下列情形之一的，可以暂予监外执行： </p><ul><li>（一）有严重疾病需要保外就医的； </li><li>（二）怀孕或者正在哺乳自己婴儿的妇女； </li><li>（三）生活不能自理，适用暂予监外执行不致危害社会的。 对被判处无期徒刑的罪犯，有前款第二项规定情形的，可以暂予监外执行。 对适用保外就医可能有社会危险性的罪犯，或者自伤自残的罪犯，不得保外就医。 对罪犯确有严重疾病，必须保外就医的，由省级人民政府指定的医院诊断并开具证明文件。 在交付执行前，暂予监外执行由交付执行的人民法院决定；在交付执行后，暂予监外执行由监狱或者看守所提出书面意见，报省级以上监狱管理机关或者设区的市一级以上公安机关批准。</li></ul><p><strong>第二百六十六条</strong></p><p>监狱、看守所提出暂予监外执行的书面意见的，应当将书面意见的副本抄送人民检察院。人民检察院可以向决定或者批准机关提出书面意见。</p><p><strong>第二百六十七条</strong></p><p>决定或者批准暂予监外执行的机关应当将暂予监外执行决定抄送人民检察院。人民检察院认为暂予监外执行不当的，应当自接到通知之日起一个月以内将书面意见送交决定或者批准暂予监外执行的机关，决定或者批准暂予监外执行的机关接到人民检察院的书面意见后，应当立即对该决定进行重新核查。</p><p><strong>第二百六十八条</strong></p><p>对暂予监外执行的罪犯，有下列情形之一的，应当及时收监： </p><ul><li>（一）发现不符合暂予监外执行条件的； </li><li>（二）严重违反有关暂予监外执行监督管理规定的；</li><li>（三）暂予监外执行的情形消失后，罪犯刑期未满的。 对于人民法院决定暂予监外执行的罪犯应当予以收监的，由人民法院作出决定，将有关的法律文书送达公安机关、监狱或者其他执行机关。 不符合暂予监外执行条件的罪犯通过贿赂等非法手段被暂予监外执行的，在监外执行的期间不计入执行刑期。罪犯在暂予监外执行期间脱逃的，脱逃的期间不计入执行刑期。 罪犯在暂予监外执行期间死亡的，执行机关应当及时通知监狱或者看守所。</li></ul><p><strong>第二百六十九条</strong></p><p>对被判处管制、宣告缓刑、假释或者暂予监外执行的罪犯，依法实行社区矫正，由社区矫正机构负责执行。</p><p><strong>第二百七十条</strong></p><p>对被判处剥夺政治权利的罪犯，由公安机关执行。执行期满，应当由执行机关书面通知本人及其所在单位、居住地基层组织。</p><p><strong>第二百七十一条</strong></p><p>被判处罚金的罪犯，期满不缴纳的，人民法院应当强制缴纳；如果由于遭遇不能抗拒的灾祸等原因缴纳确实有困难的，经人民法院裁定，可以延期缴纳、酌情减少或者免除。</p><p><strong>第二百七十二条</strong></p><p>没收财产的判决，无论附加适用或者独立适用，都由人民法院执行；在必要的时候，可以会同公安机关执行。</p><p><strong>第二百七十三条</strong></p><p>罪犯在服刑期间又犯罪的，或者发现了判决的时候所没有发现的罪行，由执行机关移送人民检察院处理。 被判处管制、拘役、有期徒刑或者无期徒刑的罪犯，在执行期间确有悔改或者立功表现，应当依法予以减刑、假释的时候，由执行机关提出建议书，报请人民法院审核裁定，并将建议书副本抄送人民检察院。人民检察院可以向人民法院提出书面意见。</p><p><strong>第二百七十四条</strong></p><p>人民检察院认为人民法院减刑、假释的裁定不当，应当在收到裁定书副本后二十日以内，向人民法院提出书面纠正意见。人民法院应当在收到纠正意见后一个月以内重新组成合议庭进行审理，作出最终裁定。</p><p><strong>第二百七十五条</strong></p><p>监狱和其他执行机关在刑罚执行中，如果认为判决有错误或者罪犯提出申诉，应当转请人民检察院或者原判人民法院处理。</p><p><strong>第二百七十六条</strong></p><p>人民检察院对执行机关执行刑罚的活动是否合法实行监督。如果发现有违法的情况，应当通知执行机关纠正。</p><h3 id="第五编-特别程序"><a href="#第五编-特别程序" class="headerlink" title="第五编　特别程序"></a>第五编　特别程序</h3><h4 id="第一章-未成年人刑事案件诉讼程序"><a href="#第一章-未成年人刑事案件诉讼程序" class="headerlink" title="第一章　未成年人刑事案件诉讼程序"></a>第一章　未成年人刑事案件诉讼程序</h4><p><strong>第二百七十七条</strong></p><p>对犯罪的未成年人实行教育、感化、挽救的方针，坚持教育为主、惩罚为辅的原则。 人民法院、人民检察院和公安机关办理未成年人刑事案件，应当保障未成年人行使其诉讼权利，保障未成年人得到法律帮助，并由熟悉未成年人身心特点的审判人员、检察人员、侦查人员承办。</p><p><strong>第二百七十八条</strong></p><p>未成年犯罪嫌疑人、被告人没有委托辩护人的，人民法院、人民检察院、公安机关应当通知法律援助机构指派律师为其提供辩护。</p><p><strong>第二百七十九条</strong></p><p>公安机关、人民检察院、人民法院办理未成年人刑事案件，根据情况可以对未成年犯罪嫌疑人、被告人的成长经历、犯罪原因、监护教育等情况进行调查。</p><p><strong>第二百八十条</strong></p><p>对未成年犯罪嫌疑人、被告人应当严格限制适用逮捕措施。人民检察院审查批准逮捕和人民法院决定逮捕，应当讯问未成年犯罪嫌疑人、被告人，听取辩护律师的意见。 对被拘留、逮捕和执行刑罚的未成年人与成年人应当分别关押、分别管理、分别教育。</p><p><strong>第二百八十一条</strong></p><p>对于未成年人刑事案件，在讯问和审判的时候，应当通知未成年犯罪嫌疑人、被告人的法定代理人到场。无法通知、法定代理人不能到场或者法定代理人是共犯的，也可以通知未成年犯罪嫌疑人、被告人的其他成年亲属，所在学校、单位、居住地基层组织或者未成年人保护组织的代表到场，并将有关情况记录在案。到场的法定代理人可以代为行使未成年犯罪嫌疑人、被告人的诉讼权利。 到场的法定代理人或者其他人员认为办案人员在讯问、审判中侵犯未成年人合法权益的，可以提出意见。讯问笔录、法庭笔录应当交给到场的法定代理人或者其他人员阅读或者向他宣读。 讯问女性未成年犯罪嫌疑人，应当有女工作人员在场。 审判未成年人刑事案件，未成年被告人最后陈述后，其法定代理人可以进行补充陈述。 询问未成年被害人、证人，适用第一款、第二款、第三款的规定。</p><p><strong>第二百八十二条</strong></p><p>对于未成年人涉嫌刑法分则第四章、第五章、第六章规定的犯罪，可能判处一年有期徒刑以下刑罚，符合起诉条件，但有悔罪表现的，人民检察院可以作出附条件不起诉的决定。人民检察院在作出附条件不起诉的决定以前，应当听取公安机关、被害人的意见。 对附条件不起诉的决定，公安机关要求复议、提请复核或者被害人申诉的，适用本法第一百七十九条、第一百八十条的规定。 未成年犯罪嫌疑人及其法定代理人对人民检察院决定附条件不起诉有异议的，人民检察院应当作出起诉的决定。</p><p><strong>第二百八十三条</strong></p><p>在附条件不起诉的考验期内，由人民检察院对被附条件不起诉的未成年犯罪嫌疑人进行监督考察。未成年犯罪嫌疑人的监护人，应当对未成年犯罪嫌疑人加强管教，配合人民检察院做好监督考察工作。 附条件不起诉的考验期为六个月以上一年以下，从人民检察院作出附条件不起诉的决定之日起计算。 被附条件不起诉的未成年犯罪嫌疑人，应当遵守下列规定：   </p><ul><li>（一）遵守法律法规，服从监督；</li><li>（二）按照考察机关的规定报告自己的活动情况； </li><li>（三）离开所居住的市、县或者迁居，应当报经考察机关批准；</li><li>（四）按照考察机关的要求接受矫治和教育。</li></ul><p><strong>第二百八十四条</strong></p><p>被附条件不起诉的未成年犯罪嫌疑人，在考验期内有下列情形之一的，人民检察院应当撤销附条件不起诉的决定，提起公诉： </p><ul><li>（一）实施新的犯罪或者发现决定附条件不起诉以前还有其他犯罪需要追诉的； </li><li>（二）违反治安管理规定或者考察机关有关附条件不起诉的监督管理规定，情节严重的。 被附条件不起诉的未成年犯罪嫌疑人，在考验期内没有上述情形，考验期满的，人民检察院应当作出不起诉的决定。</li></ul><p><strong>第二百八十五条</strong></p><p>审判的时候被告人不满十八周岁的案件，不公开审理。但是，经未成年被告人及其法定代理人同意，未成年被告人所在学校和未成年人保护组织可以派代表到场。</p><p><strong>第二百八十六条</strong></p><p>犯罪的时候不满十八周岁，被判处五年有期徒刑以下刑罚的，应当对相关犯罪记录予以封存。 犯罪记录被封存的，不得向任何单位和个人提供，但司法机关为办案需要或者有关单位根据国家规定进行查询的除外。依法进行查询的单位，应当对被封存的犯罪记录的情况予以保密。</p><p><strong>第二百八十七条</strong></p><p>办理未成年人刑事案件，除本章已有规定的以外，按照本法的其他规定进行。</p><h4 id="第二章-当事人和解的公诉案件诉讼程序"><a href="#第二章-当事人和解的公诉案件诉讼程序" class="headerlink" title="第二章　当事人和解的公诉案件诉讼程序"></a>第二章　当事人和解的公诉案件诉讼程序</h4><p><strong>第二百八十八条</strong></p><p>下列公诉案件，犯罪嫌疑人、被告人真诚悔罪，通过向被害人赔偿损失、赔礼道歉等方式获得被害人谅解，被害人自愿和解的，双方当事人可以和解： （一）因民间纠纷引起，涉嫌刑法分则第四章、第五章规定的犯罪案件，可能判处三年有期徒刑以下刑罚的； （二）除渎职犯罪以外的可能判处七年有期徒刑以下刑罚的过失犯罪案件。 犯罪嫌疑人、被告人在五年以内曾经故意犯罪的，不适用本章规定的程序。</p><p><strong>第二百八十九条</strong></p><p>双方当事人和解的，公安机关、人民检察院、人民法院应当听取当事人和其他有关人员的意见，对和解的自愿性、合法性进行审查，并主持制作和解协议书。</p><p><strong>第二百九十条</strong></p><p>对于达成和解协议的案件，公安机关可以向人民检察院提出从宽处理的建议。人民检察院可以向人民法院提出从宽处罚的建议；对于犯罪情节轻微，不需要判处刑罚的，可以作出不起诉的决定。人民法院可以依法对被告人从宽处罚。</p><h4 id="第三章-缺席审判程序"><a href="#第三章-缺席审判程序" class="headerlink" title="第三章　缺席审判程序"></a>第三章　缺席审判程序</h4><p><strong>第二百九十一条</strong></p><p>对于贪污贿赂犯罪案件，以及需要及时进行审判，经最高人民检察院核准的严重危害国家安全犯罪、恐怖活动犯罪案件，犯罪嫌疑人、被告人在境外，监察机关、公安机关移送起诉，人民检察院认为犯罪事实已经查清，证据确实、充分，依法应当追究刑事责任的，可以向人民法院提起公诉。人民法院进行审查后，对于起诉书中有明确的指控犯罪事实，符合缺席审判程序适用条件的，应当决定开庭审判。 前款案件，由犯罪地、被告人离境前居住地或者最高人民法院指定的中级人民法院组成合议庭进行审理。</p><p><strong>第二百九十二条</strong></p><p>人民法院应当通过有关国际条约规定的或者外交途径提出的司法协助方式，或者被告人所在地法律允许的其他方式，将传票和人民检察院的起诉书副本送达被告人。传票和起诉书副本送达后，被告人未按要求到案的，人民法院应当开庭审理，依法作出判决，并对违法所得及其他涉案财产作出处理。</p><p><strong>第二百九十三条</strong></p><p>人民法院缺席审判案件，被告人有权委托辩护人，被告人的近亲属可以代为委托辩护人。被告人及其近亲属没有委托辩护人的，人民法院应当通知法律援助机构指派律师为其提供辩护。</p><p><strong>第二百九十四条</strong></p><p>人民法院应当将判决书送达被告人及其近亲属、辩护人。被告人或者其近亲属不服判决的，有权向上一级人民法院上诉。辩护人经被告人或者其近亲属同意，可以提出上诉。 人民检察院认为人民法院的判决确有错误的，应当向上一级人民法院提出抗诉。</p><p><strong>第二百九十五条</strong></p><p>在审理过程中，被告人自动投案或者被抓获的，人民法院应当重新审理。 罪犯在判决、裁定发生法律效力后到案的，人民法院应当将罪犯交付执行刑罚。交付执行刑罚前，人民法院应当告知罪犯有权对判决、裁定提出异议。罪犯对判决、裁定提出异议的，人民法院应当重新审理。 依照生效判决、裁定对罪犯的财产进行的处理确有错误的，应当予以返还、赔偿。</p><p><strong>第二百九十六条</strong></p><p>因被告人患有严重疾病无法出庭，中止审理超过六个月，被告人仍无法出庭，被告人及其法定代理人、近亲属申请或者同意恢复审理的，人民法院可以在被告人不出庭的情况下缺席审理，依法作出判决。</p><p><strong>第二百九十七条</strong></p><p>被告人死亡的，人民法院应当裁定终止审理，但有证据证明被告人无罪，人民法院经缺席审理确认无罪的，应当依法作出判决。 人民法院按照审判监督程序重新审判的案件，被告人死亡的，人民法院可以缺席审理，依法作出判决。</p><h4 id="第四章-犯罪嫌疑人、被告人逃匿、死亡案件违法所得的没收程序"><a href="#第四章-犯罪嫌疑人、被告人逃匿、死亡案件违法所得的没收程序" class="headerlink" title="第四章　犯罪嫌疑人、被告人逃匿、死亡案件违法所得的没收程序"></a>第四章　犯罪嫌疑人、被告人逃匿、死亡案件违法所得的没收程序</h4><p><strong>第二百九十八条</strong></p><p>对于贪污贿赂犯罪、恐怖活动犯罪等重大犯罪案件，犯罪嫌疑人、被告人逃匿，在通缉一年后不能到案，或者犯罪嫌疑人、被告人死亡，依照刑法规定应当追缴其违法所得及其他涉案财产的，人民检察院可以向人民法院提出没收违法所得的申请。 公安机关认为有前款规定情形的，应当写出没收违法所得意见书，移送人民检察院。 没收违法所得的申请应当提供与犯罪事实、违法所得相关的证据材料，并列明财产的种类、数量、所在地及查封、扣押、冻结的情况。 人民法院在必要的时候，可以查封、扣押、冻结申请没收的财产。</p><p><strong>第二百九十九条</strong></p><p>没收违法所得的申请，由犯罪地或者犯罪嫌疑人、被告人居住地的中级人民法院组成合议庭进行审理。 人民法院受理没收违法所得的申请后，应当发出公告。公告期间为六个月。犯罪嫌疑人、被告人的近亲属和其他利害关系人有权申请参加诉讼，也可以委托诉讼代理人参加诉讼。 人民法院在公告期满后对没收违法所得的申请进行审理。利害关系人参加诉讼的，人民法院应当开庭审理。</p><p><strong>第三百条</strong></p><p>人民法院经审理，对经查证属于违法所得及其他涉案财产，除依法返还被害人的以外，应当裁定予以没收；对不属于应当追缴的财产的，应当裁定驳回申请，解除查封、扣押、冻结措施。 对于人民法院依照前款规定作出的裁定，犯罪嫌疑人、被告人的近亲属和其他利害关系人或者人民检察院可以提出上诉、抗诉。</p><p><strong>第三百零一条</strong></p><p>在审理过程中，在逃的犯罪嫌疑人、被告人自动投案或者被抓获的，人民法院应当终止审理。 没收犯罪嫌疑人、被告人财产确有错误的，应当予以返还、赔偿。</p><h4 id="第五章-依法不负刑事责任的精神病人的强制医疗程序"><a href="#第五章-依法不负刑事责任的精神病人的强制医疗程序" class="headerlink" title="第五章　依法不负刑事责任的精神病人的强制医疗程序"></a>第五章　依法不负刑事责任的精神病人的强制医疗程序</h4><p><strong>第三百零二条</strong></p><p>实施暴力行为，危害公共安全或者严重危害公民人身安全，经法定程序鉴定依法不负刑事责任的精神病人，有继续危害社会可能的，可以予以强制医疗。</p><p><strong>第三百零三条</strong></p><p>根据本章规定对精神病人强制医疗的，由人民法院决定。 公安机关发现精神病人符合强制医疗条件的，应当写出强制医疗意见书，移送人民检察院。对于公安机关移送的或者在审查起诉过程中发现的精神病人符合强制医疗条件的，人民检察院应当向人民法院提出强制医疗的申请。人民法院在审理案件过程中发现被告人符合强制医疗条件的，可以作出强制医疗的决定。 对实施暴力行为的精神病人，在人民法院决定强制医疗前，公安机关可以采取临时的保护性约束措施。</p><p><strong>第三百零四条</strong></p><p>人民法院受理强制医疗的申请后，应当组成合议庭进行审理。 人民法院审理强制医疗案件，应当通知被申请人或者被告人的法定代理人到场。被申请人或者被告人没有委托诉讼代理人的，人民法院应当通知法律援助机构指派律师为其提供法律帮助。</p><p><strong>第三百零五条</strong></p><p>人民法院经审理，对于被申请人或者被告人符合强制医疗条件的，应当在一个月以内作出强制医疗的决定。 被决定强制医疗的人、被害人及其法定代理人、近亲属对强制医疗决定不服的，可以向上一级人民法院申请复议。</p><p><strong>第三百零六条</strong></p><p>强制医疗机构应当定期对被强制医疗的人进行诊断评估。对于已不具有人身危险性，不需要继续强制医疗的，应当及时提出解除意见，报决定强制医疗的人民法院批准。 被强制医疗的人及其近亲属有权申请解除强制医疗。</p><p><strong>第三百零七条</strong></p><p>人民检察院对强制医疗的决定和执行实行监督。</p><h3 id="附则"><a href="#附则" class="headerlink" title="附则"></a>附则</h3><p><strong>第三百零八条</strong></p><p>军队保卫部门对军队内部发生的刑事案件行使侦查权。 中国海警局履行海上维权执法职责，对海上发生的刑事案件行使侦查权。 对罪犯在监狱内犯罪的案件由监狱进行侦查。 军队保卫部门、中国海警局、监狱办理刑事案件，适用本法的有关规定。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基本信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;发文字号：中华人民共和国主席令第十号&lt;/p&gt;
&lt;p&gt;效力级别法律：时效性现行有效&lt;/p&gt;
&lt;p&gt;发布日期：2018-10-26&lt;/p&gt;
&lt;p&gt;实施日期：2018-10-26&lt;/p&gt;
&lt;p&gt;发布机关：全国人大常委会&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="法律" scheme="https://removeif.github.io/categories/%E6%B3%95%E5%BE%8B/"/>
    
    
      <category term="法律" scheme="https://removeif.github.io/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>中华人民共和国劳动法</title>
    <link href="https://removeif.github.io/2019/08/21/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%8A%B3%E5%8A%A8%E6%B3%95.html"/>
    <id>https://removeif.github.io/2019/08/21/中华人民共和国劳动法.html</id>
    <published>2019-08-21T09:43:55.000Z</published>
    <updated>2019-08-22T02:35:51.362Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《中华人民共和国劳动法》已由中华人民共和国第八届全国人民代表大会常务委员会第八次会议于１９９４年７月５日通过，现予公布，自１９９５年１月１日起施行。<br><a id="more"></a></p></blockquote><p><strong>中华人民共和国主席令</strong></p><p>（第二十八号）</p><p>《中华人民共和国劳动法》已由中华人民共和国第八届全国人民代表大会常务委员会第八次会议于１９９４年７月５日通过，现予公布，自１９９５年１月１日起施行。</p><p>中华人民共和国主席 江泽民</p><p>１９９４年７月５日</p><p><strong>中华人民共和国劳动法</strong></p><p><strong>（１９９４年７月５日第八届全国人民代表大会常务委员会第八次会议通过）</strong></p><p>目录</p><p><a href="#1">第一章 总则</a></p><p><a href="#2">第二章 促进就业</a></p><p><a href="#3">第三章 劳动合同和集体合同</a></p><p><a href="#4">第四章 工作时间和休息休假</a></p><p><a href="#5">第五章 工资</a></p><p><a href="#6">第六章 劳动安全卫生</a></p><p><a href="#7">第七章 女职工和未成年工特殊保护</a></p><p><a href="#8">第八章 职业培训</a></p><p><a href="#9">第九章 社会保险和福利</a></p><p><a href="#10">第十章 劳动争议</a></p><p><a href="#11">第十一章 监督检查</a></p><p><a href="#12">第十二章 法律责任</a></p><p><a href="#13">第十三章 附则</a></p><p><span id="1"></span></p><p><strong>第一章 总则</strong></p><p>　</p><p>第一  为了保护劳动者的合法权益，调整劳动关系，建立和维护适应社会主义市场经济的劳动制度，促进经济发展和社会进步，根据宪法，制定本法。</p><p>第二  在中华人民共和国境内的企业、个体经济组织（以下统称用人单位）和与之形成劳动关系的劳动者，适用本法。</p><p>国家机关、事业组织、社会团体和与之建立劳动合同关系的劳动者，依照本法执行。</p><p>第三  劳动者享有平等就业和选择职业的权利、取得劳动报酬的权利、休息休假的权利、获得劳动安全卫生保护的权利、接受职业技能培训的权利、享受社会保险和福利的权利、提请劳动争议处理的权利以及法律规定的其他劳动权利。</p><p>劳动者应当完成劳动任务，提高职业技能，执行劳动安全卫生规程，遵守劳动纪律和职业道德。</p><p>第四  用人单位应当依法建立和完善规章制度，保障劳动者享有劳动权利和履行劳动义务。</p><p>第五  国家采取各种措施，促进劳动就业，发展职业教育，制定劳动标准，调节社会收入，完善社会保险，协调劳动关系，逐步提高劳动者的生活水平。</p><p>第六  国家提倡劳动者参加社会义务劳动，开展劳动竞赛和合理化建议活动，鼓励和保护劳动者进行科学研究、技术革新和发明创造，表彰和奖励劳动模范和先进工作者。</p><p>第七条 劳动者有权依法参加和组织工会。</p><p>工会代表和维护劳动者的合法权益，依法独立自主地开展活动。</p><p>第八  劳动者依照法律规定，通过职工大会、职工代表大会或者其他形式，参与民主管理或者就保护劳动者合法权益与用人单位进行平等协商。</p><p>第九条 国务院劳动行政部门主管全国劳动工作。</p><p>县级以上地方人民政府劳动行政部门主管本行政区域内的劳动工作。</p><p><span id="2">　</span></p><p><strong>第二章 促进就业</strong></p><p>　</p><p>第十  国家通过促进经济和社会发展，创造就业条件，扩大就业机会。</p><p>国家鼓励企业、事业组织、社会团体在法律、行政法规规定的范围内兴办产业或者拓展经营，增加就业。</p><p>国家支持劳动者自愿组织起来就业和从事个体经营实现就业。</p><p>第十一  地方各级人民政府应当采取措施，发展多种类型的职业介绍机构，提供就业服务。</p><p>第十二  劳动者就业，不因民族、种族、性别、宗教信仰不同而受歧视。</p><p>第十三  妇女享有与男子平等的就业权利。在录用职工时，除国家规定的不适合妇女的工种或者岗位外，不得以性别为由拒绝录用妇女或者提高对妇女的录用标准。</p><p>第十四  残疾人、少数民族人员、退出现役的军人的就业，法律、法规有特别规定的，从其规定。</p><p>第十五条 禁止用人单位招用未满十六周岁的未成年人。</p><p>文艺、体育和特种工艺单位招用未满十六周岁的未成年人，必须依照国家有关规定，履行审批手续，并保障其接受义务教育的权利。</p><p><span id="3"></span></p><p><strong>第三章 劳动合同和集体合同</strong></p><p>　</p><p>第十六  劳动合同是劳动者与用人单位确立劳动关系、明确双方权利和义务的协议。</p><p>建立劳动关系应当订立劳动合同。</p><p>第十七  订立和变更劳动合同，应当遵循平等自愿、协商一致的原则，不得违反法律、行政法规的规定。</p><p>劳动合同依法订立即具有法律约束力，当事人必须履行劳动合同规定的义务。</p><p>第十八条 下列劳动合同无效：</p><p>（一）违反法律、行政法规的劳动合同；</p><p>（二）采取欺诈、威胁等手段订立的劳动合同。</p><p>无效的劳动合同，从订立的时候起，就没有法律约束力。确认劳动合同部分无效的，如果不影响其余部分的效力，其余部分仍然有效。</p><p>劳动合同的无效，由劳动争议仲裁委员会或者人民法院确认。</p><p>第十九条 劳动合同应当以书面形式订立，并具备以下条款：</p><p>（一）劳动合同期限；</p><p>（二）工作内容；</p><p>（三）劳动保护和劳动条件；</p><p>（四）劳动报酬；</p><p>（五）劳动纪律；</p><p>（六）劳动合同终止的条件；</p><p>（七）违反劳动合同的责任。</p><p>劳动合同除前款规定的必备条款外，当事人可以协商约定其他内容。</p><p>第二十  劳动合同的期限分为有固定期限、无固定期限和以完成一定的工作为期限。</p><p>劳动者在同一用人单位连续工作满十年以上，当事人双方同意延续劳动合同的，如果劳动者提出订立无固定期限的劳动合同，应当订立无固定期限的劳动合同。</p><p>第二十一  劳动合同可以约定试用期。试用期最长不得超过六个月。</p><p>第二十二  劳动合同当事人可以在劳动合同中约定保守用人单位商业秘密的有关事项。</p><p>第二十三  劳动合同期满或者当事人约定的劳动合同终止条件出现，劳动合同即行终止。</p><p>第二十四条 经劳动合同当事人协商一致，劳动合同可以解除。</p><p>第二十五  劳动者有下列情形之一的，用人单位可以解除劳动合同：</p><p>（一）在试用期间被证明不符合录用条件的；</p><p>（二）严重违反劳动纪律或者用人单位规章制度的；</p><p>（三）严重失职，营私舞弊，对用人单位利益造成重大损害的；</p><p>（四）被依法追究刑事责任的。</p><p>第二十六  有下列情形之一的，用人单位可以解除劳动合同，但是应当提前三十日以书面形式通知劳动者本人：</p><p>（一）劳动者患病或者非因工负伤，医疗期满后，不能从事原工作也不能从事由用人单位另行安排的工作的；</p><p>（二）劳动者不能胜任工作，经过培训或者调整工作岗位，仍不能胜任工作的；</p><p>（三）劳动合同订立时所依据的客观情况发生重大变化，致使原劳动合同无法履行，经当事人协商不能就变更劳动合同达成协议的。</p><p>第二十七  用人单位濒临破产进行法定整顿期间或者生产经营状况发生严重困难，确需裁减人员的，应当提前三十日向工会或者全体职工说明情况，听取工会或者职工的意见，经向劳动行政部门报告后，可以裁减人员。</p><p>用人单位依据本条规定裁减人员，在六个月内录用人员的，应当优先录用被裁减的人员。</p><p>第二十八  用人单位依据本法第二十四条、第二十六条、第二十七条的规定解除劳动合同的，应当依照国家有关规定给予经济补偿。</p><p>第二十九  劳动者有下列情形之一的，用人单位不得依据本法第二十六条、第二十七条的规定解除劳动合同：</p><p>（一）患职业病或者因工负伤并被确认丧失或者部分丧失劳动能力的；</p><p>（二）患病或者负伤，在规定的医疗期内的；</p><p>（三）女职工在孕期、产假、哺乳期内的；</p><p>（四）法律、行政法规规定的其他情形。</p><p>第三十  用人单位解除劳动合同，工会认为不适当的，有权提出意见。如果用人单位违反法律、法规或者劳动合同，工会有权要求重新处理；劳动者申请仲裁或者提起诉讼的，工会应当依法给予支持和帮助。</p><p>第三十一  劳动者解除劳动合同，应当提前三十日以书面形式通知用人单位。</p><p>第三十二  有下列情形之一的，劳动者可以随时通知用人单位解除劳动合同：</p><p>（一）在试用期内的；</p><p>（二）用人单位以暴力、威胁或者非法限制人身自由的手段强迫劳动的；</p><p>（三）用人单位未按照劳动合同约定支付劳动报酬或者提供劳动条件的。</p><p>第三十三  企业职工一方与企业可以就劳动报酬、工作时间、休息休假、劳动安全卫生、保险福利等事项，签订集体合同。集体合同草案应当提交职工代表大会或者全体职工讨论通过。</p><p>集体合同由工会代表职工与企业签订；没有建立工会的企业，由职工推举的代表与企业签订。</p><p>第三十四  集体合同签订后应当报送劳动行政部门；劳动行政部门自收到集体合同文本之日起十五日内未提出异议的，集体合同即行生效。</p><p>第三十五  依法签订的集体合同对企业和企业全体职工具有约束力。职工个人与企业订立的劳动合同中劳动条件和劳动报酬等标准不得低于集体合同的规定。</p><p><span id="4"></span></p><p><strong>第四章 工作时间和休息休假</strong></p><p>　</p><p>第三十六  国家实行劳动者每日工作时间不超过八小时、平均每周工作时间不超过四十四小时的工时制度。</p><p>第三十七  对实行计件工作的劳动者，用人单位应当根据本法第三十六条规定的工时制度合理确定其劳动定额和计件报酬标准。</p><p>第三十八条 用人单位应当保证劳动者每周至少休息一日。</p><p>第三十九  企业因生产特点不能实行本法第三十六条、第三十八条规定的，经劳动行政部门批准，可以实行其他工作和休息办法。</p><p>第四十条 用人单位在下列节日期间应当依法安排劳动者休假：</p><p>（一）元旦；</p><p>（二）春节；</p><p>（三）国际劳动节；</p><p>（四）国庆节；</p><p>（五）法律、法规规定的其他休假节日。</p><p>第四十一  用人单位由于生产经营需要，经与工会和劳动者协商后可以延长工作时间，一般每日不得超过一小时；因特殊原因需要延长工作时间的，在保障劳动者身体健康的条件下延长工作时间每日不得超过三小时，但是每月不得超过三十六小时。</p><p>第四十二  有下列情形之一的，延长工作时间不受本法第四十一条规定的限制：</p><p>（一）发生自然灾害、事故或者因其他原因，威胁劳动者生命健康和财产安全，需要紧急处理的；</p><p>（二）生产设备、交通运输线路、公共设施发生故障，影响生产和公众利益，必须及时抢修的；</p><p>（三）法律、行政法规规定的其他情形。</p><p>第四十三条 用人单位不得违反本法规定延长劳动者的工作时间。</p><p>第四十四  有下列情形之一的，用人单位应当按照下列标准支付高于劳动者正常工作时间工资的工资报酬：</p><p>（一）安排劳动者延长工作时间的，支付不低于工资的百分之一百五十的工资报酬；</p><p>（二）休息日安排劳动者工作又不能安排补休的，支付不低于工资的百分之二百的工资报酬；</p><p>（三）法定休假日安排劳动者工作的，支付不低于工资的百分之三百的工资报酬。</p><p>第四十五条 国家实行带薪年休假制度。</p><p>劳动者连续工作一年以上的，享受带薪年休假。具体办法由国务院规定。</p><p><span id="5"></span></p><p><strong>第五章 工资</strong></p><p>　</p><p>第四十六条 工资分配应当遵循按劳分配原则，实行同工同酬。</p><p>工资水平在经济发展的基础上逐步提高。国家对工资总量实行宏观调控。</p><p>第四十七  用人单位根据本单位的生产经营特点和经济效益，依法自主确定本单位的工资分配方式和工资水平。</p><p>第四十八  国家实行最低工资保障制度。最低工资的具体标准由省、自治区、直辖市人民政府规定，报国务院备案。</p><p>用人单位支付劳动者的工资不得低于当地最低工资标准。</p><p>第四十九条 确定和调整最低工资标准应当综合参考下列因素：</p><p>（一）劳动者本人及平均赡养人口的最低生活费用；</p><p>（二）社会平均工资水平；</p><p>（三）劳动生产率；</p><p>（四）就业状况；</p><p>（五）地区之间经济发展水平的差异。</p><p>第五十  工资应当以货币形式按月支付给劳动者本人。不得克扣或者无故拖欠劳动者的工资。</p><p>第五十一  劳动者在法定休假日和婚丧假期间以及依法参加社会活动期间，用人单位应当依法支付工资。</p><p><span id="6">　</span></p><p><strong>第六章 劳动安全卫生</strong></p><p>　</p><p>第五十二  用人单位必须建立、健全劳动安全卫生制度，严格执行国家劳动安全卫生规程和标准，对劳动者进行劳动安全卫生教育，防止劳动过程中的事故，减少职业危害。</p><p>第五十三条 劳动安全卫生设施必须符合国家规定的标准。</p><p>新建、改建、扩建工程的劳动安全卫生设施必须与主体工程同时设计、同时施工、同时投入生产和使用。</p><p>第五十四  用人单位必须为劳动者提供符合国家规定的劳动安全卫生条件和必要的劳动防护用品，对从事有职业危害作业的劳动者应当定期进行健康检查。</p><p>第五十五  从事特种作业的劳动者必须经过专门培训并取得特种作业资格。</p><p>第五十六条 劳动者在劳动过程中必须严格遵守安全操作规程。</p><p>劳动者对用人单位管理人员违章指挥、强令冒险作业，有权拒绝执行；对危害生命安全和身体健康的行为，有权提出批评、检举和控告。</p><p>第五十七  国家建立伤亡事故和职业病统计报告和处理制度。县级以上各级人民政府劳动行政部门、有关部门和用人单位应当依法对劳动者在劳动过程中发生的伤亡事故和劳动者的职业病状况，进行统计、报告和处理。</p><p><span id="7">　</span></p><p><strong>第七章 女职工和未成年工特殊保护</strong></p><p>　</p><p>第五十八条 国家对女职工和未成年工实行特殊劳动保护。</p><p>未成年工是指年满十六周岁未满十八周岁的劳动者。</p><p>第五十九  禁止安排女职工从事矿山井下、国家规定的第四级体力劳动强度的劳动和其他禁忌从事的劳动。</p><p>第六十  不得安排女职工在经期从事高处、低温、冷水作业和国家规定的第三级体力劳动强度的劳动。</p><p>第六十一  不得安排女职工在怀孕期间从事国家规定的第三级体力劳动强度的劳动和孕期禁忌从事的活动。对怀孕七个月以上的女职工，不得安排其延长工作时间和夜班劳动。</p><p>第六十二条 女职工生育享受不少于九十天的产假。</p><p>第六十三  不得安排女职工在哺乳未满一周岁的婴儿期间从事国家规定的第三级体力劳动强度的劳动和哺乳期禁忌从事的其他劳动，不得安排其延长工作时间和夜班劳动。</p><p>第六十四  不得安排未成年工从事矿山井下、有毒有害、国家规定的第四级体力劳动强度的劳动和其他禁忌从事的劳动。</p><p>第六十五条 用人单位应当对未成年工定期进行健康检查。</p><p><span id="8">　</span></p><p><strong>第八章 职业培训</strong></p><p>　</p><p>第六十六  国家通过各种途径，采取各种措施，发展职业培训事业，开发劳动者的职业技能，提高劳动者素质，增强劳动者的就业能力和工作能力。</p><p>第六十七  各级人民政府应当把发展职业培训纳入社会经济发展的规划，鼓励和支持有条件的企业、事业组织、社会团体和个人进行各种形式的职业培训。</p><p>第六十八  用人单位应当建立职业培训制度，按照国家规定提取和使用职业培训经费，根据本单位实际，有计划地对劳动者进行职业培训。</p><p>从事技术工种的劳动者，上岗前必须经过培训。</p><p>第六十九  国家确定职业分类，对规定的职业制定职业技能标准，实行职业资格证书制度，由经过政府批准的考核鉴定机构负责对劳动者实施职业技能考核鉴定。</p><p><span id="9">　</span></p><p><strong>第九章 社会保险和福利</strong></p><p>　</p><p>第七十  国家发展社会保险事业，建立社会保险制度，设立社会保险基金，使劳动者在年老、患病、工伤、失业、生育等情况下获得帮助和补偿。</p><p>第七十一  社会保险水平应当与社会经济发展水平和社会承受能力相适应。</p><p>第七十二  社会保险基金按照保险类型确定资金来源，逐步实行社会统筹。用人单位和劳动者必须依法参加社会保险，缴纳社会保险费。</p><p>第七十三条 劳动者在下列情形下，依法享受社会保险待遇：</p><p>（一）退休；</p><p>（二）患病、负伤；</p><p>（三）因工伤残或者患职业病；</p><p>（四）失业；</p><p>（五）生育。</p><p>劳动者死亡后，其遗属依法享受遗属津贴。</p><p>劳动者享受社会保险待遇的条件和标准由法律、法规规定。</p><p>劳动者享受的社会保险金必须按时足额支付。</p><p>第七十四  社会保险基金经办机构依照法律规定收支、管理和运营社会保险基金，并负有使社会保险基金保值增值的责任。</p><p>社会保险基金监督机构依照法律规定，对社会保险基金的收支、管理和运营实施监督。</p><p>社会保险基金经办机构和社会保险基金监督机构的设立和职能由法律规定。</p><p>任何组织和个人不得挪用社会保险基金。</p><p>第七十五  国家鼓励用人单位根据本单位实际情况为劳动者建立补充保险。</p><p>国家提倡劳动者个人进行储蓄性保险。</p><p>第七十六  国家发展社会福利事业，兴建公共福利设施，为劳动者休息、休养和疗养提供条件。</p><p>用人单位应当创造条件，改善集体福利，提高劳动者的福利待遇。</p><p><span id="10">　</span></p><p><strong>第十章 劳动争议</strong></p><p>　</p><p>第七十七  用人单位与劳动者发生劳动争议，当事人可以依法申请调解、仲裁、提起诉讼，也可以协商解决。</p><p>调解原则适用于仲裁和诉讼程序。</p><p>第七十八  解决劳动争议，应当根据合法、公正、及时处理的原则，依法维护劳动争议当事人的合法权益。</p><p>第七十九  劳动争议发生后，当事人可以向本单位劳动争议调解委员会申请调解；调解不成，当事人一方要求仲裁的，可以向劳动争议仲裁委员会申请仲裁。当事人一方也可以直接向劳动争议仲裁委员会申请仲裁。对仲裁裁决不服的，可以向人民法院提起诉讼。</p><p>第八十  在用人单位内，可以设立劳动争议调解委员会。劳动争议调解委员会由职工代表、用人单位代表和工会代表组成。劳动争议调解委员会主任由工会代表担任。</p><p>劳动争议经调解达成协议的，当事人应当履行。</p><p>第八十一  劳动争议仲裁委员会由劳动行政部门代表、同级工会代表、用人单位方面的代表组成。劳动争议仲裁委员会主任由劳动行政部门代表担任。</p><p>第八十二  提出仲裁要求的一方应当自劳动争议发生之日起六十日内向劳动争议仲裁委员会提出书面申请。仲裁裁决一般应在收到仲裁申请的六十日内作出。对仲裁裁决无异议的，当事人必须履行。</p><p>第八十三  劳动争议当事人对仲裁裁决不服的，可以自收到仲裁裁决书之日起十五日内向人民法院提起诉讼。一方当事人在法定期限内不起诉又不履行仲裁裁决的，另一方当事人可以申请人民法院强制执行。</p><p>第八十四  因签订集体合同发生争议，当事人协商解决不成的，当地人民政府劳动行政部门可以组织有关各方协调处理。</p><p>因履行集体合同发生争议，当事人协商解决不成的，可以向劳动争议仲裁委员会申请仲裁；对仲裁裁决不服的，可以自收到仲裁裁决书之日起十五日内向人民法院提起诉讼。</p><p><span id="11">　</span></p><p><strong>第十一章 监督检查</strong></p><p>第八十五  县级以上各级人民政府劳动行政部门依法对用人单位遵守劳动法律、法规的情况进行监督检查，对违反劳动法律、法规的行为有权制止，并责令改正。</p><p>第八十六  县级以上各级人民政府劳动行政部门监督检查人员执行公务，有权进入用人单位了解执行劳动法律、法规的情况，查阅必要的资料，并对劳动场所进行检查。</p><p>县级以上各级人民政府劳动行政部门监督检查人员执行公务，必须出示证件，秉公执法并遵守有关规定。</p><p>第八十七  县级以上各级人民政府有关部门在各自职责范围内，对用人单位遵守劳动法律、法规的情况进行监督。</p><p>第八十八  各级工会依法维护劳动者的合法权益，对用人单位遵守劳动法律、法规的情况进行监督。</p><p>任何组织和个人对于违反劳动法律、法规的行为有权检举和控告。</p><p><span id="12">　</span></p><p><strong>第十二章 法律责任</strong></p><p>　</p><p>第八十九  用人单位制定的劳动规章制度违反法律、法规规定的，由劳动行政部门给予警告，责令改正；对劳动者造成损害的，应当承担赔偿责任。</p><p>第九十  用人单位违反本法规定，延长劳动者工作时间的，由劳动行政部门给予警告，责令改正，并可以处以罚款。</p><p>第九十一  用人单位有下列侵害劳动者合法权益情形之一的，由劳动行政部门责令支付劳动者的工资报酬、经济补偿，并可以责令支付赔偿金：</p><p>（一）克扣或者无故拖欠劳动者工资的；</p><p>（二）拒不支付劳动者延长工作时间工资报酬的；</p><p>（三）低于当地最低工资标准支付劳动者工资的；</p><p>（四）解除劳动合同后，未依照本法规定给予劳动者经济补偿的。</p><p>第九十二  用人单位的劳动安全设施和劳动卫生条件不符合国家规定或者未向劳动者提供必要的劳动防护用品和劳动保护设施的，由劳动行政部门或者有关部门责令改正，可以处以罚款；情节严重的，提请县级以上人民政府决定责令停产整顿；对事故隐患不采取措施，致使发生重大事故，造成劳动者生命和财产损失的，对责任人员比照刑法第一百八十七条的规定追究刑事责任。</p><p>第九十三  用人单位强令劳动者违章冒险作业，发生重大伤亡事故，造成严重后果的，对责任人员依法追究刑事责任。</p><p>第九十四  用人单位非法招用未满十六周岁的未成年人的，由劳动行政部门责令改正，处以罚款；情节严重的，由工商行政管理部门吊销营业执照。</p><p>第九十五  用人单位违反本法对女职工和未成年工的保护规定，侵害其合法权益的，由劳动行政部门责令改正，处以罚款；对女职工或者未成年工造成损害的，应当承担赔偿责任。</p><p>第九十六  用人单位有下列行为之一，由公安机关对责任人员处以十五日以下拘留、罚款或者警告；构成犯罪的，对责任人员依法追究刑事责任：</p><p>（一）以暴力、威胁或者非法限制人身自由的手段强迫劳动的；</p><p>（二）侮辱、体罚、殴打、非法搜查和拘禁劳动者的。</p><p>第九十七  由于用人单位的原因订立的无效合同，对劳动者造成损害的，应当承担赔偿责任。</p><p>第九十八  用人单位违反本法规定的条件解除劳动合同或者故意拖延不订立劳动合同的，由劳动行政部门责令改正；对劳动者造成损害的，应当承担赔偿责任。</p><p>第九十九  用人单位招用尚未解除劳动合同的劳动者，对原用人单位造成经济损失的，该用人单位应当依法承担连带赔偿责任。</p><p>第一百  用人单位无故不缴纳社会保险费的，由劳动行政部门责令其限期缴纳；逾期不缴的，可以加收滞纳金。</p><p>第一百零一  用人单位无理阻挠劳动行政部门、有关部门及其工作人员行使监督检查权，打击报复举报人员的，由劳动行政部门或者有关部门处以罚款；构成犯罪的，对责任人员依法追究刑事责任。</p><p>第一百零二  劳动者违反本法规定的条件解除劳动合同或者违反劳动合同中约定的保密事项，对用人单位造成经济损失的，应当依法承担赔偿责任。</p><p>第一百零三  劳动行政部门或者有关部门的工作人员滥用职权、玩忽职守、徇私舞弊，构成犯罪的，依法追究刑事责任；不构成犯罪的，给予行政处分。</p><p>第一百零四  国家工作人员和社会保险基金经办机构的工作人员挪用社会保险基金，构成犯罪的，依法追究刑事责任。</p><p>第一百零五  违反本法规定侵害劳动者合法权益，其他法律、行政法规已规定处罚的，依照该法律、行政法规的规定处罚。</p><p><span id="13">　</span></p><p><strong>第十三章 附则</strong></p><p>　</p><p>第一百零六  省、自治区、直辖市人民政府根据本法和本地区的实际情况，规定劳动合同制度的实施步骤，报国务院备案。</p><p>第一百零七条 本法自１９９５年１月１日起施行</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《中华人民共和国劳动法》已由中华人民共和国第八届全国人民代表大会常务委员会第八次会议于１９９４年７月５日通过，现予公布，自１９９５年１月１日起施行。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="法律" scheme="https://removeif.github.io/categories/%E6%B3%95%E5%BE%8B/"/>
    
    
      <category term="法律" scheme="https://removeif.github.io/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>中华人民共和国婚姻法</title>
    <link href="https://removeif.github.io/2019/08/21/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%A9%9A%E5%A7%BB%E6%B3%95.html"/>
    <id>https://removeif.github.io/2019/08/21/中华人民共和国婚姻法.html</id>
    <published>2019-08-21T09:43:54.000Z</published>
    <updated>2019-08-30T13:03:59.404Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基本信息</p></blockquote><p>效力级别法律：时效性现行有效</p><p>发布日期：2001-04-28</p><p>实施日期：2001-04-28</p><p>发布机关：全国人大常委会<br><a id="more"></a></p><blockquote><p>法律修订</p></blockquote><p>１９８０年９月１０日第五届全国人民代表大会第三次会议通过</p><p>根据２００１年４月２８日第九届全国人民代表大会常务委员会第二十一次会议《关于修改〈中华人民共和国婚姻法〉的决定》修正</p><p><a href="https://duxiaofa.baidu.com/detail?cid=68f8580d4055743e96cf7d5064727256_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国婚姻法（1980修正）</a></p><p><a href="https://duxiaofa.baidu.com/detail?cid=9bfe53bb510dcd68a02c029109aec898_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国婚姻法（1950修正）</a></p><blockquote><p>正文</p></blockquote><h4 id="第一章-总则"><a href="#第一章-总则" class="headerlink" title="第一章　总则"></a>第一章　总则</h4><p><strong>第一条 立法目的</strong></p><p>本法是婚姻家庭关系的基本准则。</p><p><strong>第二条 婚姻制度</strong></p><p>实行婚姻自由、一夫一妻、男女平等的婚姻制度。 保护妇女、儿童和老人的合法权益。 实行计划生育。</p><p><strong>第三条 禁止的婚姻行为</strong></p><p>禁止包办、买卖婚姻和其他干涉婚姻自由的行为。禁止借婚姻索取财物。 禁止重婚。禁止有配偶者与他人同居。禁止家庭暴力。禁止家庭成员间的虐待和遗弃。</p><p><strong>第四条 家庭关系</strong></p><p>夫妻应当互相忠实，互相尊重；家庭成员间应当敬老爱幼，互相帮助，维护平等、和睦、文明的婚姻家庭关系。</p><h4 id="第二章-结婚"><a href="#第二章-结婚" class="headerlink" title="第二章　结婚"></a>第二章　结婚</h4><p><strong>第五条 结婚自愿</strong></p><p>结婚必须男女双方完全自愿，不许任何一方对他方加以强迫或任何第三者加以干涉。</p><p><strong>第六条 法定婚龄</strong></p><p>结婚年龄，男不得早于二十二周岁，女不得早于二十周岁。晚婚晚育应予鼓励。</p><p><strong>第七条 禁止结婚</strong></p><p>有下列情形之一的，禁止结婚： （一）直系血亲和三代以内的旁系血亲； （二）患有医学上认为不应当结婚的疾病。</p><p><strong>第八条 结婚登记</strong></p><p>要求结婚的男女双方必须亲自到婚姻登记机关进行结婚登记。符合本法规定的，予以登记，发给结婚证。取得结婚证，即确立夫妻关系。未办理结婚登记的，应当补办登记。</p><p><strong>第九条 互为家庭成员</strong></p><p>登记结婚后，根据男女双方约定，女方可以成为男方家庭的成员，男方可以成为女方家庭的成员。</p><p><strong>第十条 婚姻无效</strong></p><p>有下列情形之一的，婚姻无效： （一）重婚的； （二）有禁止结婚的亲属关系的； （三）婚前患有医学上认为不应当结婚的疾病，婚后尚未治愈的； （四）未到法定婚龄的。</p><p><strong>第十一条 胁迫结婚</strong></p><p>因胁迫结婚的，受胁迫的一方可以向婚姻登记机关或人民法院请求撤销该婚姻。受胁迫的一方撤销婚姻的请求，应当自结婚登记之日起一年内提出。被非法限制人身自由的当事人请求撤销婚姻的，应当自恢复人身自由之日起一年内提出。</p><p><strong>第十二条 婚姻的无效</strong></p><p>无效或被撤销的婚姻，自始无效。当事人不具有夫妻的权利和义务。同居期间所得的财产，由当事人协议处理；协议不成时，由人民法院根据照顾无过错方的原则判决。对重婚导致的婚姻无效的财产处理，不得侵害合法婚姻当事人的财产权益。当事人所生的子女，适用本法有关父母子女的规定。</p><h4 id="第三章-家庭关系"><a href="#第三章-家庭关系" class="headerlink" title="第三章　家庭关系"></a>第三章　家庭关系</h4><p><strong>第十三条 夫妻平等</strong></p><p>夫妻在家庭中地位平等。</p><p><strong>第十四条 夫妻姓名权</strong></p><p>夫妻双方都有各用自己姓名的权利。</p><p><strong>第十五条 夫妻的自由</strong></p><p>夫妻双方都有参加生产、工作、学习和社会活动的自由，一方不得对他方加以限制或干涉。</p><p><strong>第十六条 计划生育义务</strong></p><p>夫妻双方都有实行计划生育的义务。</p><p><strong>第十七条 夫妻共有财产</strong></p><p>夫妻在婚姻关系存续期间所得的下列财产，归夫妻共同所有： （一）工资、奖金； （二）生产、经营的收益； （三）知识产权的收益； （四）继承或赠与所得的财产，但本法第十八条第三项规定的除外； （五）其他应当归共同所有的财产。 夫妻对共同所有的财产，有平等的处理权。</p><p><strong>第十八条 夫妻一方的财产</strong></p><p>有下列情形之一的，为夫妻一方的财产： （一）一方的婚前财产； （二）一方因身体受到伤害获得的医疗费、残疾人生活补助费等费用； （三）遗嘱或赠与合同中确定只归夫或妻一方的财产； （四）一方专用的生活用品； （五）其他应当归一方的财产。</p><p><strong>第十九条 夫妻财产约定</strong></p><p>夫妻可以约定婚姻关系存续期间所得的财产以及婚前财产归各自所有、共同所有或部分各自所有、部分共同所有。约定应当采用书面形式。没有约定或约定不明确的，适用本法第十七条、第十八条的规定。 夫妻对婚姻关系存续期间所得的财产以及婚前财产的约定，对双方具有约束力。 夫妻对婚姻关系存续期间所得的财产约定归各自所有的，夫或妻一方对外所负的债务，第三人知道该约定的，以夫或妻一方所有的财产清偿。</p><p><strong>第二十条 夫妻扶养义务</strong></p><p>夫妻有互相扶养的义务。 一方不履行扶养义务时，需要扶养的一方，有要求对方付给扶养费的权利。</p><p><strong>第二十一条 父母与子女</strong></p><p>父母对子女有抚养教育的义务；子女对父母有赡养扶助的义务。 父母不履行抚养义务时，未成年的或不能独立生活的子女，有要求父母付给抚养费的权利。 子女不履行赡养义务时，无劳动能力的或生活困难的父母，有要求子女付给赡养费的权利。 禁止溺婴、弃婴和其他残害婴儿的行为。</p><p><strong>第二十二条 子女的姓</strong></p><p>子女可以随父姓，可以随母姓。</p><p><strong>第二十三条 父母对子女的保护和教育</strong></p><p>父母有保护和教育未成年子女的权利和义务。在未成年子女对国家、集体或他人造成损害时，父母有承担民事责任的义务。</p><p><strong>第二十四条 继承遗产</strong></p><p>夫妻有相互继承遗产的权利。 父母和子女有相互继承遗产的权利。</p><p><strong>第二十五条 非婚生子女</strong></p><p>非婚生子女享有与婚生子女同等的权利，任何人不得加以危害和歧视。 不直接抚养非婚生子女的生父或生母，应当负担子女的生活费和教育费，直至子女能独立生活为止。</p><p><strong>第二十六条 收养关系</strong></p><p>国家保护合法的收养关系。养父母和养子女间的权利和义务，适用本法对父母子女关系的有关规定。 养子女和生父母间的权利和义务，因收养关系的成立而消除。</p><p><strong>第二十七条 继父母与继子女</strong></p><p>继父母与继子女间，不得虐待或歧视。 继父或继母和受其抚养教育的继子女间的权利和义务，适用本法对父母子女关系的有关规定。</p><p><strong>第二十八条 祖与孙</strong></p><p>有负担能力的祖父母、外祖父母，对于父母已经死亡或父母无力抚养的未成年的孙子女、外孙子女，有抚养的义务。有负担能力的孙子女、外孙子女，对于子女已经死亡或子女无力赡养的祖父母、外祖父母，有赡养的义务。</p><p>第二十九条 兄姐与弟妹</p><p>有负担能力的兄、姐，对于父母已经死亡或父母无力抚养的未成年的弟、妹，有扶养的义务。由兄、姐扶养长大的有负担能力的弟、妹，对于缺乏劳动能力又缺乏生活来源的兄、姐，有扶养的义务。</p><p><strong>第三十条 尊重父母婚姻</strong></p><p>子女应当尊重父母的婚姻权利，不得干涉父母再婚以及婚后的生活。子女对父母的赡养义务，不因父母的婚姻关系变化而终止。</p><h4 id="第四章-离婚"><a href="#第四章-离婚" class="headerlink" title="第四章　离婚"></a>第四章　离婚</h4><p><strong>第三十一条 自愿离婚</strong></p><p>男女双方自愿离婚的，准予离婚。双方必须到婚姻登记机关申请离婚。婚姻登记机关查明双方确实是自愿并对子女和财产问题已有适当处理时，发给离婚证。</p><p><strong>第三十二条 离婚诉讼</strong></p><p>男女一方要求离婚的，可由有关部门进行调解或直接向人民法院提出离婚诉讼。 人民法院审理离婚案件，应当进行调解；如感情确已破裂，调解无效，应准予离婚。 有下列情形之一，调解无效的，应准予离婚： （一）重婚或有配偶者与他人同居的； （二）实施家庭暴力或虐待、遗弃家庭成员的； （三）有赌博、吸毒等恶习屡教不改的； （四）因感情不和分居满二年的； （五）其他导致夫妻感情破裂的情形。 一方被宣告失踪，另一方提出离婚诉讼的，应准予离婚。</p><p><strong>第三十三条 军人配偶要求离婚</strong></p><p>现役军人的配偶要求离婚，须得军人同意，但军人一方有重大过错的除外。</p><p><strong>第三十四条 不得提出离婚</strong></p><p>女方在怀孕期间、分娩后一年内或中止妊娠后六个月内，男方不得提出离婚。女方提出离婚的，或人民法院认为确有必要受理男方离婚请求的，不在此限。</p><p><strong>第三十五条 复婚</strong></p><p>离婚后，男女双方自愿恢复夫妻关系的，必须到婚姻登记机关进行复婚登记。</p><p><strong>第三十六条 离婚与子女</strong></p><p>父母与子女间的关系，不因父母离婚而消除。离婚后，子女无论由父或母直接抚养，仍是父母双方的子女。 离婚后，父母对于子女仍有抚养和教育的权利和义务。 离婚后，哺乳期内的子女，以随哺乳的母亲抚养为原则。哺乳期后的子女，如双方因抚养问题发生争执不能达成协议时，由人民法院根据子女的权益和双方的具体情况判决。</p><p><strong>第三十七条 离婚后的子女抚养</strong></p><p>离婚后，一方抚养的子女，另一方应负担必要的生活费和教育费的一部或全部，负担费用的多少和期限的长短，由双方协议；协议不成时，由人民法院判决。 关于子女生活费和教育费的协议或判决，不妨碍子女在必要时向父母任何一方提出超过协议或判决原定数额的合理要求。</p><p><strong>第三十八条 离婚后的子女探望</strong></p><p>离婚后，不直接抚养子女的父或母，有探望子女的权利，另一方有协助的义务。 行使探望权利的方式、时间由当事人协议；协议不成时，由人民法院判决。 父或母探望子女，不利于子女身心健康的，由人民法院依法中止探望的权利；中止的事由消失后，应当恢复探望的权利。</p><p><strong>第三十九条 夫妻共同财产的离婚处理</strong></p><p>离婚时，夫妻的共同财产由双方协议处理；协议不成时，由人民法院根据财产的具体情况，照顾子女和女方权益的原则判决。 夫或妻在家庭土地承包经营中享有的权益等，应当依法予以保护。</p><p><strong>第四十条 补偿</strong></p><p>夫妻书面约定婚姻关系存续期间所得的财产归各自所有，一方因抚育子女、照料老人、协助另一方工作等付出较多义务的，离婚时有权向另一方请求补偿，另一方应当予以补偿。</p><p><strong>第四十一条 共同债务</strong></p><p>离婚时，原为夫妻共同生活所负的债务，应当共同偿还。共同财产不足清偿的，或财产归各自所有的，由双方协议清偿；协议不成时，由人民法院判决。</p><p><strong>第四十二条 适当帮助</strong></p><p>离婚时，如一方生活困难，另一方应从其住房等个人财产中给予适当帮助。具体办法由双方协议；协议不成时，由人民法院判决。</p><h4 id="第五章-救助措施与法律责任"><a href="#第五章-救助措施与法律责任" class="headerlink" title="第五章　救助措施与法律责任"></a>第五章　救助措施与法律责任</h4><p><strong>第四十三条 家庭暴力与虐待</strong></p><p>实施家庭暴力或虐待家庭成员，受害人有权提出请求，居民委员会、村民委员会以及所在单位应当予以劝阻、调解。 对正在实施的家庭暴力，受害人有权提出请求，居民委员会、村民委员会应当予以劝阻；公安机关应当予以制止。 实施家庭暴力或虐待家庭成员，受害人提出请求的，公安机关应当依照治安管理处罚的法律规定予以行政处罚。</p><p><strong>第四十四条 遗弃</strong></p><p>对遗弃家庭成员，受害人有权提出请求，居民委员会、村民委员会以及所在单位应当予以劝阻、调解。 对遗弃家庭成员，受害人提出请求的，人民法院应当依法作出支付扶养费、抚养费、赡养费的判决。</p><p><strong>第四十五条 家庭暴力、虐待、遗弃犯罪</strong></p><p>对重婚的，对实施家庭暴力或虐待、遗弃家庭成员构成犯罪的，依法追究刑事责任。受害人可以依照刑事诉讼法的有关规定，向人民法院自诉；公安机关应当依法侦查，人民检察院应当依法提起公诉。</p><p><strong>第四十六条 损害赔偿</strong></p><p>有下列情形之一，导致离婚的，无过错方有权请求损害赔偿： （一）重婚的； （二）有配偶者与他人同居的； （三）实施家庭暴力的； （四）虐待、遗弃家庭成员的。</p><p><strong>第四十七条 隐藏、转移共同财产等</strong></p><p>离婚时，一方隐藏、转移、变卖、毁损夫妻共同财产，或伪造债务企图侵占另一方财产的，分割夫妻共同财产时，对隐藏、转移、变卖、毁损夫妻共同财产或伪造债务的一方，可以少分或不分。离婚后，另一方发现有上述行为的，可以向人民法院提起诉讼，请求再次分割夫妻共同财产。 人民法院对前款规定的妨害民事诉讼的行为，依照民事诉讼法的规定予以制裁。</p><p><strong>第四十八条 强制执行</strong></p><p>对拒不执行有关扶养费、抚养费、赡养费、财产分割、遗产继承、探望子女等判决或裁定的，由人民法院依法强制执行。有关个人和单位应负协助执行的责任。</p><p><strong>第四十九条 婚姻家庭的其他违法</strong></p><p>其他法律对有关婚姻家庭的违法行为和法律责任另有规定的，依照其规定。</p><h4 id="第六章-附则"><a href="#第六章-附则" class="headerlink" title="第六章　附则"></a>第六章　附则</h4><p><strong>第五十条 变通规定</strong></p><p>民族自治地方的人民代表大会有权结合当地民族婚姻家庭的具体情况，制定变通规定。自治州、自治县制定的变通规定，报省、自治区、直辖市人民代表大会常务委员会批准后生效。自治区制定的变通规定，报全国人民代表大会常务委员会批准后生效。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基本信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效力级别法律：时效性现行有效&lt;/p&gt;
&lt;p&gt;发布日期：2001-04-28&lt;/p&gt;
&lt;p&gt;实施日期：2001-04-28&lt;/p&gt;
&lt;p&gt;发布机关：全国人大常委会&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="法律" scheme="https://removeif.github.io/categories/%E6%B3%95%E5%BE%8B/"/>
    
    
      <category term="法律" scheme="https://removeif.github.io/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>mysql高性能优化规范方法</title>
    <link href="https://removeif.github.io/2019/08/21/mysql%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E6%96%B9%E6%B3%95.html"/>
    <id>https://removeif.github.io/2019/08/21/mysql高性能优化规范方法.html</id>
    <published>2019-08-21T09:07:50.000Z</published>
    <updated>2019-08-21T09:27:11.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库命令规范"><a href="#数据库命令规范" class="headerlink" title="数据库命令规范"></a>数据库命令规范</h2><ul><li>所有数据库对象名称必须使用<strong>小写字母并用下划线</strong>分割</li><li>所有数据库对象名称<strong>禁止</strong>使用mysql<strong>保留关键字</strong>（如果表名中包含关键字查询时，需要将其用单引号括起来）</li><li>数据库对象的命名要能做到<strong>见名识意</strong>，并且最后<strong>不要超过32个字符</strong></li><li><strong>临时库表必须以tmp_</strong>为前缀并以日期为后缀，<strong>备份表必须以bak_</strong>为前缀并以日期(时间戳)为后缀</li><li>所有存储<strong>相同数据的列名和列类型必须一致</strong>（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）<a id="more"></a></li></ul><h2 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h2><h3 id="所有表必须使用Innodb存储引擎"><a href="#所有表必须使用Innodb存储引擎" class="headerlink" title="所有表必须使用Innodb存储引擎"></a>所有表必须使用Innodb存储引擎</h3><p>没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，<strong>5.6以后默认的为Innodb</strong>）。</p><p>Innodb 支持<strong>事务</strong>，支持行<strong>级锁</strong>，更好的恢复性，<strong>高并发</strong>下性能更好。</p><h3 id="数据库和表的字符集统一使用UTF8"><a href="#数据库和表的字符集统一使用UTF8" class="headerlink" title="数据库和表的字符集统一使用UTF8"></a>数据库和表的字符集统一使用UTF8</h3><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储<strong>emoji</strong>表情的需要，字符集需要采用<strong>utf8mb4</strong>字符集。</p><h3 id="所有表和字段都需要添加注释"><a href="#所有表和字段都需要添加注释" class="headerlink" title="所有表和字段都需要添加注释"></a>所有表和字段都需要添加注释</h3><p>使用<strong>comment</strong>从句添加表和列的备注，从一开始就进行数据字典的维护</p><h3 id="尽量控制单表数据量的大小，建议控制在500万以内。"><a href="#尽量控制单表数据量的大小，建议控制在500万以内。" class="headerlink" title="尽量控制单表数据量的大小，建议控制在500万以内。"></a>尽量控制单表数据量的大小，建议控制在500万以内。</h3><p><strong>500万</strong>并不是Mysql数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p><p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p><h3 id="谨慎使用Mysql分区表"><a href="#谨慎使用Mysql分区表" class="headerlink" title="谨慎使用Mysql分区表"></a>谨慎使用Mysql分区表</h3><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p><p>谨慎选择分区键，<strong>跨分区查询效率</strong>可能更<strong>低</strong>；</p><p>建议采用<strong>物理分表</strong>的方式管理大数据。</p><h3 id="尽量做到冷热数据分离，减小表的宽度"><a href="#尽量做到冷热数据分离，减小表的宽度" class="headerlink" title="尽量做到冷热数据分离，减小表的宽度"></a>尽量做到冷热数据分离，减小表的宽度</h3><p>Mysql限制每个表最多存储<strong>4096列</strong>，并且<strong>每一行数据</strong>的大小不能超过<strong>65535</strong>字节。</p><p>减少<strong>磁盘IO</strong>,保证热数据的内存缓存命中率（表越宽，把<strong>表装载进内存缓冲池时所占用</strong>的内存也就越<strong>大</strong>,也会消耗更多的IO）；</p><p>更有效的利用缓存，避免读入无用的冷数据；</p><p>经常一起使用的列放到一个表中（避免更多的关联操作）。</p><h3 id="禁止在表中建立预留字段"><a href="#禁止在表中建立预留字段" class="headerlink" title="禁止在表中建立预留字段"></a>禁止在表中建立预留字段</h3><p>预留字段的命名很难做到见名识义。</p><p>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</p><p>对预留字段类型的修改，会对表进行锁定。</p><h3 id="禁止在数据库中存储图片，文件等大的二进制数据"><a href="#禁止在数据库中存储图片，文件等大的二进制数据" class="headerlink" title="禁止在数据库中存储图片，文件等大的二进制数据"></a>禁止在数据库中存储图片，文件等大的二进制数据</h3><p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。</p><p>通常存储于文件服务器，数据库只存储<strong>文件地址信息</strong></p><h3 id="禁止在线上做数据库压力测试"><a href="#禁止在线上做数据库压力测试" class="headerlink" title="禁止在线上做数据库压力测试"></a>禁止在线上做数据库压力测试</h3><h3 id="禁止从开发环境，测试环境直接连接生产环境数据库"><a href="#禁止从开发环境，测试环境直接连接生产环境数据库" class="headerlink" title="禁止从开发环境，测试环境直接连接生产环境数据库"></a>禁止从开发环境，测试环境直接连接生产环境数据库</h3><hr><h2 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h2><h3 id="优先选择符合存储需要的最小的数据类型"><a href="#优先选择符合存储需要的最小的数据类型" class="headerlink" title="优先选择符合存储需要的最小的数据类型"></a>优先选择符合存储需要的最小的数据类型</h3><p><strong>原因：</strong></p><p>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的<strong>IO次数</strong>也就越多，索引的性能也就越差。</p><p><strong>方法：</strong></p><h4 id="将字符串转换成数字类型存储，如：将IP地址转换成整形数据"><a href="#将字符串转换成数字类型存储，如：将IP地址转换成整形数据" class="headerlink" title="将字符串转换成数字类型存储，如：将IP地址转换成整形数据"></a>将字符串转换成数字类型存储，如：将IP地址转换成整形数据</h4><p>mysql提供了两个方法来处理ip地址</p><ul><li><strong>inet_aton</strong> 把ip转为无符号整型(4-8位)</li><li><strong>inet_ntoa</strong> 把整型的ip转为地址</li></ul><p>插入数据前，先用inet_aton把ip地址转为整型，可以节省空间，显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可。</p><h4 id="对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储"><a href="#对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储" class="headerlink" title="对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储"></a>对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储</h4><p><strong>原因：</strong></p><p>无符号相对于有符号可以多出一倍的存储空间</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SIGNED INT -2147483648~2147483647</span><br><span class="line">UNSIGNED INT 0~4294967295</span><br></pre></td></tr></table></figure><p><strong>VARCHAR(N)</strong>中的N代表的是<strong>字符数</strong>，而<strong>不是字节数</strong>，使用UTF8存储255个汉字 Varchar(255)=765个字节。<strong>过大的长度会消耗更多的内存。</strong></p><h3 id="避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据"><a href="#避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据" class="headerlink" title="避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据"></a>避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据</h3><h4 id="建议把BLOB或是TEXT列分离到单独的扩展表中"><a href="#建议把BLOB或是TEXT列分离到单独的扩展表中" class="headerlink" title="建议把BLOB或是TEXT列分离到单独的扩展表中"></a><strong>建议把BLOB或是TEXT列分离到单独的扩展表中</strong></h4><p>Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。</p><p>如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。</p><h4 id="TEXT或BLOB类型只能使用前缀索引"><a href="#TEXT或BLOB类型只能使用前缀索引" class="headerlink" title="TEXT或BLOB类型只能使用前缀索引"></a><strong>TEXT或BLOB类型只能使用前缀索引</strong></h4><p>因为<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247487885&amp;idx=1&amp;sn=65b1bf5f7d4505502620179669a9c2df&amp;chksm=ebd62ea1dca1a7b7bf884bcd9d538d78ba064ee03c09436ca8e57873b1d98a55afd6d7884cfc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">MySQL</a>对索引字段长度是有限制的，所以<strong>TEXT类型</strong>只能使用<strong>前缀索引</strong>，并且<strong>TEXT列上是不能有默认值</strong>的</p><h3 id="避免使用ENUM类型"><a href="#避免使用ENUM类型" class="headerlink" title="避免使用ENUM类型"></a>避免使用ENUM类型</h3><p>修改ENUM值需要使用ALTER语句</p><p><strong>ENUM类型的ORDER BY操作效率低</strong>，需要额外操作</p><p>禁止使用数值作为ENUM的枚举值</p><h3 id="尽可能把所有列定义为NOT-NULL"><a href="#尽可能把所有列定义为NOT-NULL" class="headerlink" title="尽可能把所有列定义为NOT NULL"></a>尽可能把所有列定义为NOT NULL</h3><p><strong>原因：</strong></p><p>索引<strong>NULL列需要额外的空间</strong>来保存，所以要占用更多的空间</p><p>进行比较和计算时要对NULL值做特别的处理</p><h3 id="使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间"><a href="#使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间" class="headerlink" title="使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间"></a>使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间</h3><p>TIMESTAMP 存储的时间范围 <strong>1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</strong></p><p><strong>TIMESTAMP</strong> 占用<strong>4字节和INT相同</strong>，但比INT可读性高</p><p>超出TIMESTAMP取值范围的使用DATETIME类型存储</p><p><strong>经常会有人用字符串存储日期型的数据（不正确的做法）</strong></p><ul><li>缺点1：无法用日期函数进行计算和比较</li><li>缺点2：用字符串存储日期要占用更多的空间</li></ul><h3 id="同财务相关的金额类数据必须使用decimal类型"><a href="#同财务相关的金额类数据必须使用decimal类型" class="headerlink" title="同财务相关的金额类数据必须使用decimal类型"></a>同财务相关的金额类数据必须使用decimal类型</h3><ul><li>非精准浮点：float,double</li><li>精准浮点：decimal</li></ul><p>Decimal类型为精准浮点数，在计算时不会丢失精度</p><p>占用空间由定义的宽度决定，每<strong>4个字节可以存储9位数字</strong>，并且<strong>小数点要占用一个字节</strong></p><p>可用于存储<strong>比bigint更大</strong>的<strong>整型数据</strong></p><hr><h2 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h2><h3 id="限制每张表上的索引数量，建议单张表索引不超过5个"><a href="#限制每张表上的索引数量，建议单张表索引不超过5个" class="headerlink" title="限制每张表上的索引数量，建议单张表索引不超过5个"></a>限制每张表上的索引数量，建议单张表索引不超过5个</h3><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p><p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p><p>因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能。</p><h3 id="禁止给表中的每一列都建立单独的索引"><a href="#禁止给表中的每一列都建立单独的索引" class="headerlink" title="禁止给表中的每一列都建立单独的索引"></a>禁止给表中的每一列都建立单独的索引</h3><p>5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p><h3 id="每个Innodb表必须有个主键"><a href="#每个Innodb表必须有个主键" class="headerlink" title="每个Innodb表必须有个主键"></a>每个Innodb表必须有个主键</h3><p>Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p><p>Innodb是按照主键索引的顺序来组织表的</p><ul><li><strong>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</strong></li><li><strong>不要使用UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</strong></li><li><strong>主键建议使用自增ID值</strong></li></ul><hr><h2 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="常见索引列建议"></a>常见索引列建议</h2><ul><li>出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列</li><li>包含在ORDER BY、GROUP BY、DISTINCT中的字段</li><li>并不要将符合1和2中的字段的列都建立一个索引， 通常将1、2中的字段建立联合索引效果更好</li><li>多表join的关联列</li></ul><hr><h2 id="如何选择索引列的顺序"><a href="#如何选择索引列的顺序" class="headerlink" title="如何选择索引列的顺序"></a>如何选择索引列的顺序</h2><p>建立<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247485618&amp;idx=1&amp;sn=ed892f572b81e6aa6a7be5c43c2e7351&amp;chksm=ebd6379edca1be88f7d3703db31115ced7c5cacd814b684731d6bc1f66f547f341b6c6451da4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">索引</a>的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p><ul><li><strong>区分度最高</strong>的放在联合索引的<strong>最左侧</strong>（区分度=列中不同值的数量/列的总行数）</li><li>尽量把<strong>字段长度小</strong>的列放在联合索引的<strong>最左侧</strong>（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）</li><li>使用最<strong>频繁的列</strong>放到联合索引的左侧（这样可以比较少的建立一些索引）</li></ul><hr><h2 id="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"></a>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h2><ul><li>重复索引示例：primary key(id)、index(id)、unique index(id)</li><li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li></ul><hr><h2 id="对于频繁的查询优先考虑使用覆盖索引"><a href="#对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="对于频繁的查询优先考虑使用覆盖索引"></a>对于频繁的查询优先考虑使用覆盖索引</h2><p>覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引</p><p><strong>覆盖索引的好处：</strong></p><h4 id="避免Innodb表进行索引的二次查询"><a href="#避免Innodb表进行索引的二次查询" class="headerlink" title="避免Innodb表进行索引的二次查询"></a>避免Innodb表进行索引的二次查询</h4><p>Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。</p><p>而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。</p><h4 id="可以把随机IO变成顺序IO加快查询效率"><a href="#可以把随机IO变成顺序IO加快查询效率" class="headerlink" title="可以把随机IO变成顺序IO加快查询效率"></a>可以把随机IO变成顺序IO加快查询效率</h4><p>由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。</p><hr><h2 id="索引SET规范"><a href="#索引SET规范" class="headerlink" title="索引SET规范"></a>索引SET规范</h2><h3 id="尽量避免使用外键约束"><a href="#尽量避免使用外键约束" class="headerlink" title="尽量避免使用外键约束"></a>尽量避免使用外键约束</h3><ul><li>不建议使用外键约束（foreign key），但一定要在表与表之间的<strong>关联键上</strong>建立索引</li><li>外键可用于保证数据的参照完整性，但建议在业务端实现</li><li>外键会影响父表和子表的写操作从而降低性能</li></ul><hr><h2 id="数据库SQL开发规范"><a href="#数据库SQL开发规范" class="headerlink" title="数据库SQL开发规范"></a>数据库SQL开发规范</h2><h3 id="建议使用预编译语句进行数据库操作"><a href="#建议使用预编译语句进行数据库操作" class="headerlink" title="建议使用预编译语句进行数据库操作"></a>建议使用预编译语句进行数据库操作</h3><p>预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题。</p><p>只传参数，比传递SQL语句更高效。</p><p>相同语句可以一次解析，多次使用，提高处理效率。</p><h3 id="避免数据类型的隐式转换"><a href="#避免数据类型的隐式转换" class="headerlink" title="避免数据类型的隐式转换"></a>避免数据类型的隐式转换</h3><p>隐式转换会导致索引失效如:</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> <span class="hljs-keyword">name</span>,phone <span class="hljs-keyword">from</span> customer <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'111'</span>;</span><br></pre></td></tr></table></figure><h3 id="充分利用表上已经存在的索引s"><a href="#充分利用表上已经存在的索引s" class="headerlink" title="充分利用表上已经存在的索引s"></a>充分利用表上已经存在的索引s</h3><p>避免使用双%号的查询条件。如：<code>a like &#39;%123%&#39;</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p><p>一个SQL只能利用到复合索引中的一列进行范围查询。如：有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到。</p><p>在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧，使用<strong>left join 或 not exists</strong>来优化not in 操作，因为<strong>not in</strong> 也通常会使用<strong>索引失效</strong>。</p><h3 id="数据库设计时，应该要对以后扩展进行考虑"><a href="#数据库设计时，应该要对以后扩展进行考虑" class="headerlink" title="数据库设计时，应该要对以后扩展进行考虑"></a>数据库设计时，应该要对以后扩展进行考虑</h3><h3 id="程序连接不同的数据库使用不同的账号，进制跨库查询"><a href="#程序连接不同的数据库使用不同的账号，进制跨库查询" class="headerlink" title="程序连接不同的数据库使用不同的账号，进制跨库查询"></a>程序连接不同的数据库使用不同的账号，进制跨库查询</h3><ul><li>为数据库迁移和分库分表留出余地</li><li>降低业务耦合度</li><li>避免权限过大而产生的安全风险</li></ul><h3 id="禁止使用SELECT-必须使用SELECT-lt-字段列表-gt-查询"><a href="#禁止使用SELECT-必须使用SELECT-lt-字段列表-gt-查询" class="headerlink" title="禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询"></a>禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询</h3><p><strong>原因：</strong></p><ul><li>消耗更多的CPU和IO以网络带宽资源</li><li>无法使用<strong>覆盖索引</strong></li><li>可<strong>减少表结构变更带来的影响</strong></li></ul><h3 id="禁止使用不含字段列表的INSERT语句"><a href="#禁止使用不含字段列表的INSERT语句" class="headerlink" title="禁止使用不含字段列表的INSERT语句"></a>禁止使用不含字段列表的INSERT语句</h3><p>如：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">values</span> (<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>);</span><br></pre></td></tr></table></figure><p>应使用：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t(c1,c2,c3) <span class="hljs-keyword">values</span> (<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>);</span><br></pre></td></tr></table></figure><h3 id="避免使用子查询，可以把子查询优化为join操作"><a href="#避免使用子查询，可以把子查询优化为join操作" class="headerlink" title="避免使用子查询，可以把子查询优化为join操作"></a>避免使用子查询，可以把子查询优化为join操作</h3><p>通常子查询在in子句中，且b中为简单SQL(<strong>不包含union、group by、order by、limit从句</strong>)时,才可以把子查询转化为关联查询进行优化。</p><p><strong>子查询性能差的原因：</strong></p><p><strong>子查询的结果集无法使用索引</strong>，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><p>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。</p><h3 id="避免使用JOIN关联太多的表"><a href="#避免使用JOIN关联太多的表" class="headerlink" title="避免使用JOIN关联太多的表"></a>避免使用JOIN关联太多的表</h3><p>对于Mysql来说，是存在<strong>关联缓存</strong>的，缓存的大小可以由join_buffer_size参数进行设置。</p><p>在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。</p><p>如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p><p>同时对于关联操作来说，会产生临时表操作，影响查询效率，Mysql最多允许关联61个表，建议不超过5个。</p><h3 id="减少同数据库的交互次数"><a href="#减少同数据库的交互次数" class="headerlink" title="减少同数据库的交互次数"></a>减少同数据库的交互次数</h3><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p><h3 id="对应同一列进行or判断时，使用in代替or"><a href="#对应同一列进行or判断时，使用in代替or" class="headerlink" title="对应同一列进行or判断时，使用in代替or"></a>对应同一列进行or判断时，使用in代替or</h3><p><strong>in 的值不要超过500个</strong>，<strong>in 操作可以更有效的利用索引</strong>，or大多数情况下很少能利用到索引。</p><h3 id="禁止使用order-by-rand-进行随机排序"><a href="#禁止使用order-by-rand-进行随机排序" class="headerlink" title="禁止使用order by rand() 进行随机排序"></a>禁止使用order by rand() 进行随机排序</h3><p><strong>order by rand()</strong>会把表中<strong>所有符合条件</strong>的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的CPU和IO及内存资源。</p><p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p><h3 id="WHERE从句中禁止对列进行函数转换和计算"><a href="#WHERE从句中禁止对列进行函数转换和计算" class="headerlink" title="WHERE从句中禁止对列进行函数转换和计算"></a>WHERE从句中禁止对列进行函数转换和计算</h3><p>对列进行函数转换或计算时会导致无法使用索引</p><p><strong>不推荐：</strong></p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where date(create_time)='20190101'</span><br></pre></td></tr></table></figure><p><strong>推荐：</strong></p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where create_time &gt;= '20190101' and create_time &lt; '20190102'</span><br></pre></td></tr></table></figure><h3 id="在明显不会有重复值时使用UNION-ALL-而不是UNION"><a href="#在明显不会有重复值时使用UNION-ALL-而不是UNION" class="headerlink" title="在明显不会有重复值时使用UNION ALL 而不是UNION"></a>在明显不会有重复值时使用UNION ALL 而不是UNION</h3><ul><li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li><li>UNION ALL 不会再对结果集进行去重操作</li></ul><h3 id="拆分复杂的大SQL为多个小SQL"><a href="#拆分复杂的大SQL为多个小SQL" class="headerlink" title="拆分复杂的大SQL为多个小SQL"></a>拆分复杂的大SQL为多个小SQL</h3><ul><li>大SQL逻辑上比较复杂，需要占用大量CPU进行计算的SQL</li><li>MySQL中，一个SQL只能使用一个CPU进行计算</li><li>SQL拆分后可以通过并行执行来提高处理效率</li></ul><hr><h2 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h2><h3 id="超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作"><a href="#超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作" class="headerlink" title="超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作"></a>超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作</h3><p><strong>大批量操作可能会造成严重的主从延迟</strong></p><p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，<br>而只有当<strong>主库上执行完成后</strong>，才会在其他从库上执行，所以会造成<strong>主库与从库长时间的延迟情况</strong></p><p><strong>binlog日志为row格式时会产生大量的日志</strong></p><p>大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。</p><p><strong>避免产生大事务操作</strong></p><p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响。</p><p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p><h3 id="对于大表使用pt-online-schema-change修改表结构"><a href="#对于大表使用pt-online-schema-change修改表结构" class="headerlink" title="对于大表使用pt-online-schema-change修改表结构"></a>对于大表使用pt-online-schema-change修改表结构</h3><ul><li>避免大表修改产生的主从延迟</li><li>避免在对表字段进行修改时进行锁表</li></ul><p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p><p><strong>pt-online-schema-change</strong>它会首先建立一个<strong>与原表结构相同的新表</strong>，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个DDL操作，分解成多个小的批次进行。</p><h3 id="禁止为程序使用的账号赋予super权限"><a href="#禁止为程序使用的账号赋予super权限" class="headerlink" title="禁止为程序使用的账号赋予super权限"></a>禁止为程序使用的账号赋予super权限</h3><ul><li>当达到最大连接数限制时，还运行1个有super权限的用户连接</li><li>super权限只能留给DBA处理问题的账号使用</li></ul><h3 id="对于程序连接数据库账号，遵循权限最小原则"><a href="#对于程序连接数据库账号，遵循权限最小原则" class="headerlink" title="对于程序连接数据库账号，遵循权限最小原则"></a>对于程序连接数据库账号，遵循权限最小原则</h3><ul><li>程序使用数据库账号只能在一个DB下使用，不准跨库</li><li>程序使用的账号原则上不准有drop权限</li></ul><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&amp;mid=2247486244&amp;idx=1&amp;sn=793d3e4ad3d53a0d0eb99bb472cc8deb&amp;chksm=fb0be1b0cc7c68a60cb975af28b5fe00bdf24c4e379278cf33054f064a69cf924a0e0581c8c3&amp;token=1829091620&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">文章来源</a></p><p>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库命令规范&quot;&gt;&lt;a href=&quot;#数据库命令规范&quot; class=&quot;headerlink&quot; title=&quot;数据库命令规范&quot;&gt;&lt;/a&gt;数据库命令规范&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;所有数据库对象名称必须使用&lt;strong&gt;小写字母并用下划线&lt;/strong&gt;分割&lt;/li&gt;
&lt;li&gt;所有数据库对象名称&lt;strong&gt;禁止&lt;/strong&gt;使用mysql&lt;strong&gt;保留关键字&lt;/strong&gt;（如果表名中包含关键字查询时，需要将其用单引号括起来）&lt;/li&gt;
&lt;li&gt;数据库对象的命名要能做到&lt;strong&gt;见名识意&lt;/strong&gt;，并且最后&lt;strong&gt;不要超过32个字符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;临时库表必须以tmp_&lt;/strong&gt;为前缀并以日期为后缀，&lt;strong&gt;备份表必须以bak_&lt;/strong&gt;为前缀并以日期(时间戳)为后缀&lt;/li&gt;
&lt;li&gt;所有存储&lt;strong&gt;相同数据的列名和列类型必须一致&lt;/strong&gt;（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="mysql" scheme="https://removeif.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java容器集合</title>
    <link href="https://removeif.github.io/2019/08/16/Java%E5%AE%B9%E5%99%A8%E9%9B%86%E5%90%88.html"/>
    <id>https://removeif.github.io/2019/08/16/Java容器集合.html</id>
    <published>2019-08-16T09:41:01.000Z</published>
    <updated>2019-08-16T09:46:10.273Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。<br><a id="more"></a></p></blockquote><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190816172510.png" alt=""></p><h4 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h4><ul><li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li><li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li><li>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</li></ul><h4 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h4><ul><li>ArrayList：基于动态数组实现，支持随机访问。</li><li>Vector：和 ArrayList 类似，但它是线程安全的。</li><li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li></ul><h4 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h4><ul><li>LinkedList：可以用它来实现双向队列。</li><li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190816172618.png" alt=""></p><ul><li>TreeMap：基于红黑树实现。</li><li>HashMap：基于哈希表实现。</li><li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li><li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li></ul><h2 id="容器中的设计模式"><a href="#容器中的设计模式" class="headerlink" title="容器中的设计模式"></a>容器中的设计模式</h2><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190816172707.png" alt=""></p><p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p><p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="hljs-string">"a"</span>);</span><br><span class="line">list.add(<span class="hljs-string">"b"</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@SafeVarargs</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">asList</span><span class="hljs-params">(T... a)</span></span></span><br></pre></td></tr></table></figure><p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;</span><br><span class="line">List list = Arrays.asList(arr);</span><br></pre></td></tr></table></figure><p>也可以使用以下方式调用 asList()：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>如果没有特别说明，以下源码分析基于 JDK 1.8。</p><p>在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。</p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h4><p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span></span><br><span class="line"><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>数组的默认大小为 10。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190816172831.png" alt=""></p><h4 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2. 扩容"></a>2. 扩容</h4><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="hljs-comment">// overflow-conscious code</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// overflow-conscious code</span></span><br><span class="line">    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3. 删除元素"></a>3. 删除元素</h4><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="hljs-keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Fail-Fast"><a href="#4-Fail-Fast" class="headerlink" title="4. Fail-Fast"></a>4. Fail-Fast</h4><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="hljs-function">    <span class="hljs-keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="hljs-comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="hljs-keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-序列化"><a href="#5-序列化" class="headerlink" title="5. 序列化"></a>5. 序列化</h4><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p><p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure><p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="hljs-function">    <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="hljs-comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="hljs-comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="hljs-function">    <span class="hljs-keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="hljs-comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="hljs-keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(file));</span><br><span class="line">oos.writeObject(list);</span><br></pre></td></tr></table></figure><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="1-同步"><a href="#1-同步" class="headerlink" title="1. 同步"></a>1. 同步</h4><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-与-ArrayList-的比较"><a href="#2-与-ArrayList-的比较" class="headerlink" title="2. 与 ArrayList 的比较"></a>2. 与 ArrayList 的比较</h4><ul><li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li><li>Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。</li></ul><h4 id="3-替代方案"><a href="#3-替代方案" class="headerlink" title="3. 替代方案"></a>3. 替代方案</h4><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure><p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="hljs-keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setArray</span><span class="hljs-params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">get</span><span class="hljs-params">(Object[] a, <span class="hljs-keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p>但是 CopyOnWriteArrayList 有其缺陷：</p><ul><li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li><li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li></ul><p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="1-概览-1"><a href="#1-概览-1" class="headerlink" title="1. 概览"></a>1. 概览</h4><p>基于双向链表实现，使用 Node 存储链表节点信息。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个链表存储了 first 和 last 指针：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190816173047.png" alt=""></p><h4 id="2-与-ArrayList-的比较-1"><a href="#2-与-ArrayList-的比较-1" class="headerlink" title="2. 与 ArrayList 的比较"></a>2. 与 ArrayList 的比较</h4><ul><li>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；</li><li>ArrayList 支持随机访问，LinkedList 不支持；</li><li>LinkedList 在任意位置添加删除元素更快。</li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>为了便于理解，以下源码分析以 JDK 1.7 为主。</p><h4 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h4><p>内部包含了一个 Entry 类型的数组 table。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure><p>Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190816173126.png" alt=""></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="hljs-keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="hljs-keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="hljs-keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="hljs-keyword">if</span> (k1 == k2 || (k1 != <span class="hljs-keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="hljs-keyword">if</span> (v1 == v2 || (v1 != <span class="hljs-keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> getKey() + <span class="hljs-string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-拉链法的工作原理"><a href="#2-拉链法的工作原理" class="headerlink" title="2. 拉链法的工作原理"></a>2. 拉链法的工作原理</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="hljs-string">"K1"</span>, <span class="hljs-string">"V1"</span>);</span><br><span class="line">map.put(<span class="hljs-string">"K2"</span>, <span class="hljs-string">"V2"</span>);</span><br><span class="line">map.put(<span class="hljs-string">"K3"</span>, <span class="hljs-string">"V3"</span>);</span><br></pre></td></tr></table></figure><ul><li>新建一个 HashMap，默认大小为 16；</li><li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</li><li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</li><li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</li></ul><p>应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p><p>查找需要分成两步进行：</p><ul><li>计算键值对所在的桶；</li><li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li></ul><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190816173203.png" alt=""></p><h4 id="3-put-操作"><a href="#3-put-操作" class="headerlink" title="3. put 操作"></a>3. put 操作</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="hljs-keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="hljs-comment">// 确定桶下标</span></span><br><span class="line">    <span class="hljs-keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="hljs-comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="hljs-keyword">this</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="hljs-comment">// 插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> V <span class="hljs-title">putForNullKey</span><span class="hljs-params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="hljs-number">0</span>]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (e.key == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="hljs-keyword">this</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, value, <span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="hljs-keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="hljs-number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="hljs-keyword">null</span> != key) ? hash(key) : <span class="hljs-number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="hljs-comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="hljs-keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line">Entry(<span class="hljs-keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-确定桶下标"><a href="#4-确定桶下标" class="headerlink" title="4. 确定桶下标"></a>4. 确定桶下标</h4><p>很多操作都需要先确定一个键值对所在的桶下标。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="hljs-keyword">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure><p><strong>4.1 计算 hash 值</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.2 取模</strong></p><p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x   : <span class="hljs-number">00010000</span></span><br><span class="line">x-<span class="hljs-number">1</span> : <span class="hljs-number">00001111</span></span><br></pre></td></tr></table></figure><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y       : <span class="hljs-number">10110010</span></span><br><span class="line">x-<span class="hljs-number">1</span>     : <span class="hljs-number">00001111</span></span><br><span class="line">y&amp;(x-<span class="hljs-number">1</span>) : <span class="hljs-number">00000010</span></span><br></pre></td></tr></table></figure><p>这个性质和 y 对 x 取模效果是一样的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y   : <span class="hljs-number">10110010</span></span><br><span class="line">x   : <span class="hljs-number">00010000</span></span><br><span class="line">y%x : <span class="hljs-number">00000010</span></span><br></pre></td></tr></table></figure><p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p><p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-扩容-基本原理"><a href="#5-扩容-基本原理" class="headerlink" title="5. 扩容-基本原理"></a>5. 扩容-基本原理</h4><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。</p><p>为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p><p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>capacity</td><td>table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td></tr><tr><td>size</td><td>键值对数量。</td></tr><tr><td>threshold</td><td>size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td></tr><tr><td>loadFactor</td><td>装载因子，table 能够使用的比例，threshold = capacity * loadFactor。</td></tr></tbody></table><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="hljs-keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="hljs-keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="hljs-number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="hljs-keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="hljs-keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="hljs-keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="hljs-keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="hljs-keyword">null</span>;</span><br><span class="line">            <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-扩容-重新计算桶下标"><a href="#6-扩容-重新计算桶下标" class="headerlink" title="6. 扩容-重新计算桶下标"></a>6. 扩容-重新计算桶下标</h4><p>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。</p><p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">capacity     : <span class="hljs-number">00010000</span></span><br><span class="line"><span class="hljs-keyword">new</span> capacity : <span class="hljs-number">00100000</span></span><br></pre></td></tr></table></figure><p>对于一个 Key，</p><ul><li>它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；</li><li>如果为 1，那么得到的结果为原来的结果 +16。</li></ul><h4 id="7-计算数组容量"><a href="#7-计算数组容量" class="headerlink" title="7. 计算数组容量"></a>7. 计算数组容量</h4><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p><p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mask |= mask &gt;&gt; <span class="hljs-number">1</span>    <span class="hljs-number">11011000</span></span><br><span class="line">mask |= mask &gt;&gt; <span class="hljs-number">2</span>    <span class="hljs-number">11111110</span></span><br><span class="line">mask |= mask &gt;&gt; <span class="hljs-number">4</span>    <span class="hljs-number">11111111</span></span><br></pre></td></tr></table></figure><p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num     <span class="hljs-number">10010000</span></span><br><span class="line">mask+<span class="hljs-number">1</span> <span class="hljs-number">100000000</span></span><br></pre></td></tr></table></figure><p>以下是 HashMap 中计算数组容量的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-链表转红黑树"><a href="#8-链表转红黑树" class="headerlink" title="8. 链表转红黑树"></a>8. 链表转红黑树</h4><p>从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。 应该是：从 JDK 1.8 开始， table的长度也就是HashMap的capacity(不是size)不能小于64而且在桶存储的链表长度为8时(准确的说是长度为7并且在继续塞第8个时),转换成红黑树,而不是超过8。</p><h4 id="9-与-HashTable-的比较"><a href="#9-与-HashTable-的比较" class="headerlink" title="9. 与 HashTable 的比较"></a>9. 与 HashTable 的比较</h4><ul><li>HashTable 使用 synchronized 来进行同步。</li><li>HashMap 可以插入键为 null 的 Entry。</li><li>HashMap 的迭代器是 fail-fast 迭代器。</li><li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="1-存储结构-1"><a href="#1-存储结构-1" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;</span><br><span class="line">    <span class="hljs-keyword">final</span> K key;</span><br><span class="line">    <span class="hljs-keyword">volatile</span> V value;</span><br><span class="line">    <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p><p>Segment 继承自 ReentrantLock。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">64</span> : <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure><p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="hljs-number">16</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190816173430.png" alt=""></p><h4 id="2-size-操作"><a href="#2-size-操作" class="headerlink" title="2. size 操作"></a>2. size 操作</h4><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="hljs-comment"> * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;</span><br></pre></td></tr></table></figure><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p><p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p><p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p><p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="hljs-comment"> * methods before resorting to locking. This is used to avoid</span></span><br><span class="line"><span class="hljs-comment"> * unbounded retries if tables undergo continuous modification</span></span><br><span class="line"><span class="hljs-comment"> * which would make it impossible to obtain an accurate result.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RETRIES_BEFORE_LOCK = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="hljs-comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="hljs-keyword">this</span>.segments;</span><br><span class="line">    <span class="hljs-keyword">int</span> size;</span><br><span class="line">    <span class="hljs-keyword">boolean</span> overflow; <span class="hljs-comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="hljs-keyword">long</span> sum;         <span class="hljs-comment">// sum of modCounts</span></span><br><span class="line">    <span class="hljs-keyword">long</span> last = <span class="hljs-number">0L</span>;   <span class="hljs-comment">// previous sum</span></span><br><span class="line">    <span class="hljs-keyword">int</span> retries = -<span class="hljs-number">1</span>; <span class="hljs-comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="hljs-comment">// 超过尝试次数，则对每个 Segment 加锁</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="hljs-comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="hljs-number">0L</span>;</span><br><span class="line">            size = <span class="hljs-number">0</span>;</span><br><span class="line">            overflow = <span class="hljs-keyword">false</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="hljs-keyword">if</span> (seg != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="hljs-keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span> || (size += c) &lt; <span class="hljs-number">0</span>)</span><br><span class="line">                        overflow = <span class="hljs-keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (sum == last)</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-JDK-1-8-的改动"><a href="#3-JDK-1-8-的改动" class="headerlink" title="3. JDK 1.8 的改动"></a>3. JDK 1.8 的改动</h4><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p><p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p><p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure><p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h3><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="hljs-comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="hljs-keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h4><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p><p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; <span class="hljs-comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="hljs-keyword">if</span> (evict &amp;&amp; (first = head) != <span class="hljs-keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h4><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3；</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ENTRIES = <span class="hljs-number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(MAX_ENTRIES, <span class="hljs-number">0.75f</span>, <span class="hljs-keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache = <span class="hljs-keyword">new</span> LRUCache&lt;&gt;();</span><br><span class="line">    cache.put(<span class="hljs-number">1</span>, <span class="hljs-string">"a"</span>);</span><br><span class="line">    cache.put(<span class="hljs-number">2</span>, <span class="hljs-string">"b"</span>);</span><br><span class="line">    cache.put(<span class="hljs-number">3</span>, <span class="hljs-string">"c"</span>);</span><br><span class="line">    cache.get(<span class="hljs-number">1</span>);</span><br><span class="line">    cache.put(<span class="hljs-number">4</span>, <span class="hljs-string">"d"</span>);</span><br><span class="line">    System.out.println(cache.keySet());</span><br><span class="line">&#125;</span><br><span class="line">[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p><p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">Object</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="ConcurrentCache"><a href="#ConcurrentCache" class="headerlink" title="ConcurrentCache"></a>ConcurrentCache</h4><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p><p>ConcurrentCache 采取的是分代缓存：</p><ul><li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li><li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li><li>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li><li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentCache</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, V&gt; eden;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, V&gt; longterm;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size = size;</span><br><span class="line">        <span class="hljs-keyword">this</span>.eden = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(size);</span><br><span class="line">        <span class="hljs-keyword">this</span>.longterm = <span class="hljs-keyword">new</span> WeakHashMap&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K k)</span> </span>&#123;</span><br><span class="line">        V v = <span class="hljs-keyword">this</span>.eden.get(k);</span><br><span class="line">        <span class="hljs-keyword">if</span> (v == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            v = <span class="hljs-keyword">this</span>.longterm.get(k);</span><br><span class="line">            <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>)</span><br><span class="line">                <span class="hljs-keyword">this</span>.eden.put(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eden.size() &gt;= size) &#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.longterm.putAll(<span class="hljs-keyword">this</span>.eden);</span><br><span class="line">            <span class="hljs-keyword">this</span>.eden.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">this</span>.eden.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="[https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java 容器.md">文章来源</a>)</p><p>.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://removeif.github.io/categories/java/"/>
    
      <category term="java基础" scheme="https://removeif.github.io/categories/java/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="集合" scheme="https://removeif.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>中华人民共和国网络安全法</title>
    <link href="https://removeif.github.io/2019/08/08/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95.html"/>
    <id>https://removeif.github.io/2019/08/08/中华人民共和国网络安全法.html</id>
    <published>2019-08-08T13:46:09.000Z</published>
    <updated>2019-08-22T02:35:59.430Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《<strong>中华人民共和国网络安全法</strong>》是为保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展制定。由全国人民代表大会常务委员会于2016年11月7日发布，自2017年6月1日起施行。<br><a id="more"></a></p></blockquote><h1 id="中华人民共和国网络安全法"><a href="#中华人民共和国网络安全法" class="headerlink" title="中华人民共和国网络安全法"></a>中华人民共和国网络安全法</h1><p>中文名：<strong>中华人民共和国网络安全法</strong></p><p>外文名：People’s Republic of China Network Security Law</p><p>发布机构：全国人民代表大会常务委员会</p><p>发布日期：2016年11月7日</p><p>实施日期：2017年6月1日</p><p>​    <a href="#1">第一章  总    则</a></p><p>​    <a href="#2">第二章  网络安全支持与促进</a></p><p>​    <a href="#3">第三章  网络运行安全</a></p><p>​    <a href="#4">第一节  一般规定</a></p><p>​    <a href="#5">第二节  关键信息基础设施的运行安全</a></p><p>​    <a href="#6">第四章  网络信息安全</a></p><p>​    <a href="#7">第五章  监测预警与应急处置</a></p><p>​    <a href="#8">第六章  法律责任</a></p><p>​    <a href="#9">第七章  附    则</a></p><p><span id="1"></span></p><h3 id="第一章-总-则"><a href="#第一章-总-则" class="headerlink" title="第一章  总    则"></a>第一章  总    则</h3><p><strong>第一条</strong>  为了保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展，制定本法。</p><p><strong>第二条</strong>  在中华人民共和国境内建设、运营、维护和使用网络，以及网络安全的监督管理，适用本法。</p><p><strong>第三条</strong>  国家坚持网络安全与信息化发展并重，遵循积极利用、科学发展、依法管理、确保安全的方针，推进网络基础设施建设和互联互通，鼓励网络技术创新和应用，支持培养网络安全人才，建立健全网络安全保障体系，提高网络安全保护能力。</p><p><strong>第四条</strong>  国家制定并不断完善网络安全战略，明确保障网络安全的基本要求和主要目标，提出重点领域的网络安全政策、工作任务和措施。</p><p><strong>第五条</strong>  国家采取措施，监测、防御、处置来源于中华人民共和国境内外的网络安全风险和威胁，保护关键信息基础设施免受攻击、侵入、干扰和破坏，依法惩治网络违法犯罪活动，维护网络空间安全和秩序。</p><p><strong>第六条</strong>  国家倡导诚实守信、健康文明的网络行为，推动传播社会主义核心价值观，采取措施提高全社会的网络安全意识和水平，形成全社会共同参与促进网络安全的良好环境。</p><p><strong>第七条</strong>  国家积极开展网络空间治理、网络技术研发和标准制定、打击网络违法犯罪等方面的国际交流与合作，推动构建和平、安全、开放、合作的网络空间，建立多边、民主、透明的网络治理体系。</p><p><strong>第八条</strong>  国家网信部门负责统筹协调网络安全工作和相关监督管理工作。国务院电信主管部门、公安部门和其他有关机关依照本法和有关法律、行政法规的规定，在各自职责范围内负责网络安全保护和监督管理工作。</p><p>县级以上地方人民政府有关部门的网络安全保护和监督管理职责，按照国家有关规定确定。</p><p><strong>第九条</strong>  网络运营者开展经营和服务活动，必须遵守法律、行政法规，尊重社会公德，遵守商业道德，诚实信用，履行网络安全保护义务，接受政府和社会的监督，承担社会责任。</p><p><strong>第十条</strong>  建设、运营网络或者通过网络提供服务，应当依照法律、行政法规的规定和国家标准的强制性要求，采取技术措施和其他必要措施，保障网络安全、稳定运行，有效应对网络安全事件，防范网络违法犯罪活动，维护网络数据的完整性、保密性和可用性。</p><p><strong>第十一条</strong>  网络相关行业组织按照章程，加强行业自律，制定网络安全行为规范，指导会员加强网络安全保护，提高网络安全保护水平，促进行业健康发展。</p><p><strong>第十二条</strong>  国家保护公民、法人和其他组织依法使用网络的权利，促进网络接入普及，提升网络服务水平，为社会提供安全、便利的网络服务，保障网络信息依法有序自由流动。</p><p>任何个人和组织使用网络应当遵守宪法法律，遵守公共秩序，尊重社会公德，不得危害网络安全，不得利用网络从事危害国家安全、荣誉和利益，煽动颠覆国家政权、推翻社会主义制度，煽动分裂国家、破坏国家统一，宣扬恐怖主义、极端主义，宣扬民族仇恨、民族歧视，传播暴力、淫秽色情信息，编造、传播虚假信息扰乱经济秩序和社会秩序，以及侵害他人名誉、隐私、知识产权和其他合法权益等活动。</p><p><strong>第十三条</strong>  国家支持研究开发有利于未成年人健康成长的网络产品和服务，依法惩治利用网络从事危害未成年人身心健康的活动，为未成年人提供安全、健康的网络环境。</p><p><strong>第十四条</strong>  任何个人和组织有权对危害网络安全的行为向网信、电信、公安等部门举报。收到举报的部门应当及时依法作出处理；不属于本部门职责的，应当及时移送有权处理的部门。</p><p>有关部门应当对举报人的相关信息予以保密，保护举报人的合法权益。<br><span id="2"></span></p><h3 id="第二章-网络安全支持与促进"><a href="#第二章-网络安全支持与促进" class="headerlink" title="第二章  网络安全支持与促进"></a>第二章  网络安全支持与促进</h3><p><strong>第十五条</strong>  国家建立和完善网络安全标准体系。国务院标准化行政主管部门和国务院其他有关部门根据各自的职责，组织制定并适时修订有关网络安全管理以及网络产品、服务和运行安全的国家标准、行业标准。</p><p>国家支持企业、研究机构、高等学校、网络相关行业组织参与网络安全国家标准、行业标准的制定。</p><p><strong>第十六条</strong>  国务院和省、自治区、直辖市人民政府应当统筹规划，加大投入，扶持重点网络安全技术产业和项目，支持网络安全技术的研究开发和应用，推广安全可信的网络产品和服务，保护网络技术知识产权，支持企业、研究机构和高等学校等参与国家网络安全技术创新项目。</p><p><strong>第十七条</strong>  国家推进网络安全社会化服务体系建设，鼓励有关企业、机构开展网络安全认证、检测和风险评估等安全服务。</p><p><strong>第十八条</strong>  国家鼓励开发网络数据安全保护和利用技术，促进公共数据资源开放，推动技术创新和经济社会发展。</p><p>国家支持创新网络安全管理方式，运用网络新技术，提升网络安全保护水平。</p><p><strong>第十九条</strong>  各级人民政府及其有关部门应当组织开展经常性的网络安全宣传教育，并指导、督促有关单位做好网络安全宣传教育工作。</p><p>大众传播媒介应当有针对性地面向社会进行网络安全宣传教育。</p><p><strong>第二十条</strong>  国家支持企业和高等学校、职业学校等教育培训机构开展网络安全相关教育与培训，采取多种方式培养网络安全人才，促进网络安全人才交流。<br><span id="3"></span></p><h3 id="第三章-网络运行安全"><a href="#第三章-网络运行安全" class="headerlink" title="第三章  网络运行安全"></a>第三章  网络运行安全</h3><p><span id="4"></span></p><h4 id="第一节-一般规定"><a href="#第一节-一般规定" class="headerlink" title="第一节 一般规定"></a>第一节 一般规定</h4><p><strong>第二十一条</strong>  国家实行网络安全等级保护制度。网络运营者应当按照网络安全等级保护制度的要求，履行下列安全保护义务，保障网络免受干扰、破坏或者未经授权的访问，防止网络数据泄露或者被窃取、篡改：</p><p>（一）制定内部安全管理制度和操作规程，确定网络安全负责人，落实网络安全保护责任；</p><p>（二）采取防范计算机病毒和网络攻击、网络侵入等危害网络安全行为的技术措施；</p><p>（三）采取监测、记录网络运行状态、网络安全事件的技术措施，并按照规定留存相关的网络日志不少于六个月；</p><p>（四）采取数据分类、重要数据备份和加密等措施；</p><p>（五）法律、行政法规规定的其他义务。</p><p><strong>第二十二条</strong>  网络产品、服务应当符合相关国家标准的强制性要求。网络产品、服务的提供者不得设置恶意程序；发现其网络产品、服务存在安全缺陷、漏洞等风险时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。</p><p>网络产品、服务的提供者应当为其产品、服务持续提供安全维护；在规定或者当事人约定的期限内，不得终止提供安全维护。</p><p>网络产品、服务具有收集用户信息功能的，其提供者应当向用户明示并取得同意；涉及用户个人信息的，还应当遵守本法和有关法律、行政法规关于个人信息保护的规定。</p><p><strong>第二十三条</strong>  网络关键设备和网络安全专用产品应当按照相关国家标准的强制性要求，由具备资格的机构安全认证合格或者安全检测符合要求后，方可销售或者提供。国家网信部门会同国务院有关部门制定、公布网络关键设备和网络安全专用产品目录，并推动安全认证和安全检测结果互认，避免重复认证、检测。</p><p><strong>第二十四条</strong>  网络运营者为用户办理网络接入、域名注册服务，办理固定电话、移动电话等入网手续，或者为用户提供信息发布、即时通讯等服务，在与用户签订协议或者确认提供服务时，应当要求用户提供真实身份信息。用户不提供真实身份信息的，网络运营者不得为其提供相关服务。</p><p>国家实施网络可信身份战略，支持研究开发安全、方便的电子身份认证技术，推动不同电子身份认证之间的互认。</p><p><strong>第二十五条</strong>  网络运营者应当制定网络安全事件应急预案，及时处置系统漏洞、计算机病毒、网络攻击、网络侵入等安全风险；在发生危害网络安全的事件时，立即启动应急预案，采取相应的补救措施，并按照规定向有关主管部门报告。</p><p><strong>第二十六条</strong>  开展网络安全认证、检测、风险评估等活动，向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息，应当遵守国家有关规定。</p><p><strong>第二十七条</strong>  任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。</p><p><strong>第二十八条</strong>  网络运营者应当为公安机关、国家安全机关依法维护国家安全和侦查犯罪的活动提供技术支持和协助。</p><p><strong>第二十九条</strong>  国家支持网络运营者之间在网络安全信息收集、分析、通报和应急处置等方面进行合作，提高网络运营者的安全保障能力。</p><p>有关行业组织建立健全本行业的网络安全保护规范和协作机制，加强对网络安全风险的分析评估，定期向会员进行风险警示，支持、协助会员应对网络安全风险。</p><p><strong>第三十条</strong>  网信部门和有关部门在履行网络安全保护职责中获取的信息，只能用于维护网络安全的需要，不得用于其他用途。<br><span id="5"></span></p><h4 id="第二节-关键信息基础设施的运行安全"><a href="#第二节-关键信息基础设施的运行安全" class="headerlink" title="第二节 关键信息基础设施的运行安全"></a>第二节 关键信息基础设施的运行安全</h4><p><strong>第三十一条</strong>  国家对公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务等重要行业和领域，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的关键信息基础设施，在网络安全等级保护制度的基础上，实行重点保护。关键信息基础设施的具体范围和安全保护办法由国务院制定。</p><p>国家鼓励关键信息基础设施以外的网络运营者自愿参与关键信息基础设施保护体系。</p><p><strong>第三十二条</strong>  按照国务院规定的职责分工，负责关键信息基础设施安全保护工作的部门分别编制并组织实施本行业、本领域的关键信息基础设施安全规划，指导和监督关键信息基础设施运行安全保护工作。</p><p><strong>第三十三条</strong>  建设关键信息基础设施应当确保其具有支持业务稳定、持续运行的性能，并保证安全技术措施同步规划、同步建设、同步使用。</p><p><strong>第三十四条</strong>  除本法第二十一条的规定外，关键信息基础设施的运营者还应当履行下列安全保护义务：</p><p>（一）设置专门安全管理机构和安全管理负责人，并对该负责人和关键岗位的人员进行安全背景审查；</p><p>（二）定期对从业人员进行网络安全教育、技术培训和技能考核；</p><p>（三）对重要系统和数据库进行容灾备份；</p><p>（四）制定网络安全事件应急预案，并定期进行演练；</p><p>（五）法律、行政法规规定的其他义务。</p><p><strong>第三十五条</strong>  关键信息基础设施的运营者采购网络产品和服务，可能影响国家安全的，应当通过国家网信部门会同国务院有关部门组织的国家安全审查。</p><p><strong>第三十六条</strong>  关键信息基础设施的运营者采购网络产品和服务，应当按照规定与提供者签订安全保密协议，明确安全和保密义务与责任。</p><p><strong>第三十七条</strong>  关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的个人信息和重要数据应当在境内存储。因业务需要，确需向境外提供的，应当按照国家网信部门会同国务院有关部门制定的办法进行安全评估；法律、行政法规另有规定的，依照其规定。</p><p><strong>第三十八条</strong>  关键信息基础设施的运营者应当自行或者委托网络安全服务机构对其网络的安全性和可能存在的风险每年至少进行一次检测评估，并将检测评估情况和改进措施报送相关负责关键信息基础设施安全保护工作的部门。</p><p><strong>第三十九条</strong>  国家网信部门应当统筹协调有关部门对关键信息基础设施的安全保护采取下列措施：</p><p>（一）对关键信息基础设施的安全风险进行抽查检测，提出改进措施，必要时可以委托网络安全服务机构对网络存在的安全风险进行检测评估；</p><p>（二）定期组织关键信息基础设施的运营者进行网络安全应急演练，提高应对网络安全事件的水平和协同配合能力；</p><p>（三）促进有关部门、关键信息基础设施的运营者以及有关研究机构、网络安全服务机构等之间的网络安全信息共享；</p><p>（四）对网络安全事件的应急处置与网络功能的恢复等，提供技术支持和协助。<br><span id="6"></span></p><h3 id="第四章-网络信息安全"><a href="#第四章-网络信息安全" class="headerlink" title="第四章  网络信息安全"></a>第四章  网络信息安全</h3><p><strong>第四十条</strong>  网络运营者应当对其收集的用户信息严格保密，并建立健全用户信息保护制度。</p><p><strong>第四十一条</strong>  网络运营者收集、使用个人信息，应当遵循合法、正当、必要的原则，公开收集、使用规则，明示收集、使用信息的目的、方式和范围，并经被收集者同意。</p><p>网络运营者不得收集与其提供的服务无关的个人信息，不得违反法律、行政法规的规定和双方的约定收集、使用个人信息，并应当依照法律、行政法规的规定和与用户的约定，处理其保存的个人信息。</p><p><strong>第四十二条</strong>  网络运营者不得泄露、篡改、毁损其收集的个人信息；未经被收集者同意，不得向他人提供个人信息。但是，经过处理无法识别特定个人且不能复原的除外。</p><p>网络运营者应当采取技术措施和其他必要措施，确保其收集的个人信息安全，防止信息泄露、毁损、丢失。在发生或者可能发生个人信息泄露、毁损、丢失的情况时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。</p><p><strong>第四十三条</strong>  个人发现网络运营者违反法律、行政法规的规定或者双方的约定收集、使用其个人信息的，有权要求网络运营者删除其个人信息；发现网络运营者收集、存储的其个人信息有错误的，有权要求网络运营者予以更正。网络运营者应当采取措施予以删除或者更正。</p><p><strong>第四十四条</strong>  任何个人和组织不得窃取或者以其他非法方式获取个人信息，不得非法出售或者非法向他人提供个人信息。</p><p><strong>第四十五条</strong>  依法负有网络安全监督管理职责的部门及其工作人员，必须对在履行职责中知悉的个人信息、隐私和商业秘密严格保密，不得泄露、出售或者非法向他人提供。</p><p><strong>第四十六条</strong>  任何个人和组织应当对其使用网络的行为负责，不得设立用于实施诈骗，传授犯罪方法，制作或者销售违禁物品、管制物品等违法犯罪活动的网站、通讯群组，不得利用网络发布涉及实施诈骗，制作或者销售违禁物品、管制物品以及其他违法犯罪活动的信息。</p><p><strong>第四十七条</strong>  网络运营者应当加强对其用户发布的信息的管理，发现法律、行政法规禁止发布或者传输的信息的，应当立即停止传输该信息，采取消除等处置措施，防止信息扩散，保存有关记录，并向有关主管部门报告。</p><p><strong>第四十八条</strong>  任何个人和组织发送的电子信息、提供的应用软件，不得设置恶意程序，不得含有法律、行政法规禁止发布或者传输的信息。</p><p>电子信息发送服务提供者和应用软件下载服务提供者，应当履行安全管理义务，知道其用户有前款规定行为的，应当停止提供服务，采取消除等处置措施，保存有关记录，并向有关主管部门报告。</p><p><strong>第四十九条</strong>  网络运营者应当建立网络信息安全投诉、举报制度，公布投诉、举报方式等信息，及时受理并处理有关网络信息安全的投诉和举报。</p><p>网络运营者对网信部门和有关部门依法实施的监督检查，应当予以配合。</p><p><strong>第五十条</strong>  国家网信部门和有关部门依法履行网络信息安全监督管理职责，发现法律、行政法规禁止发布或者传输的信息的，应当要求网络运营者停止传输，采取消除等处置措施，保存有关记录；对来源于中华人民共和国境外的上述信息，应当通知有关机构采取技术措施和其他必要措施阻断传播。<br><span id="7"></span></p><h3 id="第五章-监测预警与应急处置"><a href="#第五章-监测预警与应急处置" class="headerlink" title="第五章  监测预警与应急处置"></a>第五章  监测预警与应急处置</h3><p><strong>第五十一条</strong>  国家建立网络安全监测预警和信息通报制度。国家网信部门应当统筹协调有关部门加强网络安全信息收集、分析和通报工作，按照规定统一发布网络安全监测预警信息。</p><p><strong>第五十二条</strong>  负责关键信息基础设施安全保护工作的部门，应当建立健全本行业、本领域的网络安全监测预警和信息通报制度，并按照规定报送网络安全监测预警信息。</p><p><strong>第五十三条</strong>  国家网信部门协调有关部门建立健全网络安全风险评估和应急工作机制，制定网络安全事件应急预案，并定期组织演练。</p><p>负责关键信息基础设施安全保护工作的部门应当制定本行业、本领域的网络安全事件应急预案，并定期组织演练。</p><p>网络安全事件应急预案应当按照事件发生后的危害程度、影响范围等因素对网络安全事件进行分级，并规定相应的应急处置措施。</p><p><strong>第五十四条</strong>  网络安全事件发生的风险增大时，省级以上人民政府有关部门应当按照规定的权限和程序，并根据网络安全风险的特点和可能造成的危害，采取下列措施：</p><p>（一）要求有关部门、机构和人员及时收集、报告有关信息，加强对网络安全风险的监测；</p><p>（二）组织有关部门、机构和专业人员，对网络安全风险信息进行分析评估，预测事件发生的可能性、影响范围和危害程度；</p><p>（三）向社会发布网络安全风险预警，发布避免、减轻危害的措施。</p><p><strong>第五十五条</strong>  发生网络安全事件，应当立即启动网络安全事件应急预案，对网络安全事件进行调查和评估，要求网络运营者采取技术措施和其他必要措施，消除安全隐患，防止危害扩大，并及时向社会发布与公众有关的警示信息。</p><p><strong>第五十六条</strong>  省级以上人民政府有关部门在履行网络安全监督管理职责中，发现网络存在较大安全风险或者发生安全事件的，可以按照规定的权限和程序对该网络的运营者的法定代表人或者主要负责人进行约谈。网络运营者应当按照要求采取措施，进行整改，消除隐患。</p><p><strong>第五十七条</strong>  因网络安全事件，发生突发事件或者生产安全事故的，应当依照《中华人民共和国突发事件应对法》、《中华人民共和国安全生产法》等有关法律、行政法规的规定处置。</p><p><strong>第五十八条</strong> 因维护国家安全和社会公共秩序，处置重大突发社会安全事件的需要，经国务院决定或者批准，可以在特定区域对网络通信采取限制等临时措施。<br><span id="8"></span></p><h3 id="第六章-法律责任"><a href="#第六章-法律责任" class="headerlink" title="第六章  法律责任"></a>第六章  法律责任</h3><p><strong>第五十九条</strong>  网络运营者不履行本法第二十一条、第二十五条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处一万元以上十万元以下罚款，对直接负责的主管人员处五千元以上五万元以下罚款。</p><p>关键信息基础设施的运营者不履行本法第三十三条、第三十四条、第三十六条、第三十八条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处十万元以上一百万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款。</p><p><strong>第六十条</strong>  违反本法第二十二条第一款、第二款和第四十八条第一款规定，有下列行为之一的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处五万元以上五十万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款：</p><p>（一）设置恶意程序的；</p><p>（二）对其产品、服务存在的安全缺陷、漏洞等风险未立即采取补救措施，或者未按照规定及时告知用户并向有关主管部门报告的；</p><p>（三）擅自终止为其产品、服务提供安全维护的。</p><p><strong>第六十一条</strong>  网络运营者违反本法第二十四条第一款规定，未要求用户提供真实身份信息，或者对不提供真实身份信息的用户提供相关服务的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。</p><p><strong>第六十二条</strong>  违反本法第二十六条规定，开展网络安全认证、检测、风险评估等活动，或者向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息的，由有关主管部门责令改正，给予警告；拒不改正或者情节严重的，处一万元以上十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处五千元以上五万元以下罚款。</p><p><strong>第六十三条</strong>  违反本法第二十七条规定，从事危害网络安全的活动，或者提供专门用于从事危害网络安全活动的程序、工具，或者为他人从事危害网络安全的活动提供技术支持、广告推广、支付结算等帮助，尚不构成犯罪的，由公安机关没收违法所得，处五日以下拘留，可以并处五万元以上五十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处十万元以上一百万元以下罚款。</p><p>单位有前款行为的，由公安机关没收违法所得，处十万元以上一百万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。</p><p>违反本法第二十七条规定，受到治安管理处罚的人员，五年内不得从事网络安全管理和网络运营关键岗位的工作；受到刑事处罚的人员，终身不得从事网络安全管理和网络运营关键岗位的工作。</p><p><strong>第六十四条</strong>  网络运营者、网络产品或者服务的提供者违反本法第二十二条第三款、第四十一条至第四十三条规定，侵害个人信息依法得到保护的权利的，由有关主管部门责令改正，可以根据情节单处或者并处警告、没收违法所得、处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款；情节严重的，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照。</p><p>违反本法第四十四条规定，窃取或者以其他非法方式获取、非法出售或者非法向他人提供个人信息，尚不构成犯罪的，由公安机关没收违法所得，并处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款。</p><p><strong>第六十五条</strong>  关键信息基础设施的运营者违反本法第三十五条规定，使用未经安全审查或者安全审查未通过的网络产品或者服务的，由有关主管部门责令停止使用，处采购金额一倍以上十倍以下罚款；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。</p><p><strong>第六十六条</strong>  关键信息基础设施的运营者违反本法第三十七条规定，在境外存储网络数据，或者向境外提供网络数据的，由有关主管部门责令改正，给予警告，没收违法所得，处五万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。</p><p><strong>第六十七条</strong>  违反本法第四十六条规定，设立用于实施违法犯罪活动的网站、通讯群组，或者利用网络发布涉及实施违法犯罪活动的信息，尚不构成犯罪的，由公安机关处五日以下拘留，可以并处一万元以上十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处五万元以上五十万元以下罚款。关闭用于实施违法犯罪活动的网站、通讯群组。</p><p>单位有前款行为的，由公安机关处十万元以上五十万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。</p><p><strong>第六十八条</strong>  网络运营者违反本法第四十七条规定，对法律、行政法规禁止发布或者传输的信息未停止传输、采取消除等处置措施、保存有关记录的，由有关主管部门责令改正，给予警告，没收违法所得；拒不改正或者情节严重的，处十万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。</p><p>电子信息发送服务提供者、应用软件下载服务提供者，不履行本法第四十八条第二款规定的安全管理义务的，依照前款规定处罚。</p><p><strong>第六十九条</strong>  网络运营者违反本法规定，有下列行为之一的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，对直接负责的主管人员和其他直接责任人员，处一万元以上十万元以下罚款：</p><p>（一）不按照有关部门的要求对法律、行政法规禁止发布或者传输的信息，采取停止传输、消除等处置措施的；</p><p>（二）拒绝、阻碍有关部门依法实施的监督检查的；</p><p>（三）拒不向公安机关、国家安全机关提供技术支持和协助的。</p><p><strong>第七十条</strong>  发布或者传输本法第十二条第二款和其他法律、行政法规禁止发布或者传输的信息的，依照有关法律、行政法规的规定处罚。</p><p><strong>第七十一条</strong>  有本法规定的违法行为的，依照有关法律、行政法规的规定记入信用档案，并予以公示。</p><p><strong>第七十二条</strong>  国家机关政务网络的运营者不履行本法规定的网络安全保护义务的，由其上级机关或者有关机关责令改正；对直接负责的主管人员和其他直接责任人员依法给予处分。</p><p><strong>第七十三条</strong>  网信部门和有关部门违反本法第三十条规定，将在履行网络安全保护职责中获取的信息用于其他用途的，对直接负责的主管人员和其他直接责任人员依法给予处分。</p><p>网信部门和有关部门的工作人员玩忽职守、滥用职权、徇私舞弊，尚不构成犯罪的，依法给予处分。</p><p><strong>第七十四条</strong>  违反本法规定，给他人造成损害的，依法承担民事责任。</p><p>违反本法规定，构成违反治安管理行为的，依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。</p><p><strong>第七十五条</strong>  境外的机构、组织、个人从事攻击、侵入、干扰、破坏等危害中华人民共和国的关键信息基础设施的活动，造成严重后果的，依法追究法律责任；国务院公安部门和有关部门并可以决定对该机构、组织、个人采取冻结财产或者其他必要的制裁措施。<br><span id="9"></span></p><h3 id="第七章-附-则"><a href="#第七章-附-则" class="headerlink" title="第七章  附    则"></a>第七章  附    则</h3><p><strong>第七十六条</strong>  本法下列用语的含义：</p><p>（一）网络，是指由计算机或者其他信息终端及相关设备组成的按照一定的规则和程序对信息进行收集、存储、传输、交换、处理的系统。</p><p>（二）网络安全，是指通过采取必要措施，防范对网络的攻击、侵入、干扰、破坏和非法使用以及意外事故，使网络处于稳定可靠运行的状态，以及保障网络数据的完整性、保密性、可用性的能力。</p><p>（三）网络运营者，是指网络的所有者、管理者和网络服务提供者。</p><p>（四）网络数据，是指通过网络收集、存储、传输、处理和产生的各种电子数据。</p><p>（五）个人信息，是指以电子或者其他方式记录的能够单独或者与其他信息结合识别自然人个人身份的各种信息，包括但不限于自然人的姓名、出生日期、身份证件号码、个人生物识别信息、住址、电话号码等。</p><p><strong>第七十七条</strong>  存储、处理涉及国家秘密信息的网络的运行安全保护，除应当遵守本法外，还应当遵守保密法律、行政法规的规定。</p><p><strong>第七十八条</strong>  军事网络的安全保护，由中央军事委员会另行规定。</p><p><strong>第七十九条</strong>  本法自2017年6月1日起施行。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《&lt;strong&gt;中华人民共和国网络安全法&lt;/strong&gt;》是为保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展制定。由全国人民代表大会常务委员会于2016年11月7日发布，自2017年6月1日起施行。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="法律" scheme="https://removeif.github.io/categories/%E6%B3%95%E5%BE%8B/"/>
    
    
      <category term="法律" scheme="https://removeif.github.io/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发相关知识点</title>
    <link href="https://removeif.github.io/2019/08/07/Java%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://removeif.github.io/2019/08/07/Java并发相关知识点.html</id>
    <published>2019-08-07T07:52:06.000Z</published>
    <updated>2019-08-16T09:13:50.793Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。<br>  互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p></blockquote><a id="more"></a><p>并发零碎知识点</p><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190806172320.png" alt=""></p><p><strong>新建（New）</strong></p><p>创建后尚未启动。</p><p><strong>可运行（Runnable）</strong></p><p>可能正在运行，也可能正在等待 CPU 时间片。</p><p>包含了操作系统线程状态中的 Running 和 Ready。</p><p><strong>阻塞（Blocked）</strong></p><p>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p><p><strong>无限期等待（Waiting）</strong></p><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><p><strong>限期等待（Timed Waiting）</strong></p><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p><p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p><p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><p><strong>死亡（Terminated）</strong></p><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><h2 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h2><p>有三种使用线程的方法：</p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p><h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><p>需要实现 run() 方法。</p><p>通过 Thread 调用 start() 方法来启动线程。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="hljs-keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="hljs-keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">  <span class="hljs-comment">//调用 thread.run()并不是开启新线程，而是在当前线程里马上调用run()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h3><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="hljs-keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="hljs-keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="hljs-keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h3><p>实现接口会更好一些，因为：</p><ul><li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li><li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li></ul><h2 id="基础线程机制"><a href="#基础线程机制" class="headerlink" title="基础线程机制"></a>基础线程机制</h2><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p><p>主要有三种 Executor：</p><ul><li>CachedThreadPool：一个任务创建一个线程；</li><li>FixedThreadPool：所有任务只能使用固定大小的线程；</li><li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="hljs-keyword">new</span> MyRunnable());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>main() 属于非守护线程。</p><p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable());</span><br><span class="line">    thread.setDaemon(<span class="hljs-keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p><p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="hljs-number">3000</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p><h3 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h3><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line">                System.out.println(<span class="hljs-string">"Thread run"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="hljs-keyword">new</span> MyThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="hljs-string">"Main run"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$<span class="hljs-number">0</span>(InterruptExample.java:<span class="hljs-number">5</span>)</span><br><span class="line">    at InterruptExample$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">713338599</span>.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)</span><br></pre></td></tr></table></figure><h3 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h3><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p><p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="hljs-comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="hljs-string">"Thread end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread2 = <span class="hljs-keyword">new</span> MyThread2();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">Thread end</span><br></pre></td></tr></table></figure><h3 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h3><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p><p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line">            System.out.println(<span class="hljs-string">"Thread run"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="hljs-string">"Main run"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda$main$<span class="hljs-number">0</span>(ExecutorInterruptExample.java:<span class="hljs-number">9</span>)</span><br><span class="line">    at ExecutorInterruptExample$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">1160460865</span>.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="hljs-number">1142</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="hljs-number">617</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)</span><br></pre></td></tr></table></figure><p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="hljs-comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="hljs-keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><strong>1. 同步一个代码块</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="hljs-string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="hljs-keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span></span><br></pre></td></tr></table></figure><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="hljs-keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="hljs-keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">9</span></span><br></pre></td></tr></table></figure><p><strong>2. 同步一个方法</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span> <span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它和同步代码块一样，作用于同一个对象。</p><p><strong>3. 同步一个类</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="hljs-string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="hljs-keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="hljs-keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span></span><br></pre></td></tr></table></figure><p><strong>4. 同步一个静态方法</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用于整个类。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="hljs-string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="hljs-comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LockExample lockExample = <span class="hljs-keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span></span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><strong>1. 锁的实现</strong></p><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><p><strong>2. 性能</strong></p><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><p><strong>3. 等待可中断</strong></p><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><p><strong>4. 公平锁</strong></p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><p><strong>5. 锁绑定多个条件</strong></p><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><h3 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h3><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 <strong>ReentrantLock 不是所有的 JDK 版本都支持</strong>。并且使用 <strong>synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放</strong>。</p><h2 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h2><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="hljs-string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="hljs-keyword">new</span> A();</span><br><span class="line">        B b = <span class="hljs-keyword">new</span> B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JoinExample example = <span class="hljs-keyword">new</span> JoinExample();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h3><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p><p>它们都属于 Object 的一部分，而不属于 Thread。</p><p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</p><p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"before"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="hljs-string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="hljs-keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure><p><strong>wait() 和 sleep() 的区别</strong></p><ul><li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><h3 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h3><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p><p>使用 Lock 来获取一个 Condition 对象。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"before"</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="hljs-string">"after"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    AwaitSignalExample example = <span class="hljs-keyword">new</span> AwaitSignalExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure><h2 id="J-U-C-AQS"><a href="#J-U-C-AQS" class="headerlink" title="J.U.C - AQS"></a>J.U.C - AQS</h2><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>用来控制一个或者多个线程等待多个线程。</p><p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190806173906.png" alt=""></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalThread = <span class="hljs-number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="hljs-string">"run.."</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="hljs-string">"end"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run..run..run..run..run..run..run..run..run..run..end</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="hljs-keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="hljs-keyword">this</span>.count = parties;</span><br><span class="line">    <span class="hljs-keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>(parties, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190806174326.png" alt=""></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalThread = <span class="hljs-number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="hljs-string">"before.."</span>);</span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="hljs-string">"after.."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</span><br></pre></td></tr></table></figure><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> clientCount = <span class="hljs-number">3</span>;</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalRequestCount = <span class="hljs-number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="hljs-string">" "</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure><h2 id="J-U-C-其它组件"><a href="#J-U-C-其它组件" class="headerlink" title="J.U.C - 其它组件"></a>J.U.C - 其它组件</h2><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureTask</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;Integer&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;</span><br><span class="line">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="hljs-number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread = <span class="hljs-keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread otherThread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"other task is running..."</span>);</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="hljs-number">1000</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">other task is running...</span><br><span class="line"><span class="hljs-number">4950</span></span><br></pre></td></tr></table></figure><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p><strong>java.util.concurrent.BlockingQueue</strong> 接口有以下阻塞队列的实现：</p><ul><li><strong>FIFO 队列</strong> ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li><li><strong>优先级队列</strong> ：PriorityBlockingQueue</li></ul><p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p><p><strong>使用 BlockingQueue 实现生产者消费者问题</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="hljs-string">"product"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="hljs-string">"produce.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                String product = queue.take();</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="hljs-string">"consume.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="hljs-keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="line">        Consumer consumer = <span class="hljs-keyword">new</span> Consumer();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="hljs-keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..</span><br></pre></td></tr></table></figure><h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkJoinExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threshold = <span class="hljs-number">5</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> first;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ForkJoinExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.first = first;</span><br><span class="line">        <span class="hljs-keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="hljs-comment">// 任务足够小则直接计算</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// 拆分成小任务</span></span><br><span class="line">            <span class="hljs-keyword">int</span> middle = first + (last - first) / <span class="hljs-number">2</span>;</span><br><span class="line">            ForkJoinExample leftTask = <span class="hljs-keyword">new</span> ForkJoinExample(first, middle);</span><br><span class="line">            ForkJoinExample rightTask = <span class="hljs-keyword">new</span> ForkJoinExample(middle + <span class="hljs-number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ForkJoinExample example = <span class="hljs-keyword">new</span> ForkJoinExample(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>);</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool();</span><br><span class="line">    Future result = forkJoinPool.submit(example);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkJoinPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure><p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190806182557.png" alt=""></p><h2 id="线程不安全示例"><a href="#线程不安全示例" class="headerlink" title="线程不安全示例"></a>线程不安全示例</h2><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p><p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadSize = <span class="hljs-number">1000</span>;</span><br><span class="line">    ThreadUnsafeExample example = <span class="hljs-keyword">new</span> ThreadUnsafeExample();</span><br><span class="line">    <span class="hljs-keyword">final</span> CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-number">997</span></span><br></pre></td></tr></table></figure><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p><p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190806182932.png" alt=""></p><p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p><p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190806183027.png" alt=""></p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190806183107.png" alt=""></p><h3 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h3><p><strong>1. 原子性</strong></p><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p><p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p><p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p><p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190806183324.png" alt=""></p><p>AtomicInteger 能保证多个线程修改的原子性。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190806183350.png" alt=""></p><p>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicExample</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> AtomicInteger cnt = <span class="hljs-keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        cnt.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> cnt.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadSize = <span class="hljs-number">1000</span>;</span><br><span class="line">    AtomicExample example = <span class="hljs-keyword">new</span> AtomicExample(); <span class="hljs-comment">// 只修改这条语句</span></span><br><span class="line">    <span class="hljs-keyword">final</span> CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-number">1000</span></span><br></pre></td></tr></table></figure><p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicSynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadSize = <span class="hljs-number">1000</span>;</span><br><span class="line">    AtomicSynchronizedExample example = <span class="hljs-keyword">new</span> AtomicSynchronizedExample();</span><br><span class="line">    <span class="hljs-keyword">final</span> CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-number">1000</span></span><br></pre></td></tr></table></figure><p><strong>2. 可见性</strong></p><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><p>主要有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li><li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li></ul><p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p><p><strong>3. 有序性</strong></p><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p><p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><p><strong>1. 单一线程原则</strong></p><blockquote><p>Single Thread rule</p></blockquote><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190806184400.png" alt=""></p><p><strong>2. 管程锁定规则</strong></p><blockquote><p>Monitor Lock Rule</p></blockquote><p>​    一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190806184318.png" alt=""></p><p><strong>3.volatile 变量规则</strong></p><blockquote><p>Volatile Variable Rule</p></blockquote><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190806184517.png" alt=""></p><p><strong>4. 线程启动规则</strong></p><blockquote><p>Thread Start Rule</p></blockquote><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190806184529.png" alt=""></p><p><strong>5. 线程加入规则</strong></p><blockquote><p>Thread Join Rule</p></blockquote><p>Thread 对象的结束先行发生于 join() 方法返回。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190806184646.png" alt=""></p><p><strong>6. 线程中断规则</strong></p><blockquote><p>Thread Interruption Rule</p></blockquote><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p><p><strong>7. 对象终结规则</strong></p><blockquote><p>Finalizer Rule</p></blockquote><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p><p><strong>8. 传递性</strong></p><blockquote><p>Transitivity</p></blockquote><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p><p>线程安全有以下几种实现方式：</p><h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p><p>不可变的类型：</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li></ul><p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImmutableExample</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        unmodifiableMap.put(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Exception in thread <span class="hljs-string">"main"</span> java.lang.UnsupportedOperationException</span><br><span class="line">    at java.util.Collections$UnmodifiableMap.put(Collections.java:<span class="hljs-number">1457</span>)</span><br><span class="line">    at ImmutableExample.main(ImmutableExample.java:<span class="hljs-number">9</span>)</span><br></pre></td></tr></table></figure><p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥同步-1"><a href="#互斥同步-1" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>synchronized 和 ReentrantLock。</p><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><p><strong>1. CAS</strong></p><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><p><strong>2. AtomicInteger</strong></p><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p><p>以下代码使用了 AtomicInteger 执行了自增的操作。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> AtomicInteger cnt = <span class="hljs-keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p><p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> var5;</span><br><span class="line">    <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. ABA</strong></p><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p><p><strong>1. 栈封闭</strong></p><p>多个线程访问<strong>同一个方法的局部变量</strong>时，不会出现线程安全问题，因为<strong>局部变量存储在虚拟机栈</strong>中，属于<strong>线程私有</strong>的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add100</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StackClosedExample example = <span class="hljs-keyword">new</span> StackClosedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-number">100</span></span><br><span class="line"><span class="hljs-number">100</span></span><br></pre></td></tr></table></figure><p><strong>2. 线程本地存储（Thread Local Storage）</strong></p><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p><p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="hljs-keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="hljs-number">1</span>);</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="hljs-number">1000</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="hljs-number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-number">1</span></span><br></pre></td></tr></table></figure><p>为了理解 ThreadLocal，先看以下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalExample1</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal1 = <span class="hljs-keyword">new</span> ThreadLocal();</span><br><span class="line">        ThreadLocal threadLocal2 = <span class="hljs-keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="hljs-number">1</span>);</span><br><span class="line">            threadLocal2.set(<span class="hljs-number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="hljs-number">2</span>);</span><br><span class="line">            threadLocal2.set(<span class="hljs-number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它所对应的底层结构图为：</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190807153325.png" alt=""></p><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="hljs-comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;</span><br></pre></td></tr></table></figure><p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)</span><br><span class="line">        map.set(<span class="hljs-keyword">this</span>, value);</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get() 方法类似。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="hljs-keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p><p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 <strong>ThreadLocal 经典的内存泄漏</strong>甚至是造成自身业务混乱的风险。</p><p><strong>3. 可重入代码（Reentrant Code）</strong></p><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p><p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="hljs-keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190807154222.png" alt=""></p><p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190807154311.png" alt=""></p><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190807154456.png" alt=""></p><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190807154638.png" alt=""></p><h2 id="多线程开发良好的实践"><a href="#多线程开发良好的实践" class="headerlink" title="多线程开发良好的实践"></a>多线程开发良好的实践</h2><ul><li>给线程起个有意义的名字，这样可以方便找 Bug。</li><li>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</li><li>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</li><li>使用 BlockingQueue 实现生产者消费者问题。</li><li>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</li><li>使用本地变量和不可变类来保证线程安全。</li><li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20并发.md" target="_blank" rel="noopener">参考自来源</a><br>感谢作者的辛勤整理，转载收藏，如有侵权，请评论说明，立即处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。&lt;br&gt;  互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://removeif.github.io/categories/java/"/>
    
      <category term="并发" scheme="https://removeif.github.io/categories/java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发,多线程" scheme="https://removeif.github.io/tags/java-%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 垃圾回收</title>
    <link href="https://removeif.github.io/2019/07/24/Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html"/>
    <id>https://removeif.github.io/2019/07/24/Java-垃圾回收.html</id>
    <published>2019-07-24T06:16:58.000Z</published>
    <updated>2019-08-16T09:13:50.777Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>之前上学的时候有这个一个梗，说在食堂里吃饭，吃完把餐盘端走清理的，是 C++ 程序员，吃完直接就走的，是 Java 程序员。🤔<br><a id="more"></a></p></blockquote><p>之前上学的时候有这个一个梗，说在食堂里吃饭，吃完把餐盘端走清理的，是 C++ 程序员，吃完直接就走的，是 Java 程序员。🤔</p><p>确实，在 Java 的世界里，似乎我们不用对垃圾回收那么的专注，很多初学者不懂 GC，也依然能写出一个能用甚至还不错的程序或系统。但其实这并不代表 Java 的 GC 就不重要。相反，它是那么的重要和复杂，以至于出了问题，那些初学者除了打开 GC 日志，看着一堆0101的天文，啥也做不了。😯</p><p>今天我们就从头到尾完整地聊一聊 Java 的垃圾回收</p><h2 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h2><hr><p>垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。</p><p>Java 语言出来之前，大家都在拼命的写 C 或者 C++ 的程序，而此时存在一个很大的矛盾，C++ 等语言创建对象要不断的去开辟空间，不用的时候又需要不断的去释放控件，既要写构造函数，又要写析构函数，很多时候都在重复的 allocated，然后不停的析构。于是，有人就提出，能不能写一段程序实现这块功能，每次创建，释放控件的时候复用这段代码，而无需重复的书写呢？</p><p>1960年，基于 MIT 的 Lisp 首先提出了垃圾回收的概念，而这时 Java 还没有出世呢！<strong>所以实际上 GC 并不是Java的专利，GC 的历史远远大于 Java 的历史！</strong></p><h2 id="怎么定义垃圾"><a href="#怎么定义垃圾" class="headerlink" title="怎么定义垃圾"></a>怎么定义垃圾</h2><hr><p>既然我们要做垃圾回收，首先我们得搞清楚垃圾的定义是什么，哪些内存是需要回收的。</p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>引用计数算法（Reachability Counting）是通过在对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。如果该对象被其它对象引用，则它的引用计数加1，如果删除对该对象的引用，那么它的引用计数就减1，当该对象的引用计数为0时，那么该对象就会被回收。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String m = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"jack"</span>);</span><br></pre></td></tr></table></figure><p>先创建一个字符串，这时候”jack”有一个引用，就是 m。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190719151851.png" alt=""></p><p>然后将 m 设置为 null，这时候”jack”的引用次数就等于0了，在引用计数算法中，意味着这块内容就需要被回收了。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="hljs-keyword">null</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190719151919.png" alt=""></p><p>引用计数算法是将垃圾回收分摊到整个应用程序的运行当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。因此，采用引用计数的垃圾收集不属于严格意义上的”Stop-The-World”的垃圾收集机制。</p><p>看似很美好，但我们知道JVM的垃圾回收就是”Stop-The-World”的，那是什么原因导致我们最终放弃了引用计数算法呢？看下面的例子。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> Object instance;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReferenceCountingGC</span><span class="hljs-params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGC</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ReferenceCountingGC a = <span class="hljs-keyword">new</span> ReferenceCountingGC(<span class="hljs-string">"objA"</span>);</span><br><span class="line">    ReferenceCountingGC b = <span class="hljs-keyword">new</span> ReferenceCountingGC(<span class="hljs-string">"objB"</span>);</span><br><span class="line"></span><br><span class="line">    a.instance = b;</span><br><span class="line">    b.instance = a;</span><br><span class="line"></span><br><span class="line">    a = <span class="hljs-keyword">null</span>;</span><br><span class="line">    b = <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义2个对象</li><li>相互引用</li><li>置空各自的声明引用</li></ul><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190719152024.png" alt=""></p><p>我们可以看到，最后这2个对象已经不可能再被访问了，但由于他们相互引用着对方，导致它们的引用计数永远都不会为0，通过引用计数算法，也就永远无法通知GC收集器回收它们。</p><p><strong>可达性分析算法</strong></p><p>可达性分析算法（Reachability Analysis）的基本思路是，通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190719152050.png" alt=""></p><p>通过可达性算法，成功解决了引用计数所无法解决的问题-“循环依赖”，只要你无法与 GC Root 建立直接或间接的连接，系统就会判定你为可回收对象。那这样就引申出了另一个问题，哪些属于 GC Root。</p><h2 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h2><p>在 Java 语言中，可作为 GC Root 的对象包括以下4种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190719152138.png" alt=""></p><h3 id="虚拟机栈（栈帧中的本地变量表）中引用的对象"><a href="#虚拟机栈（栈帧中的本地变量表）中引用的对象" class="headerlink" title="虚拟机栈（栈帧中的本地变量表）中引用的对象"></a>虚拟机栈（栈帧中的本地变量表）中引用的对象</h3><p>此时的 s，即为 GC Root，当s置空时，localParameter 对象也断掉了与 GC Root 的引用链，将被回收。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackLocalParameter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StackLocalParameter</span><span class="hljs-params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGC</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    StackLocalParameter s = <span class="hljs-keyword">new</span> StackLocalParameter(<span class="hljs-string">"localParameter"</span>);</span><br><span class="line">    s = <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法区中类静态属性引用的对象"><a href="#方法区中类静态属性引用的对象" class="headerlink" title="方法区中类静态属性引用的对象"></a>方法区中类静态属性引用的对象</h3><p>s 为 GC Root，s 置为 null，经过 GC 后，s 所指向的 properties 对象由于无法与 GC Root 建立关系被回收。</p><p>而 m 作为类的静态属性，也属于 GC Root，parameter 对象依然与 GC root 建立着连接，所以此时 parameter 对象并不会被回收。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAreaStaicProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodAreaStaicProperties m;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MethodAreaStaicProperties</span><span class="hljs-params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGC</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    MethodAreaStaicProperties s = <span class="hljs-keyword">new</span> MethodAreaStaicProperties(<span class="hljs-string">"properties"</span>);</span><br><span class="line">    s.m = <span class="hljs-keyword">new</span> MethodAreaStaicProperties(<span class="hljs-string">"parameter"</span>);</span><br><span class="line">    s = <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法区中常量引用的对象"><a href="#方法区中常量引用的对象" class="headerlink" title="方法区中常量引用的对象"></a>方法区中常量引用的对象</h3><p>m 即为方法区中的常量引用，也为 GC Root，s 置为 null 后，final 对象也不会因没有与 GC Root 建立联系而被回收。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAreaStaicProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MethodAreaStaicProperties m = MethodAreaStaicProperties(<span class="hljs-string">"final"</span>);</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MethodAreaStaicProperties</span><span class="hljs-params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGC</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    MethodAreaStaicProperties s = <span class="hljs-keyword">new</span> MethodAreaStaicProperties(<span class="hljs-string">"staticProperties"</span>);</span><br><span class="line">    s = <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本地方法栈中引用的对象"><a href="#本地方法栈中引用的对象" class="headerlink" title="本地方法栈中引用的对象"></a>本地方法栈中引用的对象</h3><p>任何 Native 接口都会使用某种本地方法栈，实现的本地方法接口是使用 C 连接模型的话，那么它的本地方法栈就是 C 栈。当线程调用 Java 方法时，虚拟机会创建一个新的栈帧并压入 Java 栈。然而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不再在线程的 Java 栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190719152254.png" alt=""></p><h3 id="怎么回收垃圾"><a href="#怎么回收垃圾" class="headerlink" title="怎么回收垃圾"></a>怎么回收垃圾</h3><p>在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，这里我们讨论几种常见的垃圾收集算法的核心思想。</p><h3 id="标记-—-清除算法"><a href="#标记-—-清除算法" class="headerlink" title="标记 — 清除算法"></a>标记 — 清除算法</h3><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190719152406.png" alt=""></p><p>标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分，先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。就像上图一样，清理掉的垃圾就变成未使用的内存区域，等待被再次使用。</p><p>这逻辑再清晰不过了，并且也很好操作，但它存在一个很大的问题，那就是内存碎片。</p><p>上图中等方块的假设是 2M，小一些的是 1M，大一些的是 4M。等我们回收完，内存就会切成了很多段。我们知道开辟内存空间时，需要的是连续的内存区域，这时候我们需要一个 2M的内存区域，其中有2个 1M 是没法用的。这样就导致，其实我们本身还有这么多的内存的，但却用不了。</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190719152712.png" alt=""></p><p>复制算法（Copying）是在标记清除算法上演化而来，解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况，逻辑清晰，运行高效。</p><p>上面的图很清楚，也很明显的暴露了另一个问题，合着我这140平的大三房，只能当70平米的小两房来使？代价实在太高。</p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190719152756.png" alt=""></p><p>标记整理算法（Mark-Compact）标记过程仍然与标记 — 清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</p><p>标记整理算法一方面在标记-清除算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。看起来很美好，但从上图可以看到，它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。</p><p>分代收集算法分代收集算法（Generational Collection）严格来说并不是一种思想或理论，而是融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或者标记 — 整理算法来进行回收。so，另一个问题来了，那内存区域到底被分为哪几块，每一块又有什么特别适合什么算法呢？</p><h3 id="内存模型与回收策略"><a href="#内存模型与回收策略" class="headerlink" title="内存模型与回收策略"></a>内存模型与回收策略</h3><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190719160903.png" alt=""></p><p>Java 堆（Java Heap）是JVM所管理的内存中最大的一块，堆又是垃圾收集器管理的主要区域，这里我们主要分析一下 Java 堆的结构。</p><p>Java 堆主要分为2个区域-年轻代与老年代，其中年轻代又分 Eden 区和 Survivor 区，其中 Survivor 区又分 From 和 To 2个区。可能这时候大家会有疑问，为什么需要 Survivor 区，为什么Survivor 还要分2个区。不着急，我们从头到尾，看看对象到底是怎么来的，而它又是怎么没的。</p><h3 id="Eden-区"><a href="#Eden-区" class="headerlink" title="Eden 区"></a>Eden 区</h3><p>IBM 公司的专业研究表明，有将近98%的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。</p><p>通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。</p><h3 id="Survivor-区"><a href="#Survivor-区" class="headerlink" title="Survivor 区"></a>Survivor 区</h3><p>Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。Survivor 又分为2个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。</p><h3 id="为啥需要？"><a href="#为啥需要？" class="headerlink" title="为啥需要？"></a>为啥需要？</h3><p>不就是新生代到老年代么，直接 Eden 到 Old 不好了吗，为啥要这么复杂。想想如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次 Minor GC 没有消灭，但其实也并不会蹦跶多久，或许第二次，第三次就需要被清除。这时候移入老年区，很明显不是一个明智的决定。</p><p>所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。</p><h3 id="为啥需要俩？"><a href="#为啥需要俩？" class="headerlink" title="为啥需要俩？"></a>为啥需要俩？</h3><p>设置两个 Survivor 区最大的好处就是解决内存碎片化。</p><p>我们先假设一下，Survivor 如果只有一个区域会怎样。Minor GC 执行后，Eden 区被清空了，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。问题来了，这时候我们怎么清除它们？在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为 Survivor 有2个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。</p><p>这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。那么，Survivor 为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果 Survivor 区再细分下去，每一块的空间就会比较小，容易导致 Survivor 区满，两块 Survivor 区可能是经过权衡之后的最佳方案。</p><h3 id="Old-区"><a href="#Old-区" class="headerlink" title="Old 区"></a>Old 区</h3><p>老年代占据着2/3的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代这里采用的是标记 — 整理算法。</p><p>除了上述所说，在内存担保机制下，无法安置的对象会直接进到老年代，以下几种情况也会进入老年代。</p><h3 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h3><p>大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。这样做主要是为了避免在 Eden 区及2个 Survivor 区之间发生大量的内存复制。当你的系统有非常多“朝生夕死”的大对象时，得注意了。</p><h3 id="长期存活对象"><a href="#长期存活对象" class="headerlink" title="长期存活对象"></a>长期存活对象</h3><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加1岁。当年龄增加到15岁时，这时候就会被转移到老年代。当然，这里的15，JVM 也支持进行特殊设置。</p><h3 id="动态对象年龄"><a href="#动态对象年龄" class="headerlink" title="动态对象年龄"></a>动态对象年龄</h3><p>虚拟机并不重视要求对象年龄必须到15岁，才会放入老年区，如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区，无需等你“成年”。</p><p>这其实有点类似于负载均衡，轮询是负载均衡的一种，保证每台机器都分得同样的请求。看似很均衡，但每台机的硬件不通，健康状况不同，我们还可以基于每台机接受的请求数，或每台机的响应时间等，来调整我们的负载均衡算法。</p><p><a href="https://mp.weixin.qq.com/s/x83h2MKCxsHJDpoWbVtnig" target="_blank" rel="noopener">参考自</a></p><p>.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;之前上学的时候有这个一个梗，说在食堂里吃饭，吃完把餐盘端走清理的，是 C++ 程序员，吃完直接就走的，是 Java 程序员。🤔&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://removeif.github.io/categories/java/"/>
    
      <category term="JVM" scheme="https://removeif.github.io/categories/java/JVM/"/>
    
    
      <category term="java" scheme="https://removeif.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java BIO NIO AIO区别与使用</title>
    <link href="https://removeif.github.io/2019/07/19/Java-BIO-NIO-AIO%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8.html"/>
    <id>https://removeif.github.io/2019/07/19/Java-BIO-NIO-AIO区别与使用.html</id>
    <published>2019-07-19T08:19:21.000Z</published>
    <updated>2019-08-16T09:13:50.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>BIO 全称Block-IO 是一种<strong>同步且阻塞</strong>的通信模式。是一个比较传统的通信方式，模式简单，使用方便。但并发处理能力低，通信耗时，依赖网速。<br><a id="more"></a></p></blockquote><h2 id="Java-BIO"><a href="#Java-BIO" class="headerlink" title="Java BIO"></a>Java BIO</h2><p>使用BIO实现文件的读取和写入。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//Initializes The Object</span></span><br><span class="line">User1 user = <span class="hljs-keyword">new</span> User1();</span><br><span class="line">user.setName(<span class="hljs-string">"hollis"</span>);</span><br><span class="line">user.setAge(<span class="hljs-number">23</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//Write Obj to File</span></span><br><span class="line">ObjectOutputStream oos = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"tempFile"</span>));</span><br><span class="line">    oos.writeObject(user);</span><br><span class="line">&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    IOUtils.closeQuietly(oos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//Read Obj from File</span></span><br><span class="line">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"tempFile"</span>);</span><br><span class="line">ObjectInputStream ois = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(file));</span><br><span class="line">    User1 newUser = (User1) ois.readObject();</span><br><span class="line">    System.out.println(newUser);</span><br><span class="line">&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    IOUtils.closeQuietly(ois);</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        FileUtils.forceDelete(file);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><p>Java NIO，全程 Non-Block IO ，是Java SE 1.4版以后，针对网络传输效能优化的新功能。是一种<strong>非阻塞同步</strong>的通信模式。NIO 与原来的 I/O 有同样的作用和目的, 他们之间最重要的区别是数据打包和传输的方式。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。面向流的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。面向块的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readNIO</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        String pathname = <span class="hljs-string">"C:\\Users\\adew\\Desktop\\jd-gui.cfg"</span>;</span><br><span class="line">        FileInputStream fin = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            fin = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(pathname));</span><br><span class="line">            FileChannel channel = fin.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">int</span> capacity = <span class="hljs-number">100</span>;<span class="hljs-comment">// 字节</span></span><br><span class="line">            ByteBuffer bf = ByteBuffer.allocate(capacity);</span><br><span class="line">            <span class="hljs-keyword">int</span> length = -<span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">while</span> ((length = channel.read(bf)) != -<span class="hljs-number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                bf.clear();</span><br><span class="line">                <span class="hljs-keyword">byte</span>[] bytes = bf.array();</span><br><span class="line">                System.out.write(bytes, <span class="hljs-number">0</span>, length);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            channel.close();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (fin != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    fin.close();</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeNIO</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        String filename = <span class="hljs-string">"out.txt"</span>;</span><br><span class="line">        FileOutputStream fos = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(filename));</span><br><span class="line">            FileChannel channel = fos.getChannel();</span><br><span class="line">            ByteBuffer src = Charset.forName(<span class="hljs-string">"utf8"</span>).encode(<span class="hljs-string">"你好你好你好你好你好"</span>);</span><br><span class="line">            <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">while</span> ((length = channel.write(src)) != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"写入长度:"</span> + length);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (fos != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Java-AIO"><a href="#Java-AIO" class="headerlink" title="Java AIO"></a>Java AIO</h2><p>Java AIO，全程 Asynchronous IO，是<strong>异步非阻塞</strong>的IO。是一种非阻塞异步的通信模式。在NIO的基础上引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadFromFile</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Path file = Paths.get(<span class="hljs-string">"/usr/a.txt"</span>);</span><br><span class="line">    AsynchronousFileChannel channel = AsynchronousFileChannel.open(file);</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">100_000</span>);</span><br><span class="line">    Future&lt;Integer&gt; result = channel.read(buffer, <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">while</span> (!result.isDone()) &#123;</span><br><span class="line">      ProfitCalculator.calculateTax();</span><br><span class="line">    &#125;</span><br><span class="line">    Integer bytesRead = result.get();</span><br><span class="line">    System.out.println(<span class="hljs-string">"Bytes read ["</span> + bytesRead + <span class="hljs-string">"]"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfitCalculator</span> </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProfitCalculator</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculateTax</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteToFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(</span><br><span class="line">        Paths.get(<span class="hljs-string">"/asynchronous.txt"</span>), StandardOpenOption.READ,</span><br><span class="line">        StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line">    CompletionHandler&lt;Integer, Object&gt; handler = <span class="hljs-keyword">new</span> CompletionHandler&lt;Integer, Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-meta">@Override</span></span><br><span class="line">      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(Integer result, Object attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"Attachment: "</span> + attachment + <span class="hljs-string">" "</span> + result</span><br><span class="line">            + <span class="hljs-string">" bytes written"</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"CompletionHandler Thread ID: "</span></span><br><span class="line">            + Thread.currentThread().getId());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-meta">@Override</span></span><br><span class="line">      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable e, Object attachment)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="hljs-string">"Attachment: "</span> + attachment + <span class="hljs-string">" failed with:"</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="hljs-string">"Main Thread ID: "</span> + Thread.currentThread().getId());</span><br><span class="line">    fileChannel.write(ByteBuffer.wrap(<span class="hljs-string">"Sample"</span>.getBytes()), <span class="hljs-number">0</span>, <span class="hljs-string">"First Write"</span>,</span><br><span class="line">        handler);</span><br><span class="line">    fileChannel.write(ByteBuffer.wrap(<span class="hljs-string">"Box"</span>.getBytes()), <span class="hljs-number">0</span>, <span class="hljs-string">"Second Write"</span>,</span><br><span class="line">        handler);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三种IO的区别"><a href="#三种IO的区别" class="headerlink" title="三种IO的区别"></a>三种IO的区别</h2><p>首先，我们站在宏观的角度，重新画一下重点：</p><p><strong>BIO （Blocking I/O）：同步阻塞I/O模式。</strong></p><p><strong>NIO （New I/O）：同步非阻塞模式。</strong></p><p><strong>AIO （Asynchronous I/O）：异步非阻塞I/O模型。</strong></p><p><strong>同步请求</strong>，A调用B，B的处理是同步的，在处理完之前他不会通知A，只有处理完之后才会明确的通知A。</p><p><strong>异步请求</strong>，A调用B，B的处理是异步的，B在接到请求后先告诉A我已经接到请求了，然后异步去处理，处理完之后通过回调等方式再通知A。</p><p>所以说，同步和异步最大的区别就是被调用方的执行方式和返回时机。同步指的是被调用方做完事情之后再返回，异步指的是被调用方先返回，然后再做事情，做完之后再想办法通知调用方。</p><p><strong>阻塞请求</strong>，A调用B，A一直等着B的返回，别的事情什么也不干。</p><p><strong>非阻塞请求</strong>，A调用B，A不用一直等着B的返回，先去忙别的事情了。</p><p>所以说，阻塞非阻塞最大的区别就是在被调用方返回结果之前的这段时间内，调用方是否一直等待。阻塞指的是调用方一直等待别的事情什么都不做。非阻塞指的是调用方先去忙别的事情。</p><p><strong>同步阻塞模式</strong>：这种模式下，我们的工作模式是先来到厨房，开始烧水，并坐在水壶面前一直等着水烧开。</p><p><strong>同步非阻塞模式</strong>：这种模式下，我们的工作模式是先来到厨房，开始烧水，但是我们不一直坐在水壶前面等，而是回到客厅看电视，然后每隔几分钟到厨房看一下水有没有烧开。</p><p><strong>异步非阻塞I/O模型</strong>：这种模式下，我们的工作模式是先来到厨房，开始烧水，我们不一一直坐在水壶前面等，也不隔一段时间去看一下，而是在客厅看电视，水壶上面有个开关，水烧开之后他会通知我。</p><p><strong>阻塞VS非阻塞</strong>：人是否坐在水壶前面一直等。</p><p><strong>同步VS异步</strong>：水壶是不是在水烧开之后主动通知人。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p><p>AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&amp;mid=2247485960&amp;idx=1&amp;sn=83d418c498c2d6df102bd227c9e5c7ff&amp;chksm=cef5f9bef98270a8e5cbd23280fb211362c7ff17dcf8894df71ba42692348c8f99e101a3c35d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">参考自</a></p><p>.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;BIO 全称Block-IO 是一种&lt;strong&gt;同步且阻塞&lt;/strong&gt;的通信模式。是一个比较传统的通信方式，模式简单，使用方便。但并发处理能力低，通信耗时，依赖网速。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://removeif.github.io/categories/java/"/>
    
      <category term="java基础" scheme="https://removeif.github.io/categories/java/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://removeif.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>常见sql错误写法</title>
    <link href="https://removeif.github.io/2019/07/05/%E5%B8%B8%E8%A7%81sql%E9%94%99%E8%AF%AF%E5%86%99%E6%B3%95.html"/>
    <id>https://removeif.github.io/2019/07/05/常见sql错误写法.html</id>
    <published>2019-07-05T08:05:12.000Z</published>
    <updated>2019-08-16T09:13:50.781Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>sql语句应用不当，可能仅仅一个顺序的不同，往往会带来成千上万倍的耗时问题。<br><a id="more"></a></p></blockquote><h3 id="1、LIMIT-语句"><a href="#1、LIMIT-语句" class="headerlink" title="1、LIMIT 语句"></a><strong>1、LIMIT 语句</strong></h3><p>分页查询是最常用的场景之一，但也通常也是最容易出问题的地方。比如对于下面简单的语句，一般 DBA 想到的办法是在 type, name, create_time 字段上加组合索引。这样条件排序都能有效的利用到索引，性能迅速提升。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * </span><br><span class="line"><span class="hljs-keyword">FROM</span>   operation </span><br><span class="line"><span class="hljs-keyword">WHERE</span>  <span class="hljs-keyword">type</span> = <span class="hljs-string">'SQLStats'</span> </span><br><span class="line">       <span class="hljs-keyword">AND</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'SlowLog'</span> </span><br><span class="line"><span class="hljs-keyword">ORDER</span>  <span class="hljs-keyword">BY</span> create_time </span><br><span class="line"><span class="hljs-keyword">LIMIT</span>  <span class="hljs-number">1000</span>, <span class="hljs-number">10</span>;</span><br></pre></td></tr></table></figure><p>好吧，可能90%以上的 DBA 解决该问题就到此为止。但当 LIMIT 子句变成 “LIMIT 1000000,10” 时，程序员仍然会抱怨：我只取10条记录为什么还是慢？</p><p>要知道数据库也并不知道第1000000条记录从什么地方开始，即使有索引也需要从头计算一次。出现这种性能问题，多数情形下是程序员偷懒了。</p><p>在前端数据浏览翻页，或者大数据分批导出等场景下，是可以将上一页的最大值当成参数作为查询条件的。SQL 重新设计如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span>   * </span><br><span class="line"><span class="hljs-keyword">FROM</span>     operation </span><br><span class="line"><span class="hljs-keyword">WHERE</span>    <span class="hljs-keyword">type</span> = <span class="hljs-string">'SQLStats'</span> </span><br><span class="line"><span class="hljs-keyword">AND</span>      <span class="hljs-keyword">name</span> = <span class="hljs-string">'SlowLog'</span> </span><br><span class="line"><span class="hljs-keyword">AND</span>      create_time &gt; <span class="hljs-string">'2017-03-16 14:00:00'</span> </span><br><span class="line"><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> create_time <span class="hljs-keyword">limit</span> <span class="hljs-number">10</span>;</span><br></pre></td></tr></table></figure><p>在新设计下查询时间基本固定，不会随着数据量的增长而发生变化。</p><h3 id="2、隐式转换"><a href="#2、隐式转换" class="headerlink" title="2、隐式转换"></a><strong>2、隐式转换</strong></h3><p>SQL语句中查询变量和字段定义类型不匹配是另一个常见的错误。比如下面的语句：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain extended SELECT * </span><br><span class="line">     &gt; FROM   my_balance b </span><br><span class="line">     &gt; WHERE  b.bpn = 14000000123 </span><br><span class="line">     &gt;       AND b.isverified IS NULL ;</span><br><span class="line">mysql&gt; show warnings;</span><br><span class="line">| Warning | 1739 | Cannot <span class="hljs-keyword">use</span> <span class="hljs-keyword">ref</span> <span class="hljs-keyword">access</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">index</span> <span class="hljs-string">'bpn'</span> due <span class="hljs-keyword">to</span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">collation</span> conversion <span class="hljs-keyword">on</span> <span class="hljs-keyword">field</span> <span class="hljs-string">'bpn'</span></span><br></pre></td></tr></table></figure><p>其中字段 bpn 的定义为 varchar(20)，MySQL 的策略是将字符串转换为数字之后再比较。函数作用于表字段，索引失效。</p><p>上述情况可能是应用程序框架自动填入的参数，而不是程序员的原意。现在应用框架很多很繁杂，使用方便的同时也小心它可能给自己挖坑。</p><h3 id="3、关联更新、删除"><a href="#3、关联更新、删除" class="headerlink" title="3、关联更新、删除"></a><strong>3、关联更新、删除</strong></h3><p>虽然 MySQL5.6 引入了物化特性，但需要特别注意它目前仅仅针对查询语句的优化。对于更新或删除需要手工重写成 JOIN。</p><p>比如下面 UPDATE 语句，MySQL 实际执行的是循环/嵌套子查询（DEPENDENT SUBQUERY)，其执行时间可想而知。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> operation o </span><br><span class="line"><span class="hljs-keyword">SET</span>    <span class="hljs-keyword">status</span> = <span class="hljs-string">'applying'</span> </span><br><span class="line"><span class="hljs-keyword">WHERE</span>  o.id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> </span><br><span class="line">                <span class="hljs-keyword">FROM</span>   (<span class="hljs-keyword">SELECT</span> o.id, </span><br><span class="line">                               o.status </span><br><span class="line">                        <span class="hljs-keyword">FROM</span>   operation o </span><br><span class="line">                        <span class="hljs-keyword">WHERE</span>  o.group = <span class="hljs-number">123</span> </span><br><span class="line">                               <span class="hljs-keyword">AND</span> o.status <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> ( <span class="hljs-string">'done'</span> ) </span><br><span class="line">                        <span class="hljs-keyword">ORDER</span>  <span class="hljs-keyword">BY</span> o.parent, </span><br><span class="line">                                  o.id </span><br><span class="line">                        <span class="hljs-keyword">LIMIT</span>  <span class="hljs-number">1</span>) t);</span><br></pre></td></tr></table></figure><p>执行计划：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+<span class="hljs-comment">----+--------------------+-------+-------+---------------+---------+---------+-------+------+-----------------------------------------------------+</span></span><br><span class="line">| id | select_type        | table | type  | possible_keys | key     | key_len | ref   | rows | Extra                                               |</span><br><span class="line">+<span class="hljs-comment">----+--------------------+-------+-------+---------------+---------+---------+-------+------+-----------------------------------------------------+</span></span><br><span class="line">| 1  | PRIMARY            | o     | index |               | PRIMARY | 8       |       | 24   | Using where; Using temporary                        |</span><br><span class="line">| 2  | DEPENDENT SUBQUERY |       |       |               |         |         |       |      | Impossible WHERE noticed after reading const tables |</span><br><span class="line">| 3  | DERIVED            | o     | ref   | idx_2,idx_5   | idx_5   | 8       | const | 1    | Using where; Using filesort                         |</span><br><span class="line">+<span class="hljs-comment">----+--------------------+-------+-------+---------------+---------+---------+-------+------+-----------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>重写为 JOIN 之后，子查询的选择模式从 DEPENDENT SUBQUERY 变成 DERIVED，执行速度大大加快，从7秒降低到2毫秒。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">UPDATE</span> operation o </span><br><span class="line">       <span class="hljs-keyword">JOIN</span>  (<span class="hljs-keyword">SELECT</span> o.id, </span><br><span class="line">                            o.status </span><br><span class="line">                     <span class="hljs-keyword">FROM</span>   operation o </span><br><span class="line">                     <span class="hljs-keyword">WHERE</span>  o.group = <span class="hljs-number">123</span> </span><br><span class="line">                            <span class="hljs-keyword">AND</span> o.status <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> ( <span class="hljs-string">'done'</span> ) </span><br><span class="line">                     <span class="hljs-keyword">ORDER</span>  <span class="hljs-keyword">BY</span> o.parent, </span><br><span class="line">                               o.id </span><br><span class="line">                     <span class="hljs-keyword">LIMIT</span>  <span class="hljs-number">1</span>) t</span><br><span class="line">         <span class="hljs-keyword">ON</span> o.id = t.id </span><br><span class="line"><span class="hljs-keyword">SET</span>    <span class="hljs-keyword">status</span> = <span class="hljs-string">'applying'</span></span><br></pre></td></tr></table></figure><p>执行计划简化为：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="hljs-comment">----+-------------+-------+------+---------------+-------+---------+-------+------+-----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key   | key_len | ref   | rows | Extra                                               |</span><br><span class="line">+<span class="hljs-comment">----+-------------+-------+------+---------------+-------+---------+-------+------+-----------------------------------------------------+</span></span><br><span class="line">| 1  | PRIMARY     |       |      |               |       |         |       |      | Impossible WHERE noticed after reading const tables |</span><br><span class="line">| 2  | DERIVED     | o     | ref  | idx_2,idx_5   | idx_5 | 8       | const | 1    | Using where; Using filesort                         |</span><br><span class="line">+<span class="hljs-comment">----+-------------+-------+------+---------------+-------+---------+-------+------+-----------------------------------------------------+</span></span><br></pre></td></tr></table></figure><h3 id="4、混合排序"><a href="#4、混合排序" class="headerlink" title="4、混合排序"></a><strong>4、混合排序</strong></h3><p>MySQL 不能利用索引进行混合排序。但在某些场景，还是有机会使用特殊方法提升性能的。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * </span><br><span class="line"><span class="hljs-keyword">FROM</span>   my_order o </span><br><span class="line">       <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> my_appraise a <span class="hljs-keyword">ON</span> a.orderid = o.id </span><br><span class="line"><span class="hljs-keyword">ORDER</span>  <span class="hljs-keyword">BY</span> a.is_reply <span class="hljs-keyword">ASC</span>, </span><br><span class="line">          a.appraise_time <span class="hljs-keyword">DESC</span> </span><br><span class="line"><span class="hljs-keyword">LIMIT</span>  <span class="hljs-number">0</span>, <span class="hljs-number">20</span></span><br></pre></td></tr></table></figure><p>执行计划显示为全表扫描：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="hljs-comment">----+-------------+-------+--------+-------------+---------+---------+---------------+---------+-+</span></span><br><span class="line">| id | select_type | table | type   | possible_keys     | key     | key_len | ref      | rows    | Extra    </span><br><span class="line">+<span class="hljs-comment">----+-------------+-------+--------+-------------+---------+---------+---------------+---------+-+</span></span><br><span class="line">|  1 | SIMPLE      | a     | ALL    | idx_orderid | NULL    | NULL    | NULL    | 1967647 | Using filesort |</span><br><span class="line">|  1 | SIMPLE      | o     | eq_ref | PRIMARY     | PRIMARY | 122     | a.orderid |       1 | NULL           |</span><br><span class="line">+<span class="hljs-comment">----+-------------+-------+--------+---------+---------+---------+-----------------+---------+-+</span></span><br></pre></td></tr></table></figure><p>由于 is_reply 只有0和1两种状态，我们按照下面的方法重写后，执行时间从1.58秒降低到2毫秒。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * </span><br><span class="line"><span class="hljs-keyword">FROM</span>   ((<span class="hljs-keyword">SELECT</span> *</span><br><span class="line">         <span class="hljs-keyword">FROM</span>   my_order o </span><br><span class="line">                <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> my_appraise a </span><br><span class="line">                        <span class="hljs-keyword">ON</span> a.orderid = o.id </span><br><span class="line">                           <span class="hljs-keyword">AND</span> is_reply = <span class="hljs-number">0</span> </span><br><span class="line">         <span class="hljs-keyword">ORDER</span>  <span class="hljs-keyword">BY</span> appraise_time <span class="hljs-keyword">DESC</span> </span><br><span class="line">         <span class="hljs-keyword">LIMIT</span>  <span class="hljs-number">0</span>, <span class="hljs-number">20</span>) </span><br><span class="line">        <span class="hljs-keyword">UNION</span> ALL </span><br><span class="line">        (<span class="hljs-keyword">SELECT</span> *</span><br><span class="line">         <span class="hljs-keyword">FROM</span>   my_order o </span><br><span class="line">                <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> my_appraise a </span><br><span class="line">                        <span class="hljs-keyword">ON</span> a.orderid = o.id </span><br><span class="line">                           <span class="hljs-keyword">AND</span> is_reply = <span class="hljs-number">1</span> </span><br><span class="line">         <span class="hljs-keyword">ORDER</span>  <span class="hljs-keyword">BY</span> appraise_time <span class="hljs-keyword">DESC</span> </span><br><span class="line">         <span class="hljs-keyword">LIMIT</span>  <span class="hljs-number">0</span>, <span class="hljs-number">20</span>)) t </span><br><span class="line"><span class="hljs-keyword">ORDER</span>  <span class="hljs-keyword">BY</span>  is_reply <span class="hljs-keyword">ASC</span>, </span><br><span class="line">          appraisetime <span class="hljs-keyword">DESC</span> </span><br><span class="line"><span class="hljs-keyword">LIMIT</span>  <span class="hljs-number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="5、EXISTS语句"><a href="#5、EXISTS语句" class="headerlink" title="5、EXISTS语句"></a><strong>5、EXISTS语句</strong></h3><p>MySQL 对待 EXISTS 子句时，仍然采用嵌套子查询的执行方式。如下面的 SQL 语句：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> *</span><br><span class="line"><span class="hljs-keyword">FROM</span>   my_neighbor n </span><br><span class="line">       <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> my_neighbor_apply sra </span><br><span class="line">              <span class="hljs-keyword">ON</span> n.id = sra.neighbor_id </span><br><span class="line">                 <span class="hljs-keyword">AND</span> sra.user_id = <span class="hljs-string">'xxx'</span> </span><br><span class="line"><span class="hljs-keyword">WHERE</span>  n.topic_status &lt; <span class="hljs-number">4</span> </span><br><span class="line">       <span class="hljs-keyword">AND</span> <span class="hljs-keyword">EXISTS</span>(<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> </span><br><span class="line">                  <span class="hljs-keyword">FROM</span>   message_info m </span><br><span class="line">                  <span class="hljs-keyword">WHERE</span>  n.id = m.neighbor_id </span><br><span class="line">                         <span class="hljs-keyword">AND</span> m.inuser = <span class="hljs-string">'xxx'</span>) </span><br><span class="line">       <span class="hljs-keyword">AND</span> n.topic_type &lt;&gt; <span class="hljs-number">5</span></span><br></pre></td></tr></table></figure><p>执行计划为：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+<span class="hljs-comment">----+--------------------+-------+------+-----+------------------------------------------+---------+-------+---------+ -----+</span></span><br><span class="line">| id | select_type        | table | type | possible_keys     | key   | key_len | ref   | rows    | Extra   |</span><br><span class="line">+<span class="hljs-comment">----+--------------------+-------+------+ -----+------------------------------------------+---------+-------+---------+ -----+</span></span><br><span class="line">|  1 | PRIMARY            | n     | ALL  |  | NULL     | NULL    | NULL  | 1086041 | Using where                   |</span><br><span class="line">|  1 | PRIMARY            | sra   | ref  |  | idx_user_id | 123     | const |       1 | Using where          |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | m     | ref  |  | idx_message_info   | 122     | const |       1 | Using index condition; Using where |</span><br><span class="line">+<span class="hljs-comment">----+--------------------+-------+------+ -----+------------------------------------------+---------+-------+---------+ -----+</span></span><br></pre></td></tr></table></figure><p>去掉 exists 更改为 join，能够避免嵌套子查询，将执行时间从1.93秒降低为1毫秒。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> *</span><br><span class="line"><span class="hljs-keyword">FROM</span>   my_neighbor n </span><br><span class="line">       <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> message_info m </span><br><span class="line">               <span class="hljs-keyword">ON</span> n.id = m.neighbor_id </span><br><span class="line">                  <span class="hljs-keyword">AND</span> m.inuser = <span class="hljs-string">'xxx'</span> </span><br><span class="line">       <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> my_neighbor_apply sra </span><br><span class="line">              <span class="hljs-keyword">ON</span> n.id = sra.neighbor_id </span><br><span class="line">                 <span class="hljs-keyword">AND</span> sra.user_id = <span class="hljs-string">'xxx'</span> </span><br><span class="line"><span class="hljs-keyword">WHERE</span>  n.topic_status &lt; <span class="hljs-number">4</span> </span><br><span class="line">       <span class="hljs-keyword">AND</span> n.topic_type &lt;&gt; <span class="hljs-number">5</span></span><br></pre></td></tr></table></figure><p>新的执行计划：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+<span class="hljs-comment">----+-------------+-------+--------+ -----+------------------------------------------+---------+ -----+------+ -----+</span></span><br><span class="line">| id | select_type | table | type   | possible_keys     | key       | key_len | ref   | rows | Extra                 |</span><br><span class="line">+<span class="hljs-comment">----+-------------+-------+--------+ -----+------------------------------------------+---------+ -----+------+ -----+</span></span><br><span class="line">|  1 | SIMPLE      | m     | ref    | | idx_message_info   | 122     | const    |    1 | Using index condition |</span><br><span class="line">|  1 | SIMPLE      | n     | eq_ref | | PRIMARY   | 122     | ighbor_id |    1 | Using where      |</span><br><span class="line">|  1 | SIMPLE      | sra   | ref    | | idx_user_id | 123     | const     |    1 | Using where           |</span><br><span class="line">+<span class="hljs-comment">----+-------------+-------+--------+ -----+------------------------------------------+---------+ -----+------+ -----+</span></span><br></pre></td></tr></table></figure><h3 id="6、条件下推"><a href="#6、条件下推" class="headerlink" title="6、条件下推"></a><strong>6、条件下推</strong></h3><p>外部查询条件不能够下推到复杂的视图或子查询的情况有：</p><ul><li>聚合子查询；</li><li>含有 LIMIT 的子查询；</li><li>UNION 或 UNION ALL 子查询；</li><li>输出字段中的子查询；</li></ul><p>如下面的语句，从执行计划可以看出其条件作用于聚合子查询之后：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * </span><br><span class="line"><span class="hljs-keyword">FROM</span>   (<span class="hljs-keyword">SELECT</span> target, </span><br><span class="line">               <span class="hljs-keyword">Count</span>(*) </span><br><span class="line">        <span class="hljs-keyword">FROM</span>   operation </span><br><span class="line">        <span class="hljs-keyword">GROUP</span>  <span class="hljs-keyword">BY</span> target) t </span><br><span class="line"><span class="hljs-keyword">WHERE</span>  target = <span class="hljs-string">'rm-xxxx'</span></span><br></pre></td></tr></table></figure><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="hljs-comment">----+-------------+------------+-------+---------------+-------------+---------+-------+------+-------------+</span></span><br><span class="line">| id | select_type | table      | type  | possible_keys | key         | key_len | ref   | rows | Extra       |</span><br><span class="line">+<span class="hljs-comment">----+-------------+------------+-------+---------------+-------------+---------+-------+------+-------------+</span></span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | ref   | &lt;auto_key0&gt;   | &lt;auto_key0&gt; | 514     | const |    2 | Using where |</span><br><span class="line">|  2 | DERIVED     | operation  | index | idx_4         | idx_4       | 519     | NULL  |   20 | Using index |</span><br><span class="line">+<span class="hljs-comment">----+-------------+------------+-------+---------------+-------------+---------+-------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>确定从语义上查询条件可以直接下推后，重写如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> target, </span><br><span class="line">       <span class="hljs-keyword">Count</span>(*) </span><br><span class="line"><span class="hljs-keyword">FROM</span>   operation </span><br><span class="line"><span class="hljs-keyword">WHERE</span>  target = <span class="hljs-string">'rm-xxxx'</span> </span><br><span class="line"><span class="hljs-keyword">GROUP</span>  <span class="hljs-keyword">BY</span> target</span><br></pre></td></tr></table></figure><p>执行计划变为：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="hljs-comment">----+-------------+-----------+------+---------------+-------+---------+-------+------+--------------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |</span><br><span class="line">+<span class="hljs-comment">----+-------------+-----------+------+---------------+-------+---------+-------+------+--------------------+</span></span><br><span class="line">| 1 | SIMPLE | operation | ref | idx_4 | idx_4 | 514 | const | 1 | Using where; Using index |</span><br><span class="line">+<span class="hljs-comment">----+-------------+-----------+------+---------------+-------+---------+-------+------+--------------------+</span></span><br></pre></td></tr></table></figure><p>关于 MySQL 外部条件不能下推的详细解释说明请<a href="http://mysql.taobao.org/monthly/2016/07/08" target="_blank" rel="noopener">参考文章</a>：</p><h3 id="7、提前缩小范围"><a href="#7、提前缩小范围" class="headerlink" title="7、提前缩小范围"></a><strong>7、提前缩小范围</strong></h3><p>先上初始 SQL 语句：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * </span><br><span class="line"><span class="hljs-keyword">FROM</span>   my_order o </span><br><span class="line">       <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> my_userinfo u </span><br><span class="line">              <span class="hljs-keyword">ON</span> o.uid = u.uid</span><br><span class="line">       <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> my_productinfo p </span><br><span class="line">              <span class="hljs-keyword">ON</span> o.pid = p.pid </span><br><span class="line"><span class="hljs-keyword">WHERE</span>  ( o.display = <span class="hljs-number">0</span> ) </span><br><span class="line">       <span class="hljs-keyword">AND</span> ( o.ostaus = <span class="hljs-number">1</span> ) </span><br><span class="line"><span class="hljs-keyword">ORDER</span>  <span class="hljs-keyword">BY</span> o.selltime <span class="hljs-keyword">DESC</span> </span><br><span class="line"><span class="hljs-keyword">LIMIT</span>  <span class="hljs-number">0</span>, <span class="hljs-number">15</span></span><br></pre></td></tr></table></figure><p>该SQL语句原意是：先做一系列的左连接，然后排序取前15条记录。从执行计划也可以看出，最后一步估算排序记录数为90万，时间消耗为12秒。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+<span class="hljs-comment">----+-------------+-------+--------+---------------+---------+---------+-----------------+--------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | type   | possible_keys | key     | key_len | ref             | rows   | Extra                                              |</span><br><span class="line">+<span class="hljs-comment">----+-------------+-------+--------+---------------+---------+---------+-----------------+--------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | o     | ALL    | NULL          | NULL    | NULL    | NULL            | 909119 | Using where; Using temporary; Using filesort       |</span><br><span class="line">|  1 | SIMPLE      | u     | eq_ref | PRIMARY       | PRIMARY | 4       | o.uid |      1 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | p     | ALL    | PRIMARY       | NULL    | NULL    | NULL            |      6 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="hljs-comment">----+-------------+-------+--------+---------------+---------+---------+-----------------+--------+----------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>由于最后 WHERE 条件以及排序均针对最左主表，因此可以先对 my_order 排序提前缩小数据量再做左连接。SQL 重写后如下，执行时间缩小为1毫秒左右。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * </span><br><span class="line"><span class="hljs-keyword">FROM</span> (</span><br><span class="line"><span class="hljs-keyword">SELECT</span> * </span><br><span class="line"><span class="hljs-keyword">FROM</span>   my_order o </span><br><span class="line"><span class="hljs-keyword">WHERE</span>  ( o.display = <span class="hljs-number">0</span> ) </span><br><span class="line">       <span class="hljs-keyword">AND</span> ( o.ostaus = <span class="hljs-number">1</span> ) </span><br><span class="line"><span class="hljs-keyword">ORDER</span>  <span class="hljs-keyword">BY</span> o.selltime <span class="hljs-keyword">DESC</span> </span><br><span class="line"><span class="hljs-keyword">LIMIT</span>  <span class="hljs-number">0</span>, <span class="hljs-number">15</span></span><br><span class="line">) o </span><br><span class="line">     <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> my_userinfo u </span><br><span class="line">              <span class="hljs-keyword">ON</span> o.uid = u.uid </span><br><span class="line">     <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> my_productinfo p </span><br><span class="line">              <span class="hljs-keyword">ON</span> o.pid = p.pid </span><br><span class="line"><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  o.selltime <span class="hljs-keyword">DESC</span></span><br><span class="line"><span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>, <span class="hljs-number">15</span></span><br></pre></td></tr></table></figure><p>再检查执行计划：子查询物化后（select_type=DERIVED)参与 JOIN。虽然估算行扫描仍然为90万，但是利用了索引以及 LIMIT 子句后，实际执行时间变得很小。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="hljs-comment">----+-------------+------------+--------+---------------+---------+---------+-------+--------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table      | type   | possible_keys | key     | key_len | ref   | rows   | Extra                                              |</span><br><span class="line">+<span class="hljs-comment">----+-------------+------------+--------+---------------+---------+---------+-------+--------+----------------------------------------------------+</span></span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | ALL    | NULL          | NULL    | NULL    | NULL  |     15 | Using temporary; Using filesort                    |</span><br><span class="line">|  1 | PRIMARY     | u          | eq_ref | PRIMARY       | PRIMARY | 4       | o.uid |      1 | NULL                                               |</span><br><span class="line">|  1 | PRIMARY     | p          | ALL    | PRIMARY       | NULL    | NULL    | NULL  |      6 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">|  2 | DERIVED     | o          | index  | NULL          | idx_1   | 5       | NULL  | 909112 | Using where                                        |</span><br><span class="line">+<span class="hljs-comment">----+-------------+------------+--------+---------------+---------+---------+-------+--------+----------------------------------------------------+</span></span><br></pre></td></tr></table></figure><h3 id="8、中间结果集下推"><a href="#8、中间结果集下推" class="headerlink" title="8、中间结果集下推"></a><strong>8、中间结果集下推</strong></h3><p>再来看下面这个已经初步优化过的例子(左连接中的主表优先作用查询条件)：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span>    a.*, </span><br><span class="line">          c.allocated </span><br><span class="line"><span class="hljs-keyword">FROM</span>      ( </span><br><span class="line">              <span class="hljs-keyword">SELECT</span>   resourceid </span><br><span class="line">              <span class="hljs-keyword">FROM</span>     my_distribute d </span><br><span class="line">                   <span class="hljs-keyword">WHERE</span>    isdelete = <span class="hljs-number">0</span> </span><br><span class="line">                   <span class="hljs-keyword">AND</span>      cusmanagercode = <span class="hljs-string">'1234567'</span> </span><br><span class="line">                   <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salecode <span class="hljs-keyword">limit</span> <span class="hljs-number">20</span>) a </span><br><span class="line"><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> </span><br><span class="line">          ( </span><br><span class="line">              <span class="hljs-keyword">SELECT</span>   resourcesid， <span class="hljs-keyword">sum</span>(<span class="hljs-keyword">ifnull</span>(allocation, <span class="hljs-number">0</span>) * <span class="hljs-number">12345</span>) allocated </span><br><span class="line">              <span class="hljs-keyword">FROM</span>     my_resources </span><br><span class="line">                   <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> resourcesid) c </span><br><span class="line"><span class="hljs-keyword">ON</span>        a.resourceid = c.resourcesid</span><br></pre></td></tr></table></figure><p>那么该语句还存在其它问题吗？不难看出子查询 c 是全表聚合查询，在表数量特别大的情况下会导致整个语句的性能下降。</p><p>其实对于子查询 c，左连接最后结果集只关心能和主表 resourceid 能匹配的数据。因此我们可以重写语句如下，执行时间从原来的2秒下降到2毫秒。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span>    a.*, </span><br><span class="line">          c.allocated </span><br><span class="line"><span class="hljs-keyword">FROM</span>      ( </span><br><span class="line">                   <span class="hljs-keyword">SELECT</span>   resourceid </span><br><span class="line">                   <span class="hljs-keyword">FROM</span>     my_distribute d </span><br><span class="line">                   <span class="hljs-keyword">WHERE</span>    isdelete = <span class="hljs-number">0</span> </span><br><span class="line">                   <span class="hljs-keyword">AND</span>      cusmanagercode = <span class="hljs-string">'1234567'</span> </span><br><span class="line">                   <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salecode <span class="hljs-keyword">limit</span> <span class="hljs-number">20</span>) a </span><br><span class="line"><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> </span><br><span class="line">          ( </span><br><span class="line">                   <span class="hljs-keyword">SELECT</span>   resourcesid， <span class="hljs-keyword">sum</span>(<span class="hljs-keyword">ifnull</span>(allocation, <span class="hljs-number">0</span>) * <span class="hljs-number">12345</span>) allocated </span><br><span class="line">                   <span class="hljs-keyword">FROM</span>     my_resources r, </span><br><span class="line">                            ( </span><br><span class="line">                                     <span class="hljs-keyword">SELECT</span>   resourceid </span><br><span class="line">                                     <span class="hljs-keyword">FROM</span>     my_distribute d </span><br><span class="line">                                     <span class="hljs-keyword">WHERE</span>    isdelete = <span class="hljs-number">0</span> </span><br><span class="line">                                     <span class="hljs-keyword">AND</span>      cusmanagercode = <span class="hljs-string">'1234567'</span> </span><br><span class="line">                                     <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salecode <span class="hljs-keyword">limit</span> <span class="hljs-number">20</span>) a </span><br><span class="line">                   <span class="hljs-keyword">WHERE</span>    r.resourcesid = a.resourcesid </span><br><span class="line">                   <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> resourcesid) c </span><br><span class="line"><span class="hljs-keyword">ON</span>        a.resourceid = c.resourcesid</span><br></pre></td></tr></table></figure><p>但是子查询 a 在我们的SQL语句中出现了多次。这种写法不仅存在额外的开销，还使得整个语句显的繁杂。使用 WITH 语句再次重写：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">WITH</span> a <span class="hljs-keyword">AS</span> </span><br><span class="line">( </span><br><span class="line">         <span class="hljs-keyword">SELECT</span>   resourceid </span><br><span class="line">         <span class="hljs-keyword">FROM</span>     my_distribute d </span><br><span class="line">         <span class="hljs-keyword">WHERE</span>    isdelete = <span class="hljs-number">0</span> </span><br><span class="line">         <span class="hljs-keyword">AND</span>      cusmanagercode = <span class="hljs-string">'1234567'</span> </span><br><span class="line">         <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salecode <span class="hljs-keyword">limit</span> <span class="hljs-number">20</span>)</span><br><span class="line"><span class="hljs-keyword">SELECT</span>    a.*, </span><br><span class="line">          c.allocated </span><br><span class="line"><span class="hljs-keyword">FROM</span>      a </span><br><span class="line"><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> </span><br><span class="line">          ( </span><br><span class="line">                   <span class="hljs-keyword">SELECT</span>   resourcesid， <span class="hljs-keyword">sum</span>(<span class="hljs-keyword">ifnull</span>(allocation, <span class="hljs-number">0</span>) * <span class="hljs-number">12345</span>) allocated </span><br><span class="line">                   <span class="hljs-keyword">FROM</span>     my_resources r, </span><br><span class="line">                            a </span><br><span class="line">                   <span class="hljs-keyword">WHERE</span>    r.resourcesid = a.resourcesid </span><br><span class="line">                   <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> resourcesid) c </span><br><span class="line"><span class="hljs-keyword">ON</span>        a.resourceid = c.resourcesid</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>数据库编译器产生执行计划，决定着SQL的实际执行方式。但是编译器只是尽力服务，所有数据库的编译器都不是尽善尽美的。</p><p>上述提到的多数场景，在其它数据库中也存在性能问题。了解数据库编译器的特性，才能避规其短处，写出高性能的SQL语句。</p><p>程序员在设计数据模型以及编写SQL语句时，要把算法的思想或意识带进来。</p><p>编写复杂SQL语句要养成使用 WITH 语句的习惯。简洁且思路清晰的SQL语句也能减小数据库的负担 。<br><a href="https://mp.weixin.qq.com/s/mS2In3ZkQ2eMDz3szt920Q" target="_blank" rel="noopener">转自</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;sql语句应用不当，可能仅仅一个顺序的不同，往往会带来成千上万倍的耗时问题。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="sql" scheme="https://removeif.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引优化方案</title>
    <link href="https://removeif.github.io/2019/07/03/mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88.html"/>
    <id>https://removeif.github.io/2019/07/03/mysql索引优化方案.html</id>
    <published>2019-07-03T09:02:13.000Z</published>
    <updated>2019-08-16T09:13:50.727Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>mysql自带优化：先执行explain sql，在执行explain extended sql，得到优化结果，show warnings显示优化后的结果sql.<br><a id="more"></a></p></blockquote><h2 id="索引基数"><a href="#索引基数" class="headerlink" title="索引基数"></a>索引基数</h2><p><strong>基数</strong>是<strong>数据列所包含的不同值的数量</strong>，例如，某个数据列包含值 1、3、7、4、7、3，那么它的基数就是 4。索引的基数相对于数据表行数较高（也就是说，列中包含很多不同的值，重复的值很少）的时候，它的工作效果最好。如果某数据列含有很多不同的年龄，索引会很快地分辨数据行；如果某个数据列用于记录性别（只有“M”和“F”两种值），那么索引的用处就不大；如果值出现的几率几乎相等，那么无论搜索哪个值都可能得到一半的数据行。在这些情况下，最好根本不要使用索引，因为查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。惯用的百分比界线是“30%”。</p><h2 id="索引失效原因"><a href="#索引失效原因" class="headerlink" title="索引失效原因"></a>索引失效原因</h2><p>索引失效的原因有如下几点：</p><ul><li>对索引列运算，运算包括（+、-、*、/、！、&lt;&gt;、%、like’%_’（% 放在前面）。</li><li>类型错误，如字段类型为 varchar，where 条件用 number。</li><li>对索引应用内部函数，这种情况下应该要建立基于函数的索引。例如 select * from template t where ROUND (t.logicdb_id) = 1，此时应该建 ROUND (t.logicdb_id) 为索引。</li></ul><p>MySQL 8.0 开始支持函数索引，5.7 可以通过虚拟列的方式来支持，之前只能新建一个 ROUND (t.logicdb_id) 列然后去维护。</p><ul><li>如果条件有 or，即使其中有条件带索引也不会使用（这也是为什么建议少使用 or 的原因），如果想使用 or，又想索引有效，只能将 or 条件中的每个列加上索引。</li><li>如果列类型是字符串，那一定要在条件中数据使用引号，否则不使用索引。</li><li><strong>B-tree 索引 is null 不会走，is not null 会走，位图索引 is null，is not null 都会走</strong>。</li><li><strong>组合索引</strong>遵循<strong>最左原则</strong>。</li></ul><h2 id="索引的建立"><a href="#索引的建立" class="headerlink" title="索引的建立"></a>索引的建立</h2><p>索引的建立需要注意以下几点：</p><ul><li><p>最重要的肯定是根据业务经常查询的语句。</p></li><li><p>尽量选择区分度高的列作为索引，区分度的公式是<br>$$<br>COUNT(DISTINCT空格col) / COUNT(*):表示字段不重复的比率，比率越大我们扫描的记录数就越少。<br>$$</p></li><li><p>如果业务中唯一特性最好建立唯一键，一方面可以保证数据的正确性，另一方面索引的效率能大大提高。</p></li></ul><h2 id="EXPLIAN-中有用的信息"><a href="#EXPLIAN-中有用的信息" class="headerlink" title="EXPLIAN 中有用的信息"></a>EXPLIAN 中有用的信息</h2><p>EXPLIAN 基本用法如下：</p><ul><li>desc 或者 explain 加上你的 SQL。</li><li>explain extended 加上你的 SQL，然后通过 show warnings 可以查看实际执行的语句，这一点也是非常有用的，很多时候不同的写法经 SQL 分析后，实际执行的代码是一样的。</li></ul><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190703164516.png" alt=""></p><h2 id="提高性能的特性"><a href="#提高性能的特性" class="headerlink" title="提高性能的特性"></a>提高性能的特性</h2><p>EXPLIAN 提高性能的特性如下：</p><ul><li>索引覆盖(covering index)：需要查询的数据在索引上都可以查到<strong>不需要回表 EXTRA</strong> 列显示 using index。</li><li>ICP特性(Index Condition Pushdown)：本来 index 仅仅是 data access 的一种访问模式，存数引擎通过索引回表获取的数据会传递到 MySQL Server 层进行 where 条件过滤。</li></ul><p>5.6 版本开始当 ICP 打开时，如果部分 where 条件能使用索引的字段，MySQL Server 会把这部分下推到引擎层，可以利用 index 过滤的 where 条件在存储引擎层进行数据过滤。</p><p>EXTRA 显示 using index condition。需要了解 MySQL 的架构图分为 Server 和存储引擎层。</p><ul><li>索引合并(index merge)：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并(intersect/union)。</li></ul><p>一般用 or 会用到，如果是 AND 条件，考虑建立复合索引。EXPLAIN 显示的索引类型会显示 index_merge，EXTRA 会显示具体的合并算法和用到的索引。</p><h2 id="Extra字段"><a href="#Extra字段" class="headerlink" title="Extra字段"></a>Extra字段</h2><p>Extra 字段使用：</p><ul><li>using filesort：说明 MySQL 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。</li></ul><p>MySQL 中无法利用索引完成的排序操作称为“文件排序”，其实不一定是文件排序，内部使用的是快排。</p><ul><li>using temporary：使用了临时表保存中间结果，MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。</li><li>using index：表示相应的 SELECT 操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。</li><li>impossible where：where 子句的值总是 false，不能用来获取任何元组。</li><li>select tables optimized away：在没有 group by 子句的情况下基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*) 操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</li><li>distinct：优化 distinct 操作，在找到第一匹配的元组后即停止找同样值的操作。</li></ul><p><strong>using filesort、using temporary</strong> 这两项出现时需要注意下，这两项是十分耗费性能的</p><p>在使用 group by 的时候，虽然没有使用 order by，如果没有索引，是可能同时出现 using filesort，using temporary 的。因为 group by 就是先排序在分组，如果没有排序的需要，可以加上一个 <strong>order by NULL</strong> 来避免排序，这样 using filesort 就会去除，能提升一点性能。</p><h2 id="type字段"><a href="#type字段" class="headerlink" title="type字段"></a>type字段</h2><ul><li>system：表只有一行记录（等于系统表），这是 const 类型的特例，平时不会出现。</li><li>const：如果通过索引依次就找到了，const 用于比较主键索引或者 unique 索引。因为只能匹配一行数据，所以很快。如果将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量。</li><li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</li><li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。</li><li>range：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的 where 语句中出现 between、&lt;、&gt;、in 等的查询。</li></ul><p>这种范围扫描索引比全表扫描要好，因为只需要开始于缩印的某一点，而结束于另一点，不用扫描全部索引。</p><ul><li>index：Full Index Scan ，index 与 ALL 的区别为 index 类型只遍历索引树，这通常比 ALL 快，因为索引文件通常比数据文件小。</li></ul><p>也就是说虽然 ALL 和 index 都是读全表，但 index 是从索引中读取的，而 ALL 是从硬盘读取的。</p><ul><li>all：Full Table Scan，遍历全表获得匹配的行。</li></ul><h2 id="字段类型和编码"><a href="#字段类型和编码" class="headerlink" title="字段类型和编码"></a>字段类型和编码</h2><ul><li><p>MySQL 返回字符串长度</p><p>CHARACTER_LENGTH(同CHAR_LENGTH)方法返回的是字符数，LENGTH 函数返回的是字节数，一个汉字三个字节。</p></li><li><p>varchar 等字段建立索引长度计算语句</p><p>select count(distinct left(test,5))/count(*) from table；越趋近 1 越好。</p></li><li><p>MySQL 的 utf8</p><p>MySQL 的 utf8 最大是 3 个字节不支持 emoji 表情符号，必须只用 utf8mb4。需要在 MySQL 配置文件中配置客户端字符集为 utf8mb4。</p></li></ul><p>JDBC 的连接串不支持配置 characterEncoding=utf8mb4，最好的办法是在连接池中指定初始化 SQL。例如：hikari 连接池，其他连接池类似 spring . datasource . hikari . connection - init - sql =set names utf8mb4。否则需要每次执行 SQL 前都先执行 set names utf8mb4。</p><h2 id="MySQL-排序规则"><a href="#MySQL-排序规则" class="headerlink" title="MySQL 排序规则"></a>MySQL 排序规则</h2><p>一般使用 _bin 和 _genera_ci：</p><ul><li>utf8_genera_ci 不区分大小写，ci 为 case insensitive 的缩写，即大小写不敏感。</li><li>utf8_general_cs 区分大小写，cs 为 case sensitive 的缩写，即大小写敏感，但是目前 MySQL 版本中已经不支持类似于 _genera_cs 的排序规则，直接使用 utf8_bin 替代。</li><li>utf8_bin 将字符串中的每一个字符用二进制数据存储，区分大小写。</li></ul><p>那么，同样是区分大小写，utf8_general_cs 和 utf8_bin 有什么区别？</p><ul><li>cs 为 case sensitive 的缩写，即大小写敏感；bin 的意思是二进制，也就是二进制编码比较。</li><li>utf8_general_cs 排序规则下，即便是区分了大小写，但是某些西欧的字符和拉丁字符是不区分的，比如 ä=a，但是有时并不需要 ä=a，所以才有 utf8_bin。</li><li>utf8_bin 的特点在于使用字符的二进制的编码进行运算，任何不同的二进制编码都是不同的，因此在 utf8_bin 排序规则下：ä&lt;&gt;a。</li></ul><h2 id="SQL语句总结"><a href="#SQL语句总结" class="headerlink" title="SQL语句总结"></a>SQL语句总结</h2><h3 id="常用但容易忘的"><a href="#常用但容易忘的" class="headerlink" title="常用但容易忘的"></a>常用但容易忘的</h3><ul><li>如果有主键或者唯一键冲突则不插入：insert ignore into。</li><li>如果有主键或者唯一键冲突则更新，注意这个会影响自增的增量：INSERT INTO room_remarks(room_id,room_remarks)VALUE(1,”sdf”) ON DUPLICATE KEY UPDATE room_remarks = “234”。</li><li>如果有就用新的替代，values 如果不包含自增列，自增列的值会变化：REPLACE INTO room_remarks(room_id,room_remarks) VALUE(1,”sdf”)。</li><li>备份表：CREATE TABLE user_info SELECT * FROM user_info。</li><li>复制表结构：CREATE TABLE user_v2 LIKE user。</li><li>从查询语句中导入：INSERT INTO user_v2 SELECT * FROM user 或者 INSERT INTO user_v2(id,num) SELECT id,num FROM user。</li><li>连表更新：UPDATE user a, room b SET a.num=a.num+1 WHERE a.room_id=b.id。</li><li>连表删除：DELETE user FROM user,black WHERE user.id=black.id。</li></ul><h3 id="锁相关"><a href="#锁相关" class="headerlink" title="锁相关"></a>锁相关</h3><p>锁相关(作为了解，很少用)：</p><ul><li>共享锁：select id from tb_test where id = 1 lock in share mode。</li><li>排它锁：select id from tb_test where id = 1 for update。</li></ul><h3 id="优化时用到"><a href="#优化时用到" class="headerlink" title="优化时用到"></a>优化时用到</h3><ul><li>强制使用某个索引：select * from table force index(idx_user) limit 2。</li><li>禁止使用某个索引：select * from table ignore index(idx_user) limit 2。</li><li>禁用缓存(在测试时去除缓存的影响)：select SQL_NO_CACHE from table limit 2。</li></ul><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><ul><li>查看字符集：SHOW VARIABLES LIKE ‘character_set%’。</li><li>查看排序规则：SHOW VARIABLES LIKE ‘collation%’。</li></ul><h3 id="SQL编写注意"><a href="#SQL编写注意" class="headerlink" title="SQL编写注意"></a>SQL编写注意</h3><ul><li>where 语句的解析顺序是从右到左，条件尽量放 where 不要放 having。</li><li>采用延迟关联(deferred join)技术优化超多分页场景，比如 limit 10000,10,延迟关联可以避免回表。</li><li>distinct 语句非常损耗性能，可以通过 group by 来优化。</li><li>连表尽量不要超过三个表。</li></ul><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><ul><li>如果有自增列，truncate 语句会把自增列的基数重置为 0，有些场景用自增列作为业务上的 ID 需要十分重视。</li><li>聚合函数会自动滤空，比如 a 列的类型是 int 且全部是 NULL，则 SUM(a) 返回的是 NULL 而不是 0。</li><li>MySQL 判断 null 相等不能用 “a=null”，这个结果永远为 UnKnown，where 和 having 中，UnKnown 永远被视为 false，check 约束中，UnKnown 就会视为 true 来处理。所以要用“a is null”处理。</li></ul><p>千万大表在线修改MySQL 在表数据量很大的时候，如果修改表结构会导致锁表，业务请求被阻塞。MySQL 在 5.6 之后引入了在线更新，但是在某些情况下还是会锁表，所以一般都采用 PT 工具( Percona Toolkit)。如对表添加索引：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-<span class="hljs-keyword">change</span> <span class="hljs-comment">--user='root' --host='localhost' --ask-pass --alter "add index idx_user_id(room_id,create_time)" </span></span><br><span class="line"></span><br><span class="line">D=fission_show_room_v2,t=room_favorite_info <span class="hljs-comment">--execute</span></span><br></pre></td></tr></table></figure><ul><li>慢查询日志</li></ul><p>有时候如果线上请求超时，应该去关注下慢查询日志，慢查询的分析很简单，先找到慢查询日志文件的位置，然后利用 mysqldumpslow 去分析。</p><p>查询慢查询日志信息可以直接通过执行 SQL 命令查看相关变量，常用的 SQL 如下：</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190703165642.png" alt=""></p><p>mysqldumpslow 的工具十分简单，我主要用到的参数如下：</p><ul><li><strong>-t：</strong>限制输出的行数，我一般取前十条就够了。</li><li><strong>-s：</strong>根据什么来排序默认是平均查询时间 at，我还经常用到 c 查询次数，因为查询次数很频繁但是时间不高也是有必要优化的，还有 t 查询时间，查看那个语句特别卡。</li><li><strong>-v：</strong>输出详细信息。</li></ul><p>例子：mysqldumpslow -v -s t -t 10 mysql_slow.log.2018-11-20-0500。</p><ul><li><p>一些数据库性能的思考</p><p>在对公司慢查询日志做优化的时候，很多时候可能是忘了建索引，像这种问题很容易解决，加个索引就行了。但是有几种情况就不是简单加索引能解决了 </p><p><strong>业务代码循环读数据库</strong></p><p>​    考虑这样一个场景，获取用户粉丝列表信息，加入分页是十个，其实像这样的 SQL 是十分简单的，通过连表查询性能也很高。</p><p>​    但是有时候，很多开发采用了取出一串 ID，然后循环读每个 ID 的信息，这样如果 ID 很多对数据库的压力是很大的，而且性能也很低。</p><p><strong>统计 SQL</strong></p><p>​    很多时候，业务上都会有排行榜这种，发现公司有很多地方直接采用数据库做计算，在对一些大表做聚合运算的时候，经常超过五秒，这些 SQL 一般很长而且很难优化。像这种场景，如果业务允许（比如一致性要求不高或者是隔一段时间才统计的），可以专门在从库里面做统计。另外我建议还是采用 Redis 缓存来处理这种业务。</p><p><strong>超大分页</strong></p><p>​    在慢查询日志中发现了一些超大分页的慢查询如 Limit 40000，1000，因为 MySQL 的分页是在 Server 层做的，可以采用延迟关联在减少回表。但是看了相关的业务代码正常的业务逻辑是不会出现这样的请求的，所以很有可能是有恶意用户在刷接口，最好在开发的时候也对接口加上校验拦截这些恶意请求。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;mysql自带优化：先执行explain sql，在执行explain extended sql，得到优化结果，show warnings显示优化后的结果sql.&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="mysql" scheme="https://removeif.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>一次数据库的死锁问题排查过程</title>
    <link href="https://removeif.github.io/2019/06/25/%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B.html"/>
    <id>https://removeif.github.io/2019/06/25/一次数据库的死锁问题排查过程.html</id>
    <published>2019-06-25T03:11:56.000Z</published>
    <updated>2019-08-16T09:13:50.772Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>某天晚上，同事正在发布，突然线上大量报警，很多是关于数据库死锁的，报警提示信息如下：<br><a id="more"></a></p></blockquote><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>某天晚上，同事正在发布，突然线上大量报警，很多是关于数据库死锁的，报警提示信息如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;"errorCode":"SYSTEM_ERROR","errorMsg":"nested exception is org.apache.ibatis.exceptions.PersistenceException: </span><br><span class="line"></span><br><span class="line">Error updating database. Cause: ERR-CODE: [TDDL-4614][ERR_EXECUTE_ON_MYSQL] </span><br><span class="line"></span><br><span class="line">Deadlock found when trying to get <span class="hljs-keyword">lock</span>; </span><br><span class="line"></span><br><span class="line">The error occurred while setting parameters\n<span class="hljs-comment">### SQL: </span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">update</span> fund_transfer_stream <span class="hljs-keyword">set</span> gmt_modified=<span class="hljs-keyword">now</span>(),state = ? <span class="hljs-keyword">where</span> fund_transfer_order_no = ? <span class="hljs-keyword">and</span> seller_id = ? <span class="hljs-keyword">and</span> state = <span class="hljs-string">'NEW'</span></span><br></pre></td></tr></table></figure><p>通过报警，我们基本可以定位到发生死锁的数据库以及数据库表。先来介绍下本文案例中涉及到的数据库相关信息。</p><h3 id="背景情况"><a href="#背景情况" class="headerlink" title="背景情况"></a>背景情况</h3><p>我们使用的数据库是Mysql 5.7，引擎是InnoDB，事务隔离级别是READ-COMMITED。</p><p>数据库版本查询方法：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">version</span>();</span><br></pre></td></tr></table></figure><p>引擎查询方法：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> fund_transfer_stream;</span><br></pre></td></tr></table></figure><p>建表语句中会显示存储引擎信息，形如：<code>ENGINE=InnoDB</code></p><p>事务隔离级别查询方法：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> @@tx_isolation;</span><br></pre></td></tr></table></figure><p>事务隔离级别设置方法（只对当前Session生效）：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">set</span> <span class="hljs-keyword">session</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> <span class="hljs-keyword">read</span> committed;</span><br></pre></td></tr></table></figure><p>PS：注意，如果数据库是分库的，以上几条SQL语句需要在单库上执行，不要在逻辑库执行。</p><p>发生死锁的表结构及索引情况（隐去了部分无关字段和索引）：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`fund_transfer_stream`</span> ( </span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'主键'</span>,</span><br><span class="line">  <span class="hljs-string">`gmt_create`</span> datetime <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'创建时间'</span>,</span><br><span class="line">  <span class="hljs-string">`gmt_modified`</span> datetime <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'修改时间'</span>, </span><br><span class="line">  <span class="hljs-string">`pay_scene_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'支付场景名称'</span>, </span><br><span class="line">  <span class="hljs-string">`pay_scene_version`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'支付场景版本'</span>,</span><br><span class="line">  <span class="hljs-string">`identifier`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'唯一性标识'</span>,</span><br><span class="line">  <span class="hljs-string">`seller_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'卖家Id'</span>,</span><br><span class="line">  <span class="hljs-string">`state`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'状态'</span>, <span class="hljs-string">`fund_transfer_order_no`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>) </span><br><span class="line">  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'资金平台返回的状态'</span>, </span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),<span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-string">`uk_scene_identifier`</span> </span><br><span class="line">  (<span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_seller`</span> (<span class="hljs-string">`seller_id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_seller_transNo`</span> (<span class="hljs-string">`seller_id`</span>,<span class="hljs-string">`fund_transfer_order_no`</span>(<span class="hljs-number">20</span>))</span><br><span class="line">  ) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'资金流水'</span>;</span><br></pre></td></tr></table></figure><p>该数据库共有三个索引，1个聚簇索引（主键索引），2个非聚簇索（非主键索引）引。</p><p>聚簇索引：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRIMARY KEY (`id`)</span><br></pre></td></tr></table></figure><p>非聚簇索引：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KEY `idx_seller` (`seller_id`),</span><br><span class="line"></span><br><span class="line">KEY `idx_seller_transNo` (`seller_id`,`fund_transfer_order_no`(20))</span><br></pre></td></tr></table></figure><p>以上两个索引，其实idx_seller_transNo已经覆盖到了idx_seller，由于历史原因，因为该表以seller_id分表，所以是先有的idx_seller，后有的idx_seller_transNo</p><h3 id="死锁日志"><a href="#死锁日志" class="headerlink" title="死锁日志"></a>死锁日志</h3><p>当数据库发生死锁时，可以通过以下命令获取死锁日志：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">engine</span> <span class="hljs-keyword">innodb</span> <span class="hljs-keyword">status</span></span><br></pre></td></tr></table></figure><p>发生死锁，第一时间查看死锁日志，得到死锁日志内容如下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Transactions deadlock detected, dumping detailed information.</span><br><span class="line">2019-03-19T21:44:23.516263+08:00 5877341 [Note] InnoDB: </span><br><span class="line"></span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 173268495, ACTIVE 0 sec fetching rows</span><br><span class="line">mysql tables in <span class="hljs-keyword">use</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">locked</span> <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">WAIT</span> <span class="hljs-number">304</span> <span class="hljs-keyword">lock</span> <span class="hljs-keyword">struct</span>(s), <span class="hljs-keyword">heap</span> <span class="hljs-keyword">size</span> <span class="hljs-number">41168</span>, <span class="hljs-number">6</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">lock</span>(s), <span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span> entries <span class="hljs-number">1</span></span><br><span class="line">MySQL <span class="hljs-keyword">thread</span> <span class="hljs-keyword">id</span> <span class="hljs-number">5877358</span>, OS <span class="hljs-keyword">thread</span> handle <span class="hljs-number">47356539049728</span>, <span class="hljs-keyword">query</span> <span class="hljs-keyword">id</span> <span class="hljs-number">557970181</span> <span class="hljs-number">11.183</span><span class="hljs-number">.244</span><span class="hljs-number">.150</span> fin_instant_app updating</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">update</span> <span class="hljs-string">`fund_transfer_stream`</span> <span class="hljs-keyword">set</span> <span class="hljs-string">`gmt_modified`</span> = <span class="hljs-keyword">NOW</span>(), <span class="hljs-string">`state`</span> = <span class="hljs-string">'PROCESSING'</span> <span class="hljs-keyword">where</span> ((<span class="hljs-string">`state`</span> = <span class="hljs-string">'NEW'</span>) <span class="hljs-keyword">AND</span> (<span class="hljs-string">`seller_id`</span> = <span class="hljs-string">'38921111'</span>) <span class="hljs-keyword">AND</span> (<span class="hljs-string">`fund_transfer_order_no`</span> = <span class="hljs-string">'99010015000805619031958363857'</span>))</span><br><span class="line"><span class="hljs-number">2019</span><span class="hljs-number">-03</span><span class="hljs-number">-19</span>T21:<span class="hljs-number">44</span>:<span class="hljs-number">23.516321</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> <span class="hljs-number">5877341</span> [Note] <span class="hljs-keyword">InnoDB</span>: </span><br><span class="line"></span><br><span class="line">*** (<span class="hljs-number">1</span>) HOLDS THE <span class="hljs-keyword">LOCK</span>(S):</span><br><span class="line"><span class="hljs-built_in">RECORD</span> LOCKS <span class="hljs-keyword">space</span> <span class="hljs-keyword">id</span> <span class="hljs-number">173</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">13726</span> n bits <span class="hljs-number">248</span> <span class="hljs-keyword">index</span> idx_seller_transNo <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> <span class="hljs-string">`xxx`</span>.<span class="hljs-string">`fund_transfer_stream`</span> trx <span class="hljs-keyword">id</span> <span class="hljs-number">173268495</span> lock_mode X locks rec but <span class="hljs-keyword">not</span> gap</span><br><span class="line"><span class="hljs-built_in">Record</span> <span class="hljs-keyword">lock</span>, <span class="hljs-keyword">heap</span> <span class="hljs-keyword">no</span> <span class="hljs-number">168</span> <span class="hljs-keyword">PHYSICAL</span> <span class="hljs-built_in">RECORD</span>: n_fields <span class="hljs-number">3</span>; compact format; info bits 0</span><br><span class="line"></span><br><span class="line">2019-03-19T21:44:23.516565+08:00 5877341 [Note] InnoDB: </span><br><span class="line"></span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 173 page no 12416 n bits 128 index PRIMARY of table `xxx`.`fund_transfer_stream` trx id 173268495 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record <span class="hljs-keyword">lock</span>, <span class="hljs-keyword">heap</span> <span class="hljs-keyword">no</span> <span class="hljs-number">56</span> <span class="hljs-keyword">PHYSICAL</span> <span class="hljs-built_in">RECORD</span>: n_fields <span class="hljs-number">17</span>; compact format; info bits 0</span><br><span class="line">2019-03-19T21:44:23.517793+08:00 5877341 [Note] InnoDB: </span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 173268500, ACTIVE 0 sec fetching rows, thread declared inside InnoDB 81</span><br><span class="line">mysql tables in <span class="hljs-keyword">use</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">locked</span> <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-number">302</span> <span class="hljs-keyword">lock</span> <span class="hljs-keyword">struct</span>(s), <span class="hljs-keyword">heap</span> <span class="hljs-keyword">size</span> <span class="hljs-number">41168</span>, <span class="hljs-number">2</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">lock</span>(s), <span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span> entries <span class="hljs-number">1</span></span><br><span class="line">MySQL <span class="hljs-keyword">thread</span> <span class="hljs-keyword">id</span> <span class="hljs-number">5877341</span>, OS <span class="hljs-keyword">thread</span> handle <span class="hljs-number">47362313119488</span>, <span class="hljs-keyword">query</span> <span class="hljs-keyword">id</span> <span class="hljs-number">557970189</span> <span class="hljs-number">11.131</span><span class="hljs-number">.81</span><span class="hljs-number">.107</span> fin_instant_app updating</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">update</span> <span class="hljs-string">`fund_transfer_stream_0056`</span> <span class="hljs-keyword">set</span> <span class="hljs-string">`gmt_modified`</span> = <span class="hljs-keyword">NOW</span>(), <span class="hljs-string">`state`</span> = <span class="hljs-string">'PROCESSING'</span> <span class="hljs-keyword">where</span> ((<span class="hljs-string">`state`</span> = <span class="hljs-string">'NEW'</span>) <span class="hljs-keyword">AND</span> (<span class="hljs-string">`seller_id`</span> = <span class="hljs-string">'38921111'</span>) <span class="hljs-keyword">AND</span> (<span class="hljs-string">`fund_transfer_order_no`</span> = <span class="hljs-string">'99010015000805619031957477256'</span>))</span><br><span class="line"><span class="hljs-number">2019</span><span class="hljs-number">-03</span><span class="hljs-number">-19</span>T21:<span class="hljs-number">44</span>:<span class="hljs-number">23.517855</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span> <span class="hljs-number">5877341</span> [Note] <span class="hljs-keyword">InnoDB</span>: </span><br><span class="line"></span><br><span class="line">*** (<span class="hljs-number">2</span>) HOLDS THE <span class="hljs-keyword">LOCK</span>(S):</span><br><span class="line"><span class="hljs-built_in">RECORD</span> LOCKS <span class="hljs-keyword">space</span> <span class="hljs-keyword">id</span> <span class="hljs-number">173</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">12416</span> n bits <span class="hljs-number">128</span> <span class="hljs-keyword">index</span> PRIMARY <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> <span class="hljs-string">`fin_instant_0003`</span>.<span class="hljs-string">`fund_transfer_stream_0056`</span> trx <span class="hljs-keyword">id</span> <span class="hljs-number">173268500</span> lock_mode X locks rec but <span class="hljs-keyword">not</span> gap</span><br><span class="line"><span class="hljs-built_in">Record</span> <span class="hljs-keyword">lock</span>, <span class="hljs-keyword">heap</span> <span class="hljs-keyword">no</span> <span class="hljs-number">56</span> <span class="hljs-keyword">PHYSICAL</span> <span class="hljs-built_in">RECORD</span>: n_fields <span class="hljs-number">17</span>; compact format; info bits 0</span><br><span class="line"></span><br><span class="line">2019-03-19T21:44:23.519053+08:00 5877341 [Note] InnoDB: </span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 173 page no 13726 n bits 248 index idx_seller_transNo of table `fin_instant_0003`.`fund_transfer_stream_0056` trx id 173268500 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record <span class="hljs-keyword">lock</span>, <span class="hljs-keyword">heap</span> <span class="hljs-keyword">no</span> <span class="hljs-number">168</span> <span class="hljs-keyword">PHYSICAL</span> <span class="hljs-built_in">RECORD</span>: n_fields <span class="hljs-number">3</span>; compact format; info bits 0</span><br><span class="line"></span><br><span class="line">2019-03-19T21:44:23.519297+08:00 5877341 [Note] InnoDB: *** WE ROLL BACK TRANSACTION (2)</span><br></pre></td></tr></table></figure><p>简单解读一下死锁日志，可以得到以下信息：</p><p>1、导致死锁的两条SQL语句分别是：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">update</span> <span class="hljs-string">`fund_transfer_stream_0056`</span> </span><br><span class="line"><span class="hljs-keyword">set</span> <span class="hljs-string">`gmt_modified`</span> = <span class="hljs-keyword">NOW</span>(), <span class="hljs-string">`state`</span> = <span class="hljs-string">'PROCESSING'</span> </span><br><span class="line"><span class="hljs-keyword">where</span> ((<span class="hljs-string">`state`</span> = <span class="hljs-string">'NEW'</span>) <span class="hljs-keyword">AND</span> (<span class="hljs-string">`seller_id`</span> = <span class="hljs-string">'38921111'</span>) <span class="hljs-keyword">AND</span> (<span class="hljs-string">`fund_transfer_order_no`</span> = <span class="hljs-string">'99010015000805619031957477256'</span>))</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">update</span> <span class="hljs-string">`fund_transfer_stream_0056`</span> </span><br><span class="line"><span class="hljs-keyword">set</span> <span class="hljs-string">`gmt_modified`</span> = <span class="hljs-keyword">NOW</span>(), <span class="hljs-string">`state`</span> = <span class="hljs-string">'PROCESSING'</span> </span><br><span class="line"><span class="hljs-keyword">where</span> ((<span class="hljs-string">`state`</span> = <span class="hljs-string">'NEW'</span>) <span class="hljs-keyword">AND</span> (<span class="hljs-string">`seller_id`</span> = <span class="hljs-string">'38921111'</span>) <span class="hljs-keyword">AND</span> (<span class="hljs-string">`fund_transfer_order_no`</span> = <span class="hljs-string">'99010015000805619031958363857'</span>))</span><br></pre></td></tr></table></figure><p>2、事务1，持有索引idx_seller_transNo的锁，在等待获取PRIMARY的锁。</p><p>3、事务2，持有PRIMARY的锁，在等待获取idx_seller_transNo的锁。</p><p>4、因事务1和事务2之间发生循环等待，故发生死锁。</p><p>5、事务1和事务2当前持有的锁均为：<code>lock_mode X locks rec but not gap</code></p><p>两个事务对记录加的都是X 锁，No Gap锁，即对当行记录加锁，并为加间隙锁。</p><blockquote><p>X锁：排他锁、又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p><p>与之对应的是S锁：共享锁，又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p><p>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</p><p>Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</p></blockquote><p>详见：<a href="https://www.cnblogs.com/zhoujinyi/p/3435982.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoujinyi/p/3435982.html</a> 、 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html</a></p><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><p>根据我们目前已知的数据库相关信息，以及死锁的日志，我们基本可以做一些简单的判定。</p><p>首先，<strong>此次死锁一定是和Gap锁以及Next-Key Lock没有关系的</strong>。因为我们的数据库隔离级别是RC（READ-COMMITED）的，这种隔离级别是不会添加Gap锁的。前面的死锁日志也提到这一点。</p><p>然后，就要翻代码了，看看我们的代码中事务到底是怎么做的。核心代码及SQL如下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">public int doProcessing(String sellerId, Long id, String fundTransferOrderNo) &#123;</span><br><span class="line">    fundTreansferStreamDAO.updateFundStreamId(sellerId, id, fundTransferOrderNo);</span><br><span class="line">    return fundTreansferStreamDAO.updateStatus(sellerId, fundTransferOrderNo, FundTransferStreamState.PROCESSING.name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码的目的是先后修改同一条记录的两个不同字段，updateFundStreamId SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">update</span> fund_transfer_stream</span><br><span class="line">        <span class="hljs-keyword">set</span> gmt_modified=<span class="hljs-keyword">now</span>(),fund_transfer_order_no = <span class="hljs-comment">#&#123;fundTransferOrderNo&#125;</span></span><br><span class="line">        <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-comment">#&#123;id&#125; and seller_id = #&#123;sellerId&#125;</span></span><br></pre></td></tr></table></figure><p>updateStatus SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">update</span> fund_transfer_stream</span><br><span class="line">    <span class="hljs-keyword">set</span> gmt_modified=<span class="hljs-keyword">now</span>(),state = <span class="hljs-comment">#&#123;state&#125;</span></span><br><span class="line">    <span class="hljs-keyword">where</span> fund_transfer_order_no = <span class="hljs-comment">#&#123;fundTransferOrderNo&#125; and seller_id = #&#123;sellerId&#125;</span></span><br><span class="line">    <span class="hljs-keyword">and</span> state = <span class="hljs-string">'NEW'</span></span><br></pre></td></tr></table></figure><p>可以看到，我们的同一个事务中执行了两条Update语句，这里分别查看下两条SQL的执行计划：</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190625110409.png" alt=""></p><p>updateFundStreamId执行的时候使用到的是PRIMARY索引。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190625110452.png" alt=""></p><p>updateStatus执行的时候使用到的是idx_seller_transNo索引。</p><blockquote><p>通过执行计划，我们发现updateStatus其实是有两个索引可以用的，执行的时候真正使用的是idx_seller_transNo索引。这是因为<strong>MySQL查询优化器是基于代价（cost-based）的查询方式。因此，在查询过程中，最重要的一部分是根据查询的SQL语句，依据多种索引，计算查询需要的代价，从而选择最优的索引方式生成查询计划。</strong></p><p>我们查询执行计划是在死锁发生之后做的，事后查询的执行计划和发绳死锁那一刻的索引使用情况并不一定相同的。但是，我们结合死锁日志，也可以定位到以上两条SQL语句执行的时候使用到的索引。即<strong>updateFundStreamId执行的时候使用到的是PRIMARY索引，updateStatus执行的时候使用到的是idx_seller_transNo索引</strong>。</p></blockquote><p>有了以上这些已知信息，我们就可以开始排查死锁原因及其背后的原理了。通过分析死锁日志，再结合我们的代码以及数据库建表语句，我们发现主要问题出在我们的idx_seller_transNo索引上面：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `idx_seller_transNo` (`seller_id`,`fund_transfer_order_no`(<span class="hljs-number">20</span>))</span><br></pre></td></tr></table></figure><p>索引创建语句中，我们使用了前缀索引，为了节约索引空间，提高索引效率，我们只选择了fund_transfer_order_no字段的前20位作为索引值。</p><p>因为fund_transfer_order_no只是普通索引，而非唯一性索引。又因为在一种特殊情况下，会有同一个用户的两个fund_transfer_order_no的前20位相同，这就导致两条不同的记录的索引值一样（因为seller_id 和fund_transfer_order_no(20)都相同 ）。</p><p>就如本文中的例子，发生死锁的两条记录的fund_transfer_order_no字段的值：99010015000805619031958363857和99010015000805619031957477256这两个就是前20位相同的。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190625110517.png" alt=""></p><p>那么为什么fund_transfer_order_no的前20位相同会导致死锁呢？</p><h3 id="加锁原理"><a href="#加锁原理" class="headerlink" title="加锁原理"></a>加锁原理</h3><p>我们就拿本次的案例来看一下MySql数据库加锁的原理是怎样的，本文的死锁背后又发生了什么。</p><p>我们在数据库上模拟死锁场景，执行顺序如下：</p><table><thead><tr><th style="text-align:center">事务1</th><th style="text-align:center">事务2</th><th style="text-align:center">执行结果</th></tr></thead><tbody><tr><td style="text-align:center">begin</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">update fund_transfer_stream set gmt_modified=now(),fund_transfer_order_no = ‘99010015000805619031958363857’ where id = 1 and seller_id = 3111095611;</td><td style="text-align:center"></td><td style="text-align:center">执行成功</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">begin</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">update fund_transfer_stream set gmt_modified=now(),fund_transfer_order_no = ‘99010015000805619031957477256’ where id = 2 and seller_id = 3111095611;</td><td style="text-align:center">执行成功</td></tr><tr><td style="text-align:center">update fund_transfer_stream set gmt_modified = NOW(), state = ‘PROCESSING’ where ((state = ‘NEW’) AND (seller_id = ‘3111095611’) AND (fund_transfer_order_no = ‘99010015000805619031958363857’));</td><td style="text-align:center"></td><td style="text-align:center">阻塞</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">update fund_transfer_stream set gmt_modified = NOW(), state = ‘PROCESSING’ where ((state = ‘NEW’) AND (seller_id = ‘3111095611’) AND (fund_transfer_order_no = ‘99010015000805619031957477256’));</td><td style="text-align:center">死锁</td></tr></tbody></table><p>我们知道，<strong>在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。</strong></p><blockquote><p>主键索引的叶子节点存的是整行数据。在InnoDB中，主键索引也被称为聚簇索引（clustered index）</p><p>非主键索引的叶子节点的内容是主键的值，在InnoDB中，非主键索引也被称为非聚簇索引（secondary index）</p></blockquote><p>所以，本文的示例中涉及到的索引结构（索引是B+树，简化成表格了）如图：</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190625110555.png" alt=""></p><p>死锁的发生与否，并不在于事务中有多少条SQL语句，<strong>死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。</strong>那么接下来就看下上面的例子中两个事务的加锁顺序是怎样的：</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190625110615.png" alt=""></p><p>下图是分解图，每一条SQL执行的时候加锁情况：</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190625110635.png" alt=""></p><p>结合以上两张图，我们发现了导致死锁的原因： 事务1执行update1占用PRIMARY = 1的锁 ——&gt; 事务2执行update1 占有PRIMARY = 2的锁； 事务1执行update2占有idx_seller_transNo = (3111095611，99010015000805619031)的锁，尝试占有PRIMARY = 2锁失败（阻塞）； 事务2执行update2尝试占有idx_seller_transNo = (3111095611，99010015000805619031)的锁失败（死锁）；</p><blockquote><p>事务在以非主键索引为where条件进行Update的时候，会先对该非主键索引加锁，然后再查询该非主键索引对应的主键索引都有哪些，再对这些主键索引进行加锁。）</p></blockquote><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>至此，我们分析清楚了导致死锁的根本原理以及其背后的原理。那么这个问题解决起来就不难了。</p><p>可以从两方面入手，分别是修改索引和修改代码（包含SQL语句）。</p><p>修改索引：只要我们把前缀索引 idx_seller_transNo中fund_transfer_order_no的前缀长度修改下就可以了。比如改成50。即可避免死锁。</p><p>但是，改了idx_seller_transNo的前缀长度后，可以解决死锁的前提条件是update语句真正执行的时候，会用到fund_transfer_order_no索引。如果MySQL查询优化器在代价分析之后，决定使用索引 KEY idx_seller(seller_id)，那么还是会存在死锁问题。原理和本文类似。</p><p>所以，根本解决办法就是改代码：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 所有update都通过主键ID进行。</span><br><span class="line">* 在同一个事务中，避免出现多条update语句修改同一条记录。</span><br></pre></td></tr></table></figure><h3 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h3><p>在死锁发生之后的一周内，我几乎每天都会抽空研究一会，问题早早的就定位到了，修改方案也有了，但是其中原理一直没搞清楚。</p><p>前前后后做过很多中种推断及假设，又都被自己一次次推翻。最终还是要靠实践来验证自己的想法。于是我自己在本地安装了数据库，实战的做了些测试，并实时查看数据库锁情况。<code>show engine innodb status ;</code>可以查看锁情况。最终才搞清楚原理。</p><p>简单说几点思考：</p><p>1、遇到问题，不要猜！！！亲手复现下问题，然后再来分析。</p><p>2、不要忽略上下文！！！我刚开始就是只关注死锁日志，一直忽略了代码中的事务其实还执行了另外一条SQL语句（updateFundStreamId）。</p><p>3、理论知识再充足，关键时刻不一定想的起来！！！</p><p>4、坑都是自己埋的！！！</p><p>参考资料：<br><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">MySQL 加锁处理分析</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html" target="_blank" rel="noopener">innodb 事务隔离级别</a></p><p><a href="https://time.geekbang.org/column/intro/139" target="_blank" rel="noopener">《MySql实战45讲》</a></p><p><a href="https://www.hollischuang.com/archives/914" target="_blank" rel="noopener">MySQL中的行级锁,表级锁,页级锁</a></p><p><a href="https://www.hollischuang.com/archives/3461" target="_blank" rel="noopener">查看原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;某天晚上，同事正在发布，突然线上大量报警，很多是关于数据库死锁的，报警提示信息如下：&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="mysql" scheme="https://removeif.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>博客图片上传picgo工具github图传使用</title>
    <link href="https://removeif.github.io/2019/06/20/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0picgo%E5%B7%A5%E5%85%B7github%E5%9B%BE%E4%BC%A0%E4%BD%BF%E7%94%A8.html"/>
    <id>https://removeif.github.io/2019/06/20/博客图片上传picgo工具github图传使用.html</id>
    <published>2019-06-20T09:31:57.000Z</published>
    <updated>2019-08-16T09:13:50.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>对于每一个写博客的人来说，图片是至关重要。这一路经历了多次图片的烦恼，之前选择了微博个人文章那里粘贴图片的方式上传，感觉也挺方便的。但是由于新浪的图片显示问题，如果header中不设置<!-- <meta name="referrer" content="no-referrer" /> 解决图片过期问题--> 标签就不能异步访问图片，导致图裂，那之恶心。然而设置之后又与网站访客统计的插件冲突，使之不能统计，真是神仙打架。无赖之下使用了PicGo工具，使用后感觉真XX方便！<br><a id="more"></a></p></blockquote><h2 id="PicGo工具下载安装配置"><a href="#PicGo工具下载安装配置" class="headerlink" title="PicGo工具下载安装配置"></a>PicGo工具下载安装配置</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul><li><p>.<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo下载</a> github网站提供三个版本的下载，MacOs、linux、windows覆盖市面上90%系统，还是很给力了。</p></li><li><p>我是mac用户，直接使用brew cask来安装PicGo: <strong>brew cask install picgo</strong>，简直方便到爆。</p></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p>PicGo配置(使用github图传，免费方便，同时配合github.io博客真是方便)</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620173723.png" alt=""></p></li></ul><p>选上必填的就ok,一开始不知道token的设置，附赠token获取方法</p><p>图片上传相关的设置</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620173650.png" alt=""></p><p>链接格式：选择适合自己的，一般用户md文件中，选第一个，然后就可以疯狂使用了。</p><h3 id="使用github图传，获取token"><a href="#使用github图传，获取token" class="headerlink" title="使用github图传，获取token"></a>使用github图传，获取token</h3><p>在github-&gt;setting-&gt;developer settings 选择generate new token</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620170732.png" alt=""></p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620171238.png" alt=""></p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620173443.png" alt=""></p><p>勾选好之后生成就好了</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>PicGo使用，简直方便</p><p>1).默认网页上直接右键复制图片</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620172136.png" alt=""></p><p>2).点击等待中的图片，开始上传</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620172046.png" alt=""></p><p>3).上传完之后有个提示，同时粘贴板也会自动粘贴上</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620173543.png" alt=""></p><p>4).直接粘贴到想要的地方</p><p>或者也可以直接截图，然后点击图片里的图片上传，很方便</p></li><li><p>PicGo上传动图gif</p><p>如果直接复制网页上的动图，去上传的话是截取的某帧，是静图。应该下载到本地，然后在拖进去上传就可以了。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;对于每一个写博客的人来说，图片是至关重要。这一路经历了多次图片的烦恼，之前选择了微博个人文章那里粘贴图片的方式上传，感觉也挺方便的。但是由于新浪的图片显示问题，如果header中不设置&lt;!-- &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; 解决图片过期问题--&gt; 标签就不能异步访问图片，导致图裂，那之恶心。然而设置之后又与网站访客统计的插件冲突，使之不能统计，真是神仙打架。无赖之下使用了PicGo工具，使用后感觉真XX方便！&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具教程" scheme="https://removeif.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
      <category term="主题工具" scheme="https://removeif.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具教程" scheme="https://removeif.github.io/tags/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>阿里一年的成长经历</title>
    <link href="https://removeif.github.io/2019/06/13/%E9%98%BF%E9%87%8C%E4%B8%80%E5%B9%B4%E7%9A%84%E6%88%90%E9%95%BF%E7%BB%8F%E5%8E%86.html"/>
    <id>https://removeif.github.io/2019/06/13/阿里一年的成长经历.html</id>
    <published>2019-06-13T03:23:16.000Z</published>
    <updated>2019-08-16T09:13:50.747Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>任何工作一定对个人都是有提升的，但是不会总结的人，在每个项目/需求中成长的东西都是散的，久而久之就忘了。通过充分的总结之后，犯过的错误我们不会二次再犯，理清楚的业务的来龙去脉铭记在心，对自己是一种提升，分享给别人对别人也是很大的帮助。<br>失败者失败的原因各有不同，成功者的做事方式总是相似的，从宏观角度去看，我认为总结就是成功者之所以能成功，很重要一个原因。<br><a id="more"></a></p></blockquote><h2 id="应当如何面对线上的异常-故障"><a href="#应当如何面对线上的异常-故障" class="headerlink" title="应当如何面对线上的异常/故障"></a>应当如何面对线上的异常/故障</h2><p>看起来毫无意义的一个问题，碰到线上异常/故障如何面对，排查解决了不就好了，但是这真的只是第一层</p><p>最近在想“消防”这个词语很有意思，它其实是两层意思：</p><ul><li>“消”是消除问题</li><li>“防”是防止问题</li></ul><p>即“消防”这个词语表达的意思应该是先消除问题再防止相同的问题再次发生。其实线上的异常/故障也是同样的道理，我们应当先及时止血，把问题处理掉，然后深挖问题，探究根因，举几个例子：</p><ul><li>假设是某段代码的空指针异常导致的，那么是否考虑加强Code Review，或者使用findbugs插件去自动扫描代码中可能的异常？</li><li>假设是线上某个配置修改导致的，那么是否今后变更的修改必须有人双重检查一遍才可以修改？</li><li>假设是本地内存中某些值因为系统重启丢失导致的，那么是否引入定时任务，定时把值写入本地内存中？</li><li>假设是某段代码逻辑没测试到导致的，那么是否可以反思总结为什么这段逻辑没有测试到，未来的测试应该如何改进？</li></ul><p>根据我过往的经验，太多公司、太多团队处理线上的问题仅仅满足于把问题处理完就完事，忽略了对问题的复盘，这对团队/对公司的发展都是不利的。</p><h2 id="什么是真正的技术能力"><a href="#什么是真正的技术能力" class="headerlink" title="什么是真正的技术能力"></a>什么是真正的技术能力</h2><p>之前加了几个技术微信群，看到很多技术朋友在兴高采烈地讨论各种源码，spring源码我彻底撸了一遍、最近深入学习了dubbo底层实现方式，当然曾经的我也是这样的，记得学习volatile的时候一直挖到了volatile在硬件层面上的实现方式，但是这真的说明技术能力强吗？从今天的思考去看这个问题，我认为这更多反应的是一个人的学习能力、钻研能力以及对技术的热情，除此之外再体现不出太多其他东西了。</p><p>这个话题，可能是这一年思考的最多个的一个点，钻研是好事，但是实际上大多时候的深入钻研并不在实际工作中有用，且研究得越深，忘得越快，因为研究得越深，那么这个技术点关联的技术点就越多，边边角角的忘了，核心的东西不容易串起来。那么什么是真正的技术能力，我画一张图概括一下：</p><blockquote><p>技术能力=解决问题的能力(解决当下问题+解决长远问题)</p></blockquote><p>简而言之，技术能力 = 解决问题的能力，那么同样都在解决问题，大家之间的技术高低又有什么区分呢？我认为有以下几个层次：</p><ul><li>第一层级，解决当下问题</li><li>第二层级，以优雅且可复用的方式解决当下问题</li><li>第三层级，解决的问题不仅仅能满足当下，还能满足未来一段时间</li></ul><p>其实从这个角度上来看，不同的技术能力，在工作过程中区分度是很明显的：</p><ul><li>写的代码是否存在异常风险，多线程运行下是否存在线程安全问题，某段代码是否会导致内存泄露</li><li>写的代码是否优雅可复用，设计的框架是否足够符合开闭原则，代码结构层次是否清晰明了</li><li>针对特定的场景，技术选型、库表结构设计是否足够合理，今天你设计的框架是只能用一年，还是未来三年五年都可以持续使用</li><li>来了一个大的需求，就比如做一个App的会员体系功能好了，是否可以在充分分析需求后，精确将需求划分为几个特定的子模块并梳理清楚模块之间的关系</li></ul><p>越厉害的人，在代码设计与开发过程中，越能看到想到一些别人看不到想不到的问题，这叫做高屋建瓴；当代码运行出现问题的时候，有人1小时排查出问题，有人1分钟发现问题，这叫做举重若轻。</p><p>因此我认为<strong>解决问题的能力才是技术能力的真正体现</strong>，这一年对技术的探究我也从研究源码更多的转变去学习设计模式、去学习分布式环境下各种NoSql的选型对比、去学习使用Lambda让代码更简洁，往真正在实际工作中解决问题的方向去努力。</p><p>另外，抛开这个点，这两天我在思考，还有一个体现技术能力的点，就是<strong>学习能力</strong>。现实中的全栈是很少的，互联网这个行业的程序员的方向通常有几类：</p><ul><li>服务端</li><li>前端</li><li>移动端</li><li>AI</li><li>嵌入式</li><li>大数据</li></ul><p>在同一类中，基础知识、基本概念、思维方向是一致的，更多可能差异在开发工具、语言上，我精通Java，但是如果明天有一个需求，使用nodejs、scala、go更好，那么是否可以快速学习、快速上手？甚至明天有一个需求需要写前端代码，是否可以快速开发、无bug上线？</p><p>所以，解决问题的能力 + 学习能力，是我认为真正的技术能力，不过说到底，学习能力某种程度上也只是为了解决问题而已。</p><h2 id="不要造轮子"><a href="#不要造轮子" class="headerlink" title="不要造轮子"></a>不要造轮子</h2><p>曾几何时，当我们看着github上这么多优秀的源代码的时候，默默立誓，这辈子我一定要写出一个牛逼的框架，开源在网上。</p><p>曾几何时，公司招聘的时候，技术负责人激情满满地介绍着公司内部自研了多少系统并在线上投入使用。</p><p>很多对技术有追求的朋友，进入一家公司可能时时刻刻在寻找机会去做一些自己造轮子的事情，但是就如同前面所说的，衡量真正好技术的标准就是能否实实在在地解决问题，自己造轮子风险高、周期长，且需要长时间的验证、排坑才能达到比较好的效果。</p><p>随便举几个例子，在互联网发展的今天：</p><ul><li>数据库连接池有dbcp、c3p0、druid</li><li>本地缓存有ehcache、要用中心缓存有redis、tail</li><li>服务化有dubbo、跨语言可以用thrift</li><li>分布式任务调度可以考虑schedulex</li><li>搜索可以选es、solr</li><li>更高级一点图片存储可以用七牛、im可以用融云/环信、音视频这块声网做得比较成熟，所有这些都提供了各个开发版本的sdk，接入简单</li></ul><p>只要你有的技术方面的需求，绝大多数业界已经有了成熟的解决方案了，根本不需要去专门自己搞一套。因此我认为轻易一定不要造轮子，如果一定要造轮子，那么请想清楚下面几个问题：</p><ul><li>你要做的事情是否当前已经有了类似解决方案？</li><li>如果有，那么你自己做的这一套东西和类似解决方案的差异点在哪里？假设不用你这套，基于已有的解决方案稍加改造是否就能达到目的？</li><li>如果没有，那么为什么之前没有？是你们公司这种场景是独一无二的？还是这种场景对应的解决方案根本就是不可行的所以之前没人去搞？</li></ul><p>如果想清楚了这些问题，那么就去干吧。</p><h2 id="去提升看问题的高度"><a href="#去提升看问题的高度" class="headerlink" title="去提升看问题的高度"></a>去提升看问题的高度</h2><p>过去有太多人在我的公众号或者博客下反馈了一个问题：在这个公司，整天做着增删改查的工作，对自己一点都没有提高。</p><p>对于这种看法，说难听点就是四个字—-目光短浅。我们看：<br><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620153626.png" alt=""><br>如果以普通的视角去看，那么一颗树那也就只是一棵树而已，但是如果跳脱出目前的视角，站在更高的角度去看，它其实是森林的一部分。你的主管并不是因为他是你的主管所以他就应该你比更高瞻远瞩，而是因为他看问题的高度比你更高、想得更远、做得更深，所以才成为了你的主管。</p><p>把这个问题说得实际点：</p><ul><li>假设今天你负责的是一个系统，那么你仅仅是把这个系统的基本原理搞懂了？还是可以把上下游有几个系统、每个系统之间如何调用、依赖方式都理顺？</li><li>假设今天你负责的是一块业务，那么你仅仅把自己负责的功能点弄清楚了？还是你可以从最上游开始，到你负责的系统，再到最下游，都思考得非常透彻？</li></ul><p>今天与其在抱怨没有机会、抱怨公司对自己能力没有提升，为什么不去思考机会为什么降临在别人头上不降临在你头上？为什么别人可以从小公司写着一样的增删改查走向BAT而你年复一年还在小公司写着增删改查？当你真正能转变自己的思维模式，跳脱出现在的圈子往更高一个层次去看问题、去提升自己，我相信总会有发光发热的一天的。</p><p>同样在阿里巴巴，马老师思考自然、思考环保、思考人类的发展，你的主管思考团队未来的方向和打法，我们在思考如何把某个客户需求完整落地，这就是高度，你未必能想到马老师想的，但是你对标层级高一点的人，一步一步尝试往他们的高度去靠。</p><p>总而言之：眼界决定高度，多看、多想、多保持好奇心、多问几个为什么，久而久之自然就迈上了一个新的台阶。</p><h2 id="学会总结"><a href="#学会总结" class="headerlink" title="学会总结"></a>学会总结</h2><p>需求、项目的复盘是非常重要的一部分内容，然而我之前见过的太多团队、太多Leader，只顾着一个迭代接着一个迭代，一个版本接着一个版本，只满足于把需求做好，而忽略了总结的重要性。</p><p>我认为大到项目、小到需求，如果在完成之后缺乏总结那么某种程度上来说是失败的，可以总结的点非常多：</p><ul><li>通过这个项目/需求，是否吃透了某一块业务，搞懂了来龙去脉</li><li>通过这个项目/需求，是否充分理解了公司某个技术框架/基础组件的用法</li><li>在整个项目的设计上，有哪些做的不好的地方</li><li>在整个项目的开发（针对程序员而言），是否踩了坑，犯了低级的错误</li><li>在整个项目的进度把控上、人员安排上、上下游协调上，是否存在不足之处</li><li>经历了某次大促的值班，是否对可以熟练使用公司的监控工具，遇到突发事件，是否快速有效地进行了解决</li></ul><p>任何工作一定对个人都是有提升的，但是不会总结的人，在每个项目/需求中成长的东西都是散的，久而久之就忘了。通过充分的总结之后，犯过的错误我们不会二次再犯，理清楚的业务的来龙去脉铭记在心，对自己是一种提升，分享给别人对别人也是很大的帮助。</p><p>失败者失败的原因各有不同，成功者的做事方式总是相似的，从宏观角度去看，我认为总结就是成功者之所以能成功，很重要一个原因。</p><p><a href="https://mp.weixin.qq.com/s/ZGEbg2ZgU2O3L7GOsXkTug" target="_blank" rel="noopener">参考资料</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;任何工作一定对个人都是有提升的，但是不会总结的人，在每个项目/需求中成长的东西都是散的，久而久之就忘了。通过充分的总结之后，犯过的错误我们不会二次再犯，理清楚的业务的来龙去脉铭记在心，对自己是一种提升，分享给别人对别人也是很大的帮助。&lt;br&gt;失败者失败的原因各有不同，成功者的做事方式总是相似的，从宏观角度去看，我认为总结就是成功者之所以能成功，很重要一个原因。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="经验成长" scheme="https://removeif.github.io/categories/%E7%BB%8F%E9%AA%8C%E6%88%90%E9%95%BF/"/>
    
    
      <category term="经验成长" scheme="https://removeif.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据库索引解析</title>
    <link href="https://removeif.github.io/2019/06/04/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%A7%A3%E6%9E%90.html"/>
    <id>https://removeif.github.io/2019/06/04/mysql数据库索引解析.html</id>
    <published>2019-06-04T11:36:04.000Z</published>
    <updated>2019-08-16T09:13:50.685Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>看了很多关于索引的博客，讲的大同小异。但是始终没有让我明白关于索引的一些概念，如B-Tree索引，Hash索引，唯一索引….或许有很多人和我一样，没搞清楚概念就开始研究B-Tree，B+Tree等结构，导致在面试的时候答非所问！<br><a id="more"></a></p></blockquote><h3 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么?"></a>索引是什么?</h3><p>索引是帮助MySQL高效获取数据的数据结构。</p><h3 id="索引能干什么"><a href="#索引能干什么" class="headerlink" title="索引能干什么?"></a>索引能干什么?</h3><p>索引非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。 索引能够轻易将查询性能提高好几个数量级，总的来说就是可以明显的提高查询效率。</p><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类?"></a>索引的分类?</h3><ol><li><p>从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，</p></li><li><p>从应用层次来分：普通索引，唯一索引，复合索引</p></li><li><p>根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。</p></li></ol><p>平时讲的索引类型一般是指在应用层次的划分。就像手机分类：安卓手机，IOS手机 与 华为手机，苹果手机，OPPO手机一样。</p><p><strong>普通索引**</strong>：**即一个索引只包含单个列，一个表可以有多个单列索引</p><p><strong>唯一索引：</strong>索引列的值必须唯一，但允许有空值</p><p><strong>复合索引：</strong>多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</p><p><strong>聚簇索引(聚集索引)：</strong>并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。</p><p><strong>非聚簇索引：</strong>不是聚簇索引，就是非聚簇索引</p><h3 id="索引的底层实现"><a href="#索引的底层实现" class="headerlink" title="索引的底层实现"></a>索引的底层实现</h3><p>mysql默认存储引擎innodb只显式支持B-Tree( 从技术上来说是B+Tree)索引，对于频繁访问的表，innodb会透明建立自适应hash索引，即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。</p><p>不谈存储引擎，只讨论实现(抽象)</p><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p>基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620153804.png" alt=""></p><h4 id="B-Tree索引（MySQL使用B-Tree）"><a href="#B-Tree索引（MySQL使用B-Tree）" class="headerlink" title="B-Tree索引（MySQL使用B+Tree）"></a>B-Tree索引（MySQL使用B+Tree）</h4><p>B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620153834.png" alt=""></p><p>B+Tree索引</p><p>是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620153924.png" alt=""></p><p>结合存储引擎来讨论（一般默认使用B+Tree）</p><p>案例：假设有一张学生表，id为主键</p><table><thead><tr><th style="text-align:left">id</th><th style="text-align:left">name</th><th style="text-align:left">birthday</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">Tom</td><td style="text-align:left">1996-01-01</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">Jann</td><td style="text-align:left">1996-01-04</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">Ray</td><td style="text-align:left">1996-01-08</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">Michael</td><td style="text-align:left">1996-01-10</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">Jack</td><td style="text-align:left">1996-01-13</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">Steven</td><td style="text-align:left">1996-01-23</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">Lily</td><td style="text-align:left">1996-01-25</td></tr></tbody></table><p><strong>在MyISAM引擎中的实现</strong>（二级索引也是这样实现的）</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620153946.png" alt=""></p><p>在InnoDB中的实现</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620154003.png" alt=""></p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620154020.png" alt=""></p><h3 id="为什么索引结构默认使用B-Tree，而不是Hash，二叉树，红黑树？"><a href="#为什么索引结构默认使用B-Tree，而不是Hash，二叉树，红黑树？" class="headerlink" title="为什么索引结构默认使用B+Tree，而不是Hash，二叉树，红黑树？"></a>为什么索引结构默认使用B+Tree，而不是Hash，二叉树，红黑树？</h3><p>B+tree：因为B树<strong>不管叶子节点还是非叶子节点，都会保存数据</strong>，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；</p><p>Hash：虽然可以快速定位，但是没有顺序，IO复杂度高。</p><p>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。</p><p>红黑树：树的高度随着数据量增加而增加，IO代价高。</p><blockquote><p>红黑树:</p><ol><li>每个节点或者是黑色，或者是红色。</li><li>根节点是黑色。</li><li>每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</li><li>如果一个节点是红色的，则它的子节点必须是黑色的。</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li></ol></blockquote><h3 id="为什么官方建议使用自增长主键作为索引？"><a href="#为什么官方建议使用自增长主键作为索引？" class="headerlink" title="为什么官方建议使用自增长主键作为索引？"></a>为什么官方建议使用自增长主键作为索引？</h3><p>结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。</p><p>插入连续的数据：</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/b5d1b710ly4g3pc5ln9mmg20di04fjsq.gif" alt=""></p><p>插入非连续的数据</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/b5d1b710ly4g3pc6246isg20di04fjwr.gif" alt=""></p><h3 id="简单总结下"><a href="#简单总结下" class="headerlink" title="简单总结下"></a>简单总结下</h3><ol><li>MySQL使用B+Tree作为索引数据结构。 </li><li>B+Tree在新增数据时，会根据索引指定列的值对旧的B+Tree做调整。</li><li>从物理存储结构上说，B-Tree和B+Tree都以页(4K)来划分节点的大小，但是由于B+Tree中中间节点不存储数据，因此B+Tree能够在同样大小的节点中，存储更多的key，提高查找效率。 </li><li>影响MySQL查找性能的主要还是磁盘IO次数，大部分是磁头移动到指定磁道的时间花费。</li><li>MyISAM存储引擎下索引和数据存储是分离的，InnoDB索引和数据存储在一起。 </li><li>InnoDB存储引擎下索引的实现，(辅助索引)全部是依赖于主索引建立的(辅助索引中叶子结点存储的并不是数据的地址，还是主索引的值，因此，所有依赖于辅助索引的都是先根据辅助索引查到主索引，再根据主索引查数据的地址)。 </li><li>由于InnoDB索引的特性，因此如果主索引不是自增的(id作主键)，那么每次插入新的数据，都很可能对B+Tree的主索引进行重整，影响性能。因此，尽量以自增id作为InnoDB的主索引。</li></ol><h2 id="InnoDB一棵B-树能存多少行数据？为什么要用B-树？而不是其他树？"><a href="#InnoDB一棵B-树能存多少行数据？为什么要用B-树？而不是其他树？" class="headerlink" title="InnoDB一棵B+树能存多少行数据？为什么要用B+树？而不是其他树？"></a>InnoDB一棵B+树能存多少行数据？为什么要用B+树？而不是其他树？</h2><p>InnoDB一棵B+树可以存放多少行数据？这个问题的简单回答是：约2千万。为什么是这么多呢？因为这是可以算出来的，要搞清楚这个问题，我们先从InnoDB索引数据结构、数据组织方式说起。</p><p>我们都知道计算机在存储数据的时候，有最小存储单元，这就好比我们今天进行现金的流通最小单位是一毛。在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是512字节，而文件系统（例如XFS/EXT4）他的最小单元是块，一个块的大小是4k，而对于我们的InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小是16K。</p><p>innodb的所有数据文件（后缀为ibd的文件），他的大小始终都是16384（16k）的整数倍。</p><p>磁盘扇区、文件系统、InnoDB存储引擎都有各自的最小存储单元。</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620154236.png" alt=""></p><p>在MySQL中我们的InnoDB页的大小默认是16k，当然也可以通过参数设置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like </span><br><span class="line">&apos;innodb_page_size&apos;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name| Value|</span><br><span class="line">+------------------+-------+</span><br><span class="line">| innodb_page_size | 16384|</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set(0.00sec)</span><br></pre></td></tr></table></figure><p>数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一行数据的大小是1k，那么一个页可以存放16行这样的数据。</p><p>如果数据库只按这样的方式存储，那么如何查找数据就成为一个问题，因为我们不知道要查找的数据存在哪个页中，也不可能把所有的页遍历一遍，那样太慢了。所以人们想了一个办法，用B+树的方式组织这些数据。如图所示：</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620154344.png" alt=""></p><p>我们先将数据记录按主键进行排序，分别存放在不同的页中（为了便于理解我们这里一个页中只存放3条记录，实际情况可以存放很多），除了存放数据的页以外，还有存放键值+指针的页，如图中page number=3的页，该页存放键值和指向数据页的指针，这样的页由N个键值+指针组成。当然它也是排好序的。这样的数据组织形式，我们称为索引组织表。现在来看下，要查找一条数据，怎么查？</p><p>如<strong>select * from user where id=5</strong>;</p><p>这里id是主键,我们通过这棵B+树来查找，首先找到根页，你怎么知道user表的根页在哪呢？其实每张表的根页位置在表空间文件中是固定的，即page number=3的页（这点我们下文还会进一步证明），找到根页后通过二分查找法，定位到id=5的数据应该在指针P5指向的页中，那么进一步去page number=5的页中查找，同样通过二分查询法即可找到id=5的记录：</p><p><strong>| 5 | zhao2 | 27 |</strong></p><p>现在我们清楚了InnoDB中主键索引B+树是如何组织数据、查询数据的，我们总结一下：</p><p>1、InnoDB存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值+指针，在B+树中叶子节点存放数据，非叶子节点存放键值+指针。</p><p>2、索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据；</p><h3 id="那么回到我们开始的问题，通常一棵B-树可以存放多少行数据？"><a href="#那么回到我们开始的问题，通常一棵B-树可以存放多少行数据？" class="headerlink" title="那么回到我们开始的问题，通常一棵B+树可以存放多少行数据？"></a>那么回到我们开始的问题，通常一棵B+树可以存放多少行数据？</h3><p>这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：<strong>根节点指针数*单个叶子节点记录行数</strong>。</p><p>上文我们已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右）。</p><p><strong>那么现在我们需要计算出非叶子节点能存放多少指针？</strong></p><p>其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即<strong>16384/14=1170</strong>。那么可以算出一棵高度为2的B+树，能存放<strong>1170*16=18720</strong>条这样的数据记录。</p><p><strong>根据同样的原理我们可以算出一个高度为3的B+树可以存放</strong>：<strong>1170*1170*16=21902400</strong>条这样的记录。</p><p>所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。</p><h3 id="怎么得到InnoDB主键索引B-树的高度？"><a href="#怎么得到InnoDB主键索引B-树的高度？" class="headerlink" title="怎么得到InnoDB主键索引B+树的高度？"></a>怎么得到InnoDB主键索引B+树的高度？</h3><p>上面我们通过推断得出B+树的高度通常是1-3，下面我们从另外一个侧面证明这个结论。在InnoDB的表空间文件中，约定<strong>page number为3</strong>的代表主键索引的根页，而在根页偏移量为<strong>64</strong>的地方存放了该B+树的page level。如果page level为1，树高为2，page level为2，则树高为3。即B+树的高度=page level+1；下面我们将从实际环境中尝试找到这个page level。</p><p>在实际操作之前，你可以通过InnoDB元数据表确认主键索引根页的page number为3，你也可以从《InnoDB存储引擎》这本书中得到确认。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">b.name, a.name, index_id, type, a.space, a.PAGE_NO</span><br><span class="line">FROM</span><br><span class="line">information_schema.INNODB_SYS_INDEXES a,</span><br><span class="line">information_schema.INNODB_SYS_TABLES b</span><br><span class="line">WHERE</span><br><span class="line">a.table_id = b.table_id AND a.space &lt;&gt; 0;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620154405.png" alt=""></p><p>可以看出数据库dbt3下的customer表、lineitem表主键索引根页的page number均为3，而其他的二级索引page number为4。关于二级索引与主键索引的区别请参考MySQL相关书籍，本文不在此介绍。</p><p><strong>下面我们对数据库表空间文件做想相关的解析：</strong></p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620154422.png" alt=""></p><p>因为主键索引B+树的根页在整个表空间文件中的第3个页开始，所以可以算出它在文件中的偏移量：<strong>16384*3=49152（16384为页大小）</strong>。</p><p>另外根据《InnoDB存储引擎》中描述在根页的64偏移量位置前2个字节，保存了page level的值，因此我们想要的page level的值在整个文件中的偏移量为：<strong>16384*3+64=49152+64=49216</strong>，前2个字节中。</p><p><strong>接下来我们用hexdump工具，查看表空间文件指定偏移量上的数据：</strong></p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620154438.png" alt=""></p><p><strong>linetem表的page level为2，B+树高度为page level+1=3；**</strong>region表的page level为0，B+树高度为page level+1=1；<strong>**customer表的page level为2，B+树高度为page level+1=3；</strong></p><p><strong>这三张表的数据量如下：</strong></p><p><img src="https://raw.githubusercontent.com/removeif/blog_image/master/20190620154455.png" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>lineitem表的数据行数为600多万，B+树高度为3，customer表数据行数只有15万，B+树高度也为3。可以看出尽管数据量差异较大，这两个表树的高度都是3，换句话说这两个表通过索引查询效率并没有太大差异，因为都只需要做3次IO。那么如果有一张表行数是一千万，那么他的B+树高度依旧是3，查询效率仍然不会相差太大。</p><p>region表只有5行数据，当然他的B+树高度为1。</p><h3 id="最后回顾一道面试题"><a href="#最后回顾一道面试题" class="headerlink" title="最后回顾一道面试题"></a>最后回顾一道面试题</h3><p>有一道MySQL的面试题，为什么MySQL的索引要使用B+树而不是其它树形结构？比如B树？</p><p>现在这个问题的复杂版本可以参考本文；</p><p><strong>他的简单版本回答是：</strong></p><p>因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文从一个问题出发，逐步介绍了InnoDB索引组织表的原理、查询方式，并结合已有知识，回答该问题，结合实践来证明。当然为了表述简单易懂，文中忽略了一些细枝末节，比如一个页中不可能所有空间都用于存放数据，它还会存放一些少量的其他字段比如page level，index number等等，另外还有页的填充因子也导致一个页不可能全部用于保存数据。关于二级索引数据存取方式可以参考MySQL相关书籍，他的要点是结合主键索引进行回表查询。<br><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&amp;mid=2452966459&amp;idx=1&amp;sn=91fd510de84bed68067bfcf94808f2ae&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">参考</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&amp;mid=2452966459&amp;idx=1&amp;sn=91fd510de84bed68067bfcf94808f2ae&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;看了很多关于索引的博客，讲的大同小异。但是始终没有让我明白关于索引的一些概念，如B-Tree索引，Hash索引，唯一索引….或许有很多人和我一样，没搞清楚概念就开始研究B-Tree，B+Tree等结构，导致在面试的时候答非所问！&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="mysql" scheme="https://removeif.github.io/tags/mysql/"/>
    
      <category term="索引" scheme="https://removeif.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
</feed>
