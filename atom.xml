<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>辣椒の酱</title>
  
  <subtitle>尚未执佩剑，转眼即江湖</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://removeif.github.io/"/>
  <updated>2019-12-11T01:49:16.996Z</updated>
  <id>https://removeif.github.io/</id>
  
  <author>
    <name>辣椒の酱</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法成长之路leetcode7-8</title>
    <link href="https://removeif.github.io/2019/12/10/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode7-8.html"/>
    <id>https://removeif.github.io/2019/12/10/algorithm/算法成长之路leetcode7-8.html</id>
    <published>2019-12-10T15:36:42.000Z</published>
    <updated>2019-12-11T01:49:16.996Z</updated>
    
    <content type="html"><![CDATA[<h3 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7. Reverse Integer</a></h3><p>Given a 32-bit signed integer, reverse digits of an integer.<br><a id="more"></a></p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure><p>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><h4 id="JAVA题解"><a href="#JAVA题解" class="headerlink" title="JAVA题解"></a>JAVA题解</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leetcode7</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * 示例 1:</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * 输入: 123</span></span><br><span class="line"><span class="hljs-comment">     * 输出: 321</span></span><br><span class="line"><span class="hljs-comment">     *  示例 2:</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * 输入: -123</span></span><br><span class="line"><span class="hljs-comment">     * 输出: -321</span></span><br><span class="line"><span class="hljs-comment">     * 示例 3:</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * 输入: 120</span></span><br><span class="line"><span class="hljs-comment">     * 输出: 21</span></span><br><span class="line"><span class="hljs-comment">     * 注意:</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment">     * 链接：https://leetcode-cn.com/problems/reverse-integer</span></span><br><span class="line"><span class="hljs-comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (x &gt; Integer.MAX_VALUE || x &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">boolean</span> isNe = x &lt; <span class="hljs-number">0</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;</span><br><span class="line">        x = Math.abs(x);</span><br><span class="line">        <span class="hljs-comment">// 取绝对值时越界了，直接返回0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (isNe &amp;&amp; x &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="hljs-keyword">long</span> m = <span class="hljs-number">10</span>;</span><br><span class="line">        <span class="hljs-keyword">long</span> base = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;</span><br><span class="line">            base = m * base;</span><br><span class="line">            <span class="hljs-keyword">long</span> re = x % base;</span><br><span class="line">            <span class="hljs-keyword">if</span> (base == <span class="hljs-number">10</span>) &#123;</span><br><span class="line">                sb.append(re);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                sb.append((re * m) / base);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (x &lt; base) &#123;</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Long res;</span><br><span class="line">        <span class="hljs-keyword">if</span> (isNe) &#123;</span><br><span class="line">            res = <span class="hljs-number">0</span> - Long.parseLong(sb.toString());</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            res = Long.parseLong(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> res.intValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> rev = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> pop = x % <span class="hljs-number">10</span>;</span><br><span class="line">            x /= <span class="hljs-number">10</span>;</span><br><span class="line">            <span class="hljs-comment">// Integer.MAX_VALUE = 2147483647,因为后面 rev = rev * 10 + pop，所以rev &gt;Integer.MAX_VALUE 溢出</span></span><br><span class="line">            <span class="hljs-comment">// rev == Integer.MAX_VALUE / 10 时，Integer.MAX_VALUE / 10 = 2147483640,so,pop &gt; 7时溢出</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (rev &gt; Integer.MAX_VALUE / <span class="hljs-number">10</span> || (rev == Integer.MAX_VALUE / <span class="hljs-number">10</span> &amp;&amp; pop &gt; <span class="hljs-number">7</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-comment">// Integer.MIN_VALUE = -2147483648</span></span><br><span class="line">            <span class="hljs-comment">// 同理如上</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (rev &lt; Integer.MIN_VALUE / <span class="hljs-number">10</span> || (rev == Integer.MIN_VALUE / <span class="hljs-number">10</span> &amp;&amp; pop &lt; -<span class="hljs-number">8</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">            rev = rev * <span class="hljs-number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Integer.MAX_VALUE);</span><br><span class="line"><span class="hljs-comment">//        System.out.println(reverse1(123));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. String to Integer (atoi)</a></h3><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p>Note:</p><p>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical </span><br><span class="line">             digit or a +/- sign. Therefore no valid conversion could be performed.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−2^31) is returned.</span><br></pre></td></tr></table></figure><h4 id="JAVA题解-1"><a href="#JAVA题解-1" class="headerlink" title="JAVA题解"></a>JAVA题解</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leetcode8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     *请你来实现一个 atoi 函数，使其能将字符串转换成整数。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 在任何情况下，若函数不能进行有效的转换时，请返回 0。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 说明：</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 示例 1:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: "42"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: 42</span></span><br><span class="line"><span class="hljs-comment">     * 示例 2:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: "   -42"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: -42</span></span><br><span class="line"><span class="hljs-comment">     * 解释: 第一个非空白字符为 '-', 它是一个负号。</span></span><br><span class="line"><span class="hljs-comment">     *      我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span></span><br><span class="line"><span class="hljs-comment">     * 示例 3:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: "4193 with words"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: 4193</span></span><br><span class="line"><span class="hljs-comment">     * 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。</span></span><br><span class="line"><span class="hljs-comment">     * 示例 4:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: "words and 987"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: 0</span></span><br><span class="line"><span class="hljs-comment">     * 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。</span></span><br><span class="line"><span class="hljs-comment">     *      因此无法执行有效的转换。</span></span><br><span class="line"><span class="hljs-comment">     * 示例 5:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: "-91283472332"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: -2147483648</span></span><br><span class="line"><span class="hljs-comment">     * 解释: 数字 "-91283472332" 超过 32 位有符号整数范围。</span></span><br><span class="line"><span class="hljs-comment">     *      因此返回 INT_MIN (−2^31) 。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment">     * 链接：https://leetcode-cn.com/problems/string-to-integer-atoi</span></span><br><span class="line"><span class="hljs-comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(String str)</span> </span>&#123;</span><br><span class="line">        StringBuilder st = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">char</span> c = str.charAt(i);</span><br><span class="line">            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (st.length() &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                st.append(c);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'+'</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (st.length() &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                st.append(c);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">' '</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (st.length() &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-number">48</span> &amp;&amp; c &lt;= <span class="hljs-number">57</span>) &#123;</span><br><span class="line">                st.append(c);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (st.length() &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (Long.parseLong(st.toString()) &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">if</span> (Long.parseLong(st.toString()) &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (st.length() == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (st.toString().equals(<span class="hljs-string">"-"</span>) || st.toString().equals(<span class="hljs-string">"+"</span>)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> Long.valueOf(st.toString()).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi1</span><span class="hljs-params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (str.isEmpty())</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">char</span>[] mychar = str.toCharArray();</span><br><span class="line">        <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>, flag = <span class="hljs-number">1</span>, n = str.length();</span><br><span class="line">        <span class="hljs-comment">//排除字符串开头的空格元素</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (index &lt; n &amp;&amp; mychar[index] == <span class="hljs-string">' '</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//排除空格后判断首字符是+还是-还是都不是</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (index &lt; n &amp;&amp; mychar[index] == <span class="hljs-string">'+'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; n &amp;&amp; mychar[index] == <span class="hljs-string">'-'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            flag = -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//重点：只管是数字的时候，其余取0</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (index &lt; n &amp;&amp; (mychar[index] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; mychar[index] &lt;= <span class="hljs-string">'9'</span>)) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (ans != (<span class="hljs-keyword">int</span>) ans) &#123;<span class="hljs-comment">//超出int范围</span></span><br><span class="line">                <span class="hljs-keyword">return</span> (flag == <span class="hljs-number">1</span>) ? Integer.MAX_VALUE : Integer.MIN_VALUE;<span class="hljs-comment">//提前结束</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">// 巧妙的加起来值来 如 111 ，第一个1时 ans = 0 * 10 +1,第二个1时 ans = 1*10 + 1 = 11,第三个1时， ans = 11*10 + 1 = 111;</span></span><br><span class="line">            ans = ans * <span class="hljs-number">10</span> + mychar[index++] - <span class="hljs-string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="hljs-comment">// 强转long是否等于int 判断是否超界，机智</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (ans != (<span class="hljs-keyword">int</span>) ans) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> (flag == <span class="hljs-number">1</span>) ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (ans * flag);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">         * "42"</span></span><br><span class="line"><span class="hljs-comment">         * "----01"</span></span><br><span class="line"><span class="hljs-comment">         * "0-1"</span></span><br><span class="line"><span class="hljs-comment">         * "-5-"</span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">        System.out.println(myAtoi(<span class="hljs-string">"0-1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;7-Reverse-Integer&quot;&gt;&lt;a href=&quot;#7-Reverse-Integer&quot; class=&quot;headerlink&quot; title=&quot;7. Reverse Integer&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;7. Reverse Integer&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Given a 32-bit signed integer, reverse digits of an integer.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://removeif.github.io/categories/algorithm/"/>
    
    
      <category term="反转整数" scheme="https://removeif.github.io/tags/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    
      <category term="字符串转整数" scheme="https://removeif.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>mysql-b+Tree索引</title>
    <link href="https://removeif.github.io/2019/12/10/database/mysql/mysql-b-Tree%E7%B4%A2%E5%BC%95.html"/>
    <id>https://removeif.github.io/2019/12/10/database/mysql/mysql-b-Tree索引.html</id>
    <published>2019-12-10T10:36:42.000Z</published>
    <updated>2019-12-10T15:38:13.489Z</updated>
    
    <content type="html"><![CDATA[<p>索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。<br>索引最形象的比喻就是图书的目录了。注意这里的大量，数据量大了索引才显得有意义，如果我想要在 [1,2,3,4] 中找到 4 这个数据，直接对全数据检索也很快，没有必要费力气建索引再去查找。</p><p>索引在 MySQL 数据库中分三类：</p><ul><li>B+ 树索引</li><li>Hash 索引</li><li>全文索引<a id="more"></a></li></ul><p>我们今天要介绍的是工作开发中最常接触到的 InnoDB 存储引擎中的 B+ 树索引。要介绍 B+ 树索引，就不得不提二叉查找树，平衡二叉树和 B 树这三种数据结构。B+ 树就是从他们仨演化来的。</p><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>首先，让我们先看一张图：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180008.png" alt=""></p><p>从图中可以看到，我们为 user 表（用户信息表）建立了一个二叉查找树的索引。</p><p>图中的圆为二叉查找树的节点，节点中存储了键（key）和数据（data）。键对应 user 表中的 id，数据对应 user 表中的行数据。</p><p>二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。</p><p>如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下：</p><ul><li>将根节点作为当前节点，把 12 与当前节点的键值 10 比较，12 大于 10，接下来我们把当前节点&gt;的右子节点作为当前节点。</li><li>继续把 12 和当前节点的键值 13 比较，发现 12 小于 13，把当前节点的左子节点作为当前节点。</li><li>把 12 和当前节点的键值 12 对比，12 等于 12，满足条件，我们从当前节点中取出 data，即 id=12，name=xm。</li></ul><p>利用二叉查找树我们只需要 3 次即可找到匹配的数据。如果在表中一条条的查找的话，我们需要 6 次才能找到。</p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>上面我们讲解了利用二叉查找树可以快速的找到数据。但是，如果上面的二叉查找树是这样的构造：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180050.png" alt=""></p><p>这个时候可以看到我们的二叉查找树变成了一个链表。如果我们需要查找 id=17 的用户信息，我们需要查找 7 次，也就相当于全表扫描了。 </p><p>导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。</p><p>为了解决这个问题，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树了。 </p><p>平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1。 </p><p>下面是平衡二叉树和非平衡二叉树的对比：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180118.png" alt=""></p><p>由平衡二叉树的构造我们可以发现第一张图中的二叉树其实就是一棵平衡二叉树。</p><p>平衡二叉树保证了树的构造是平衡的，当我们插入或删除数据导致不满足平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡。具体的调整方式这里就不介绍了。</p><p>平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h2><p>因为内存的易失性。一般情况下，我们都会选择将 user 表中的数据和索引存储在磁盘这种外围设备中。</p><p>但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取数据的次数。</p><p>另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。</p><p>如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。</p><p>如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块。</p><p>我们都知道平衡二叉树可是每个节点只存储一个键值和数据的。那说明什么？说明每个磁盘块仅仅存储一个键值和数据！那如果我们要存储海量的数据呢？</p><p>可以想象到二叉树的节点将会非常多，高度也会极其高，我们查找数据时也会进行很多次磁盘 IO，我们查找数据的效率将会极低！</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180204.png" alt=""></p><p>为了解决平衡二叉树的这个弊端，我们应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的 B 树。</p><p>B 树（Balance Tree）即为平衡树的意思，下图即是一棵 B 树：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180223.png" alt=""></p><p>图中的 p 节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有，因为图的美观性，被省略了。</p><p>图中的每个节点称为页，页就是我们上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合 MySQL 中索引的底层数据结构。</p><p>从上图可以看出，B 树相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的 B 树为 3 阶 B 树，高度也会很低。</p><p>基于这个特性，B 树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。</p><p>假如我们要查找 id=28 的用户信息，那么我们在上图 B 树中查找的流程如下：</p><ul><li>先找到根节点也就是页 1，判断 28 在键值 17 和 35 之间，那么我们根据页 1 中的指针 p2 找到页 3。</li><li>将 28 和页 3 中的键值相比较，28 在 26 和 30 之间，我们根据页 3 中的指针 p2 找到页 8。</li><li>将 28 和页 8 中的键值相比较，发现有匹配的键值 28，键值 28 对应的用户信息为（28，bv）。</li></ul><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h2><p>B+ 树是对 B 树的进一步优化。让我们先来看下 B+ 树的结构图：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180242.png" alt=""></p><p>根据上图我们来看下 B+ 树和 B 树有什么不同：</p><p>①B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。</p><p>之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。</p><p>如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。</p><p>另外，B+ 树的阶数是等于键值的数量的，如果我们的 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。</p><p>一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。</p><p>②因为 B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。</p><p>那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。</p><p>有心的读者可能还发现上图 B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。</p><p>其实上面的 B 树我们也可以对各个节点加上链表。这些不是它们之前的区别，是因为在 MySQL 的 InnoDB 存储引擎中，索引就是这样存储的。</p><p>也就是说上图中的 B+ 树索引就是 InnoDB 中 B+ 树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。</p><p>通过上图可以看到，在 InnoDB 中，我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。</p><p>MyISAM 中的 B+ 树索引实现与 InnoDB 中的略有不同。在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。</p><h2 id="聚集索引-VS-非聚集索引"><a href="#聚集索引-VS-非聚集索引" class="headerlink" title="聚集索引 VS 非聚集索引"></a>聚集索引 VS 非聚集索引</h2><p>在上节介绍 B+ 树索引的时候，我们提到了图中的索引其实是聚集索引的实现方式。</p><p>那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。</p><p>这里我们着重介绍 InnoDB 中的聚集索引和非聚集索引：</p><p><strong>①聚集索引（聚簇索引）：</strong>以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。</p><p>这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。</p><p>这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。</p><p><strong>②非聚集索引（非聚簇索引）：</strong>以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。</p><p>非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。</p><p>明白了聚集索引和非聚集索引的定义，我们应该明白这样一句话：数据即索引，索引即数据。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Innodb的存储索引是基于B+tree，理所当然，聚集索引也是基于B+tree。与非聚集索引的区别则是，聚集索引既存储了索引，也存储了行值。当一个表有一个聚集索引，它的数据是存储在索引的叶子页（leaf pages）。因此innodb也能理解为基于索引的表。</span><br><span class="line"></span><br><span class="line">Innodb如何选择一个聚集索引，对于Innodb，主键毫无疑问是一个聚集索引。但是当一个表没有主键，或者没有一个索引，Innodb会如何处理呢。请看如下规则</span><br><span class="line"></span><br><span class="line">1. 如果一个主键被定义了，那么这个主键就是作为聚集索引</span><br><span class="line"></span><br><span class="line">2. 如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引</span><br><span class="line"></span><br><span class="line">3. 如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。</span><br><span class="line"></span><br><span class="line">还有一个需要注意的是：次级索引的叶子节点并不存储行数据的物理地址。而是存储的该行的主键值。</span><br><span class="line"></span><br><span class="line">所以：一次级索引包含了两次查找。一次是查找次级索引自身。然后查找主键（聚集索引）现在应该明白了吧，建立自增主键的原因是：</span><br><span class="line"></span><br><span class="line">Innodb中的每张表都会有一个聚集索引，而聚集索引又是以物理磁盘顺序来存储的，自增主键会把数据自动向后插入，避免了插入过程中的聚集索引排序问题。聚集索引的排序，必然会带来大范围的数据的物理移动，这里面带来的磁盘IO性能损耗是非常大的。 </span><br><span class="line">而如果聚集索引上的值可以改动的话，那么也会触发物理磁盘上的移动，于是就可能出现page分裂，表碎片横生。</span><br></pre></td></tr></table></figure><h2 id="利用聚集索引和非聚集索引查找数据"><a href="#利用聚集索引和非聚集索引查找数据" class="headerlink" title="利用聚集索引和非聚集索引查找数据"></a>利用聚集索引和非聚集索引查找数据</h2><p>前面我们讲解 B+ 树索引的时候并没有去说怎么在 B+ 树中进行数据的查找，主要就是因为还没有引出聚集索引和非聚集索引的概念。</p><p>下面我们通过讲解如何通过聚集索引以及非聚集索引查找数据表中数据的方式介绍一下 B+ 树索引查找数据方法。</p><h3 id="利用聚集索引查找数据"><a href="#利用聚集索引查找数据" class="headerlink" title="利用聚集索引查找数据"></a>利用聚集索引查找数据</h3><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180304.png" alt=""></p><p>还是这张 B+ 树索引图，现在我们应该知道这就是聚集索引，表中的数据存储在其中。</p><p>现在假设我们要查找 id&gt;=18 并且 id&lt;40 的用户数据。对应的 sql 语句为：</p><p><strong>MySQL</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id&gt;=18 and id &lt;40</span><br></pre></td></tr></table></figure><p>其中 id 为主键，具体的查找过程如下：</p><p><strong>①</strong>一般根节点都是常驻内存的，也就是说页 1 已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。</p><p>从内存中读取到页 1，要查找这个 id&gt;=18 and id &lt;40 或者范围值，我们首先需要找到 id=18 的键值。</p><p>从页 1 中我们可以找到键值 18，此时我们需要根据指针 p2，定位到页 3。</p><p><strong>②</strong>要从页 3 中查找数据，我们就需要拿着 p2 指针去磁盘中进行读取页 3。</p><p>从磁盘中读取页 3 后将页 3 放入内存中，然后进行查找，我们可以找到键值 18，然后再拿到页 3 中的指针 p1，定位到页 8。</p><p><strong>③</strong>同样的页 8 页不在内存中，我们需要再去磁盘中将页 8 读取到内存中。</p><p>将页 8 读取到内存中后。因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值 18。</p><p>此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值 18 对应的数据。</p><p>因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页 8 中的键值依次进行遍历查找并匹配满足条件的数据。</p><p>我们可以一直找到键值为 22 的数据，然后页 8 中就没有数据了，此时我们需要拿着页 8 中的 p 指针去读取页 9 中的数据。</p><p><strong>④</strong>因为页 9 不在内存中，就又会加载页 9 到内存中，并通过和页 8 中一样的方式进行数据的查找，直到将页 12 加载到内存中，发现 41 大于 40，此时不满足条件。那么查找到此终止。</p><p>最终我们找到满足条件的所有数据，总共 12 条记录：</p><p><code>(18,kl), (19,kl), (22,hj), (24,io), (25,vg) , (29,jk), (31,jk) , (33,rt) , (34,ty) , (35,yu) , (37,rt) , (39,rt) 。</code></p><p>下面看下具体的查找流程图</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180400.png" alt=""></p><h3 id="利用非聚集索引查找数据"><a href="#利用非聚集索引查找数据" class="headerlink" title="利用非聚集索引查找数据"></a>利用非聚集索引查找数据</h3><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180416.png" alt=""></p><p>读者看到这张图的时候可能会蒙，这是啥东西啊？怎么都是数字。如果有这种感觉，请仔细看下图中红字的解释。</p><p>什么？还看不懂？那我再来解释下吧。首先，这个非聚集索引表示的是用户幸运数字的索引（为什么是幸运数字？一时兴起想起来的:-)），此时表结构是这样的。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180434.png" alt=""></p><p>在叶子节点中，不再存储所有的数据了，存储的是键值和主键。对于叶子节点中的 x-y，比如 1-1。左边的 1 表示的是索引的键值，右边的 1 表示的是主键值。</p><p>如果我们要找到幸运数字为 33 的用户信息，对应的 sql 语句为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where luckNum=33</span><br></pre></td></tr></table></figure><p>查找的流程跟聚集索引一样，这里就不详细介绍了。我们最终会找到主键值 47，找到主键后我们需要再到聚集索引中查找具体对应的数据信息，此时又回到了聚集索引的查找流程。</p><p>下面看下具体的查找流程图：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180507.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章从二叉查找树，详细说明了为什么 MySQL 用 B+ 树作为数据的索引，以及在 InnoDB 中数据库如何通过 B+ 树索引来存储数据以及查找数据。</p><p>我们一定要记住这句话：数据即索引，索引即数据。</p><p>参考文章:<br><a href="http://www.liuzk.com/410.html" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。&lt;br&gt;索引最形象的比喻就是图书的目录了。注意这里的大量，数据量大了索引才显得有意义，如果我想要在 [1,2,3,4] 中找到 4 这个数据，直接对全数据检索也很快，没有必要费力气建索引再去查找。&lt;/p&gt;
&lt;p&gt;索引在 MySQL 数据库中分三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B+ 树索引&lt;/li&gt;
&lt;li&gt;Hash 索引&lt;/li&gt;
&lt;li&gt;全文索引&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="b+tree" scheme="https://removeif.github.io/tags/b-tree/"/>
    
      <category term="聚簇索引" scheme="https://removeif.github.io/tags/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>算法成长之路leetcode5-6</title>
    <link href="https://removeif.github.io/2019/12/05/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode5-6.html"/>
    <id>https://removeif.github.io/2019/12/05/algorithm/算法成长之路leetcode5-6.html</id>
    <published>2019-12-05T13:14:49.026Z</published>
    <updated>2019-12-05T13:14:49.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. Longest Palindromic Substring</a></h3><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br><a id="more"></a></p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h4 id="JAVA题解"><a href="#JAVA题解" class="headerlink" title="JAVA题解"></a>JAVA题解</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leetcode5</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(longestPalindrome(<span class="hljs-string">"abbaabb"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 示例 1：</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: "babad"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: "bab"</span></span><br><span class="line"><span class="hljs-comment">     * 注意: "aba" 也是一个有效答案。</span></span><br><span class="line"><span class="hljs-comment">     * 示例 2：</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: "cbbd"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: "bb"</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment">     * 链接：https://leetcode-cn.com/problems/longest-palindromic-substring</span></span><br><span class="line"><span class="hljs-comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 终于看懂了这个中心向两边扩张算法是什么意思了。</span></span><br><span class="line"><span class="hljs-comment">     * 先来解释一下为什么中心是2n-1而不是n 比如有字符串abcba，这时回文子串是abcda，</span></span><br><span class="line"><span class="hljs-comment">     * 中心是c；又有字符串adccda，这时回文子串是adccda，中心是cc。 由此可见中心点既有可能是一个字符，</span></span><br><span class="line"><span class="hljs-comment">     * 也有可能是两个字符，当中心为一个字符的时候有n个中心，</span></span><br><span class="line"><span class="hljs-comment">     * 当中心为两个字符的时候有n-1个中心，所以一共有2n-1个中心。</span></span><br><span class="line"><span class="hljs-comment">     * 然后for循环开始从左到右遍历，为什么会有两次expandAroundCenter，一次是i和i本身，一次是i和i+1，</span></span><br><span class="line"><span class="hljs-comment">     * 这就是上面说到的一个中心与两个中心。 而后会去判断这两种情况下谁的回文子串最长，并标记出这个子串在原字符串中的定位，即start和end。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="hljs-comment">// 一个数向两边扩张</span></span><br><span class="line">            <span class="hljs-keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="hljs-comment">// 两个数向两边扩张</span></span><br><span class="line">            <span class="hljs-keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="hljs-number">1</span>);</span><br><span class="line">            <span class="hljs-comment">// 取最长的回文</span></span><br><span class="line">            <span class="hljs-keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="hljs-comment">// 判读此时长度和原来的最长度</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">                <span class="hljs-comment">// 求最长回文开始位置</span></span><br><span class="line">                start = i - (len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;</span><br><span class="line">                <span class="hljs-comment">// 求最长回文结束位置</span></span><br><span class="line">                end = i + len / <span class="hljs-number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 截取最长回文</span></span><br><span class="line">        <span class="hljs-keyword">return</span> s.substring(start, end + <span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 向两边向两边扩张求长度</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> left</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> right</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expandAroundCenter</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 定位中心位置</span></span><br><span class="line">        <span class="hljs-keyword">int</span> L = left, R = right;</span><br><span class="line">        <span class="hljs-comment">// 判读中间位置是否相等，以及两边扩张是否相等</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (L &gt;= <span class="hljs-number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">            <span class="hljs-comment">// 向左扩张一位</span></span><br><span class="line">            L--;</span><br><span class="line">            <span class="hljs-comment">// 向右扩张一位</span></span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 回文的长度 如 aba 时,当 b = 1时，一个中心点进来,L = 1,R = 1,此时满足循环，L=0,R=2,此时也满足</span></span><br><span class="line">        <span class="hljs-comment">// 循环，L = -1,R=3,此时循环结束，长度为3 = 3 -（-1） -1</span></span><br><span class="line">        <span class="hljs-keyword">return</span> R - L - <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6. ZigZag Conversion"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. ZigZag Conversion</a></h3><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><p>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><h4 id="JAVA题解-1"><a href="#JAVA题解-1" class="headerlink" title="JAVA题解"></a>JAVA题解</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leetcode6</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * 比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时，排列如下：</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * L   C   I   R</span></span><br><span class="line"><span class="hljs-comment">     * E T O E S I I G</span></span><br><span class="line"><span class="hljs-comment">     * E   D   H   N</span></span><br><span class="line"><span class="hljs-comment">     * 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："LCIRETOESIIGEDHN"。</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * 请你实现这个将字符串进行指定行数变换的函数：</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * string convert(string s, int numRows);</span></span><br><span class="line"><span class="hljs-comment">     * 示例 1:</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * 输入: s = "LEETCODEISHIRING", numRows = 3</span></span><br><span class="line"><span class="hljs-comment">     * 输出: "LCIRETOESIIGEDHN"</span></span><br><span class="line"><span class="hljs-comment">     * 示例 2:</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * 输入: s = "LEETCODEISHIRING", numRows = 4</span></span><br><span class="line"><span class="hljs-comment">     * 输出: "LDREOEIIECIHNTSG"</span></span><br><span class="line"><span class="hljs-comment">     * 解释:</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * L     D     R</span></span><br><span class="line"><span class="hljs-comment">     * E   O E   I I</span></span><br><span class="line"><span class="hljs-comment">     * E C   I H   N</span></span><br><span class="line"><span class="hljs-comment">     * T     S     G</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment">     * 链接：https://leetcode-cn.com/problems/zigzag-conversion</span></span><br><span class="line"><span class="hljs-comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">convert</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (numRows == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        List&lt;StringBuilder&gt; rows = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Math.min(numRows, s.length()); i++)</span><br><span class="line">            <span class="hljs-comment">// 确定有多少行，每一行放一个待填充的字符串</span></span><br><span class="line">            rows.add(<span class="hljs-keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="hljs-comment">// 当前行</span></span><br><span class="line">        <span class="hljs-keyword">int</span> curRow = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-comment">// 上移或下移 false上移</span></span><br><span class="line">        <span class="hljs-keyword">boolean</span> goingDown = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="hljs-comment">// 挨着放字符到对应的行</span></span><br><span class="line">            rows.get(curRow).append(c);</span><br><span class="line">            <span class="hljs-comment">// 判断是否下移，当第一行和最后一行的时候转向</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (curRow == <span class="hljs-number">0</span> || curRow == numRows - <span class="hljs-number">1</span>) goingDown = !goingDown;</span><br><span class="line">            <span class="hljs-comment">// 下移行数+1，上移行数-1</span></span><br><span class="line">            curRow += goingDown ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 存最终结果</span></span><br><span class="line">        StringBuilder ret = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="hljs-comment">// 遍历每行，进行连接</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (StringBuilder row : rows) ret.append(row);</span><br><span class="line">        <span class="hljs-keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Leetcode6 l = <span class="hljs-keyword">new</span> Leetcode6();</span><br><span class="line">        System.out.println(l.convert(<span class="hljs-string">"weweqw"</span>, <span class="hljs-number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;5-Longest-Palindromic-Substring&quot;&gt;&lt;a href=&quot;#5-Longest-Palindromic-Substring&quot; class=&quot;headerlink&quot; title=&quot;5. Longest Palindromic Substring&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;5. Longest Palindromic Substring&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://removeif.github.io/categories/algorithm/"/>
    
    
      <category term="最长回文" scheme="https://removeif.github.io/tags/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87/"/>
    
      <category term="Z字变换" scheme="https://removeif.github.io/tags/Z%E5%AD%97%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>二分查找法模板的基本思想-leetcode35</title>
    <link href="https://removeif.github.io/2019/12/03/algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-leetcode35.html"/>
    <id>https://removeif.github.io/2019/12/03/algorithm/二分查找法模板的基本思想-leetcode35.html</id>
    <published>2019-12-03T10:38:01.100Z</published>
    <updated>2019-12-03T10:38:01.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode35"><a href="#leetcode35" class="headerlink" title="leetcode35"></a>leetcode35</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。<br><a id="more"></a></p><p><strong>示例 1:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>传统解法：</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="hljs-keyword">if</span> (nums[len - <span class="hljs-number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;</span><br><span class="line">            <span class="hljs-comment">// 等于的情况最简单，我们应该放在第 1 个分支进行判断</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="hljs-comment">// 题目要我们返回大于或者等于目标值的第 1 个数的索引</span></span><br><span class="line">                <span class="hljs-comment">// 此时 mid 一定不是所求的左边界，</span></span><br><span class="line">                <span class="hljs-comment">// 此时左边界更新为 mid + 1</span></span><br><span class="line">                left = mid + <span class="hljs-number">1</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// 既然不会等于，此时 nums[mid] &gt; target</span></span><br><span class="line">                <span class="hljs-comment">// mid 也一定不是所求的右边界</span></span><br><span class="line">                <span class="hljs-comment">// 此时右边界更新为 mid - 1</span></span><br><span class="line">                right = mid - <span class="hljs-number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 注意：一定得返回左边界 left，</span></span><br><span class="line">        <span class="hljs-comment">// 如果返回右边界 right 提交代码不会通过</span></span><br><span class="line">        <span class="hljs-comment">// 【注意】下面我尝试说明一下理由，如果你不太理解下面我说的，那是我表达的问题</span></span><br><span class="line">        <span class="hljs-comment">// 但我建议你不要纠结这个问题，因为我将要介绍的二分查找法模板，可以避免对返回 left 和 right 的讨论</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1</span></span><br><span class="line">        <span class="hljs-comment">// 在上面的 while (left &lt;= right) 退出循环以后，right &lt; left，right = 0 ，left = 1</span></span><br><span class="line">        <span class="hljs-comment">// 根据题意应该返回 left，</span></span><br><span class="line">        <span class="hljs-comment">// 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 right</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>a、当把二分查找法的循环可以进行的条件写成 while (left &lt;= right) 时，在写最后一句 return 的时候，如果不假思索，把左边界 left 返回回去，虽然写对了，但可以思考一下为什么不返回右边界 right 呢？</p><p>b、但是事实上，返回 left 是有一定道理的，如果题目换一种问法，你可能就要返回右边界 right，这句话不太理解没有关系，我也不打算讲得很清楚（在上面代码的注释中我已经解释了原因），因为实在太绕了，这不是我要说的重点。</p><h3 id="二分查找法模板的基本思想"><a href="#二分查找法模板的基本思想" class="headerlink" title="二分查找法模板的基本思想"></a>二分查找法模板的基本思想</h3><p><strong>1、首先把循环可以进行的条件写成 while(left &lt; right)，在退出循环的时候，一定有 left == right 成立，此时返回 left 或者 right 都可以</strong><br>或许你会问：退出循环的时候还有一个数没有看啊（退出循环之前索引 left 或 索引 right 上的值）？<br>没有关系，我们就等到退出循环以后来看，甚至经过分析，有时都不用看，就能确定它是目标数值。</p><p>（什么时候需要看最后剩下的那个数，什么时候不需要，会在后面介绍。）</p><p>更深层次的思想是“<strong>夹逼法</strong>”或者称为“<strong>排除法</strong>”。</p><p><strong>2、“神奇的”二分查找法模板的基本思想（特别重要）</strong><br>“排除法”即：在每一轮循环中排除一半以上的元素，于是在对数级别的时间复杂度内，就可以把区间“夹逼” 只剩下 1 个数，而这个数是不是我们要找的数，单独做一次判断就可以了。</p><p>“夹逼法”或者“排除法”是二分查找算法的基本思想，“二分”是手段，在目标元素不确定的情况下，“二分” 也是“最大熵原理”告诉我们的选择。</p><p>还是 LeetCode 第 35 题，下面给出使用 while (left &lt; right) 模板写法的 2 段参考代码，以下代码的细节部分在后文中会讲到，因此一些地方不太明白没有关系，暂时跳过即可。</p><p><strong>参考代码 1</strong>：重点理解为什么候选区间的索引范围是 [0, size]。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="hljs-comment"># 返回大于等于 target 的索引，有可能是最后一个</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="hljs-comment"># 特判</span></span><br><span class="line">        <span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line">        left = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># 如果 target 比 nums里所有的数都大，则最后一个数的索引 + 1 就是候选值，因此，右边界应该是数组的长度</span></span><br><span class="line">        right = size</span><br><span class="line">        <span class="hljs-comment"># 二分的逻辑一定要写对，否则会出现死循环或者数组下标越界</span></span><br><span class="line">        <span class="hljs-keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="hljs-number">2</span></span><br><span class="line">            <span class="hljs-keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">assert</span> nums[mid] &gt;= target</span><br><span class="line">                <span class="hljs-comment"># [1,5,7] 2</span></span><br><span class="line">                right = mid</span><br><span class="line">        <span class="hljs-comment"># 调试语句</span></span><br><span class="line">        <span class="hljs-comment"># print('left = &#123;&#125;, right = &#123;&#125;, mid = &#123;&#125;'.format(left, right, mid))</span></span><br><span class="line">        <span class="hljs-keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>参考代码 2</strong>：对于是否接在原有序数组后面单独判断，不满足的时候，再在候选区间的索引范围 <code>[0, size - 1]</code> 内使用二分查找法进行搜索。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="hljs-comment"># 返回大于等于 target 的索引，有可能是最后一个</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="hljs-comment"># 特判 1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># 特判 2：如果比最后一个数字还要大，直接接在它后面就可以了</span></span><br><span class="line">        <span class="hljs-keyword">if</span> target &gt; nums[<span class="hljs-number">-1</span>]:</span><br><span class="line">            <span class="hljs-keyword">return</span> size</span><br><span class="line"></span><br><span class="line">        left = <span class="hljs-number">0</span></span><br><span class="line">        right = size - <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment"># 二分的逻辑一定要写对，否则会出现死循环或者数组下标越界</span></span><br><span class="line">        <span class="hljs-keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="hljs-number">2</span></span><br><span class="line">            <span class="hljs-keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">assert</span> nums[mid] &gt;= target</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="hljs-keyword">return</span> left</span><br></pre></td></tr></table></figure><h3 id="细节、注意事项、调试方法"><a href="#细节、注意事项、调试方法" class="headerlink" title="细节、注意事项、调试方法"></a>细节、注意事项、调试方法</h3><p><strong>1、前提：思考左、右边界，如果左、右边界不包括目标数值，会导致错误结果</strong><br>例：LeetCode 第 69 题：x 的平方根</p><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>分析：一个非负整数的平方根最小可能是 0 ，最大可能是它自己。<br>因此左边界可以取 0 ，右边界可以取 x。<br>可以分析得再细一点，但这道题没有必要，因为二分查找法会帮你排除掉不符合的区间元素。</p><p>例：LeetCode 第 287 题：寻找重复数</p><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>分析：题目告诉我们“其数字都在 1 到 n 之间（包括 1 和 n）”。因此左边界可以取 1 ，右边界可以取 n。</p><p>要注意 2 点：</p><p>如果 left 和 right 表示的是数组的索引，就要考虑“索引是否有效” ，即“索引是否越界” 是重要的定界依据；</p><p>左右边界一定要包括目标元素，例如 LeetCode 第 35 题：“搜索插入位置” ，当 target 比数组中的最后一个数字还要大（不能等于）的时候，插入元素的位置就是数组的最后一个位置 + 1，即 (len - 1 + 1 =) len，如果忽略掉这一点，把右边界定为 len - 1 ，代码就不能通过在线测评。</p><p><strong>2、中位数先写 int mid = (left + right) &gt;&gt;&gt; 1 ; 根据循环里分支的编写情况，再做调整</strong><br>理解这一点，首先要知道：当数组的元素个数是偶数的时候，中位数有左中位数和右中位数之分。</p><p>当数组的元素个数是<strong>偶数</strong>的时候：<br>使用 <strong>int mid = left + (right - left) / 2</strong> ; 得到<strong>左中位数</strong>的索引；</p><p>使用 <strong>int mid = left + (right - left + 1) / 2</strong> ; 得到<strong>右中位数</strong>的索引。</p><p>当数组的元素个数是奇数的时候，以上二者都能选到最中间的那个中位数。<br>其次，</p><p><strong>int mid = left + (right - left) / 2 ; 等价于 int mid = (left + right) &gt;&gt;&gt; 1；</strong></p><p><strong>int mid = left + (right - left + 1) / 2 ; 等价于 int mid = (left + right + 1) &gt;&gt;&gt; 1 。</strong></p><p>我们使用一个具体的例子来验证：当左边界索引 left = 3，右边界索引 right = 4 的时候，</p><p><strong>mid1 = left + (right - left) // 2 = 3 + (4 - 3) // 2 = 3 + 0 = 3，</strong></p><p><strong>mid2 = left + (right - left + 1) // 2 = 3 + (4 - 3 + 1) // 2 = 3 + 1 = 4。</strong></p><p>左中位数 mid1 是索引 left，右中位数 mid2 是索引 right。</p><p><strong>记忆方法：</strong></p><p>(right - left) 不加 11 选左中位数，加 11 选右中位数。</p><p>那么，什么时候使用左中位数，什么时候使用右中位数呢？选中位数的依据是为了避免死循环，得根据分支的逻辑来选择中位数，而分支逻辑的编写也有技巧，下面具体说。</p><p><strong>3、先写逻辑上容易想到的分支逻辑，这个分支逻辑通常是排除中位数的逻辑；</strong><br>在逻辑上，“可能是也有可能不是”让我们感到犹豫不定，但<strong>“一定不是”是我们非常坚决的，通常考虑的因素特别单一，因此“好想” </strong>。在生活中，我们经常听到这样的话：找对象时，“有车、有房，可以考虑，但没有一定不要”；找工作时，“事儿少、离家近可以考虑，但是钱少一定不去”，就是这种思想的体现。</p><p>例：LeetCode 第 69 题：x 的平方根</p><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>分析：因为题目中说“返回类型是整数，结果只保留整数的部分，小数部分将被舍去”。例如 55 的平方根约等于 2.2362.236，在这道题应该返回 22。因此如果一个数的平方小于或者等于 x，那么这个数有可能是也有可能不是 x 的平方根，但是能很肯定的是，如果一个数的平方大于 x ，这个数肯定不是 x 的平方根。</p><p>注意：先写“好想”的分支，排除了中位数之后，通常另一个分支就不排除中位数，而不必具体考虑另一个分支的逻辑的具体意义，且代码几乎是固定的。</p><p><strong>4、循环内只写两个分支，一个分支排除中位数，另一个分支不排除中位数，循环中不单独对中位数作判断</strong><br>既然是“夹逼”法，没有必要在每一轮循环开始前单独判断当前中位数是否是目标元素，因此分支数少了一支，代码执行效率更高。</p><p>以下是“排除中位数的逻辑”思考清楚以后，可能出现的两个模板代码。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191203181303.png" alt=""></p><p>可以排除“中位数”的逻辑，通常比较好想，但并不绝对，这一点视情况而定。</p><p>分支条数变成 2 条，比原来 3 个分支要考虑的情况少，好处是：</p><p>不用在每次循环开始单独考虑中位数是否是目标元素，节约了时间，我们只要在退出循环的时候，即左右区间压缩成一个数（索引）的时候，去判断这个索引表示的数是否是目标元素，而不必在二分的逻辑中单独做判断。</p><p>这一点很重要，希望读者结合具体练习仔细体会，每次循环开始的时候都单独做一次判断，在统计意义上看，二分时候的中位数恰好是目标元素的概率并不高，并且即使要这么做，也不是普适性的，不能解决绝大部分的问题。</p><p>还以 LeetCode 第 35 题为例，通过之前的分析，我们需要找到“大于或者等于目标值的第 1 个数的索引”。对于这道题而言：</p><ul><li><p>如果中位数小于目标值，它就应该被排除，左边界 left 就至少是 mid + 1；</p></li><li><p>如果中位数大于等于目标值，还不能够肯定它就是我们要找的数，因为要找的是等于目标值的第 11 个数的索引，中位数以及中位数的左边都有可能是符合题意的数，因此右边界就不能把 mid 排除，因此右边界 right 至多是 mid，此时右边界不向左边收缩。</p></li></ul><p>下一点就更关键了。</p><p><strong>5、根据分支逻辑选择中位数的类型，可能是左中位数，也可能是右位数，选择的标准是避免死循环</strong></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191203181337.png" alt=""></p><p>死循环容易发生在区间只有 22 个元素时候，此时中位数的选择尤为关键。选择中位数的依据是：避免出现死循环。我们需要确保：</p><p>（下面的这两条规则说起来很绕，可以暂时跳过）。</p><ul><li><p>如果分支的逻辑，在选择左边界的时候，不能排除中位数，那么中位数就选“右中位数”，只有这样区间才会收缩，否则进入死循环；</p></li><li><p>同理，如果分支的逻辑，在选择右边界的时候，不能排除中位数，那么中位数就选“左中位数”，只有这样区间才会收缩，否则进入死循环。</p></li></ul><p>理解上面的这个规则可以通过具体的例子。针对以上规则的第 1 点：如果分支的逻辑，在选择左边界的时候不能排除中位数，例如：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">while</span> left &lt; right:</span><br><span class="line">      <span class="hljs-comment"># 不妨先写左中位数，看看你的分支会不会让你代码出现死循环，从而调整</span></span><br><span class="line">    mid = left + (right - left) // <span class="hljs-number">2</span></span><br><span class="line">    <span class="hljs-comment"># 业务逻辑代码</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (check(mid)):</span><br><span class="line">        <span class="hljs-comment"># 选择右边界的时候，可以排除中位数</span></span><br><span class="line">        right = mid - <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        <span class="hljs-comment"># 选择左边界的时候，不能排除中位数</span></span><br><span class="line">        left = mid</span><br></pre></td></tr></table></figure><p>在区间中的元素只剩下 22 个时候，例如：left = 3，right = 4。此时左中位数就是左边界，如果你的逻辑执行到 left = mid 这个分支，且你选择的中位数是左中位数，此时左边界就不会得到更新，区间就不会再收缩（理解这句话是关键），从而进入死循环；<br>为了避免出现死循环，你需要选择中位数是右中位数，当逻辑执行到 left = mid 这个分支的时候，因为你选择了右中位数，让逻辑可以转而执行到 right = mid - 1 让区间收缩，最终成为 1 个数，退出 while 循环。<br>上面这段话不理解没有关系，因为我还没有举例子，你有个印象就好，类似地，理解选择中位数的依据的第 2 点。</p><p><strong>6、退出循环的时候，可能需要对“夹逼”剩下的那个数单独做一次判断，这一步称之为“后处理”。</strong><br>二分查找法之所以高效，是因为它利用了数组有序的特点，在每一次的搜索过程中，都可以排除将近一半的数，使得搜索区间越来越小，直到区间成为一个数。回到这一节最开始的疑问：“区间左右边界相等（即收缩成 1 个数）时，这个数是否会漏掉”，解释如下：</p><ul><li><p>如果你的业务逻辑保证了你要找的数一定在左边界和右边界所表示的区间里出现，那么可以放心地返回 left 或者 right，无需再做判断；</p></li><li><p>如果你的业务逻辑不能保证你要找的数一定在左边界和右边界所表示的区间里出现，那么只要在退出循环以后，再针对 nums[left] 或者 nums[right] （此时 <code>nums[left] == nums[right]</code>）单独作一次判断，看它是不是你要找的数即可，这一步操作常常叫做“后处理”。</p></li></ul><p>如果你能确定候选区间里目标元素一定存在，则不必做“后处理”。<br>例：LeetCode 第 69 题：x 的平方根</p><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>分析：非负实数 x 的平方根在 [0, x] 内一定存在，故退出 while (left &lt; right) 循环以后，不必单独判断 left 或者 right 是否符合题意。</p><p>如果你不能确定候选区间里目标元素一定存在，需要单独做一次判断。<br>例：LeetCode 第 704 题：二分查找</p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>分析：因为目标数有可能不在数组中，当候选区间夹逼成一个数的时候，要单独判断一下这个数是不是目标数，如果不是，返回 -1。</p><p><strong>7、取中位数的时候，要避免在计算上出现整型溢出；</strong><br>int mid = (left + right) / 2; 的问题：在 left 和 right 很大的时候，left + right 会发生整型溢出，变成负数，这是一个 bug ，得改！</p><p>int mid = left + (right - left) / 2; 在 right 很大、 left 是负数且很小的时候， right - left 也有可能超过 int 类型能表示的最大值，只不过一般情况下 left 和 right 表示的是数组索引值，left 是非负数，因此 right - left 溢出的可能性很小。因此，它是正确的写法。下面介绍推荐的写法。</p><p>int mid = (left + right) &gt;&gt;&gt; 1; 如果这样写， left + right 在发生整型溢出以后，会变成负数，此时如果除以 22 ，mid 是一个负数，但是经过无符号右移，可以得到在不溢出的情况下正确的结果。</p><p>解释“无符号右移”：在 Java 中，无符号右移运算符 &gt;&gt;&gt; 和右移运算符 &gt;&gt; 的区别如下：</p><p>右移运算符 &gt;&gt; 在右移时，丢弃右边指定位数，左边补上符号位；<br>无符号右移运算符 &gt;&gt;&gt; 在右移时，丢弃右边指定位数，左边补上 00，也就是说，对于正数来说，二者一样，而负数通过 &gt;&gt;&gt; 后能变成正数。<br>下面解释上面的模板中，取中位数的时候使用先用“＋”，然后“无符号右移”。</p><p>a、int mid = (left + right) / 2 与 int mid = left + (right - left) / 2 两种写法都有整型溢出的风险，没有哪一个是绝对安全的，注意：这里我们取平均值用的是除以 2，并且是整除：</p><p>int mid = (left + right) / 2 在 left 和 right 都很大的时候会溢出；<br>int mid = left + (right - left) / 2 在 right 很大，且 left 是负数且很小的时候会溢出；<br>b、写算法题的话，一般是让你在数组中做二分查找，因此 left 和 right 一般都表示数组的索引，因此 left 在绝大多数情况下不会是负数并且很小，因此使用 int mid = left + (right - left) // 2 相对 int mid = (left + right) // 2 更安全一些，并且也能向别人展示我们注意到了整型溢出这种情况，但事实上，还有更好的方式；</p><p>c、建议使用 int mid = (left + right) &gt;&gt;&gt; 1 这种写法，其实是大有含义的：</p><p>JDK8 中采用 int mid = (left + right) &gt;&gt;&gt; 1 ，重点不在 + ，而在 &gt;&gt;&gt; 。</p><p>我们看极端的情况，left 和 high 都是整型最大值的时候，注意，此时 3232 位整型最大值它的二进制表示的最高位是 00，它们相加以后，最高位是 11 ，变成负数，但是再经过无符号右移 &gt;&gt;&gt;（重点是忽略了符号位，空位都以 00 补齐），就能保证使用 + 在整型溢出了以后结果还是正确的。</p><p>Java 中 Collections 和 Arrays 提供的 binarySearch 方法，我们点进去看 left 和 right 都表示索引，使用无符号右移又不怕整型溢出，那就用 int mid = (left + right) &gt;&gt;&gt; 1 好啦。位运算本来就比使用除法快，这样看来使用 + 和 &lt;&lt;&lt; 真的是又快又好了。</p><p>我想这一点可能是 JDK8 的编写者们更层次的考量。</p><p>看来以后写算法题，就用 int mid = (left + right) &gt;&gt;&gt; 1 吧，反正更多的时候 left 和 right 表示索引。</p><p><strong>8、编码一旦出现死循环，输出必要的变量值、分支逻辑是调试的重要方法。</strong><br>当出现死循环的时候的调试方法：打印输出左右边界、中位数的值和目标值、分支逻辑等必要的信息。</p><p>按照我的经验，一开始编码的时候，稍不注意就很容易出现死循环，不过没有关系，你可以你的代码中写上一些输出语句，就容易理解“在区间元素只有 2 个的时候容易出现死循环”。具体编码调试的细节，可以参考我在「力扣」第 69 题：x 的平方根的题解《二分查找 + 牛顿法（Python 代码、Java 代码）》 。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下，我爱用这个模板的原因、技巧、优点和注意事项：</p><p><strong>原因：</strong><br>无脑地写 while left &lt; right: ，这样你就不用判断，在退出循环的时候你应该返回 left 还是 right，因为返回 left 或者 right 都对；</p><p><strong>技巧：</strong><br>先写分支逻辑，并且先写排除中位数的逻辑分支（因为更多时候排除中位数的逻辑容易想，但是前面我也提到过，这并不绝对），另一个分支的逻辑你就不用想了，写出第 1 个分支的反面代码即可（下面的说明中有介绍），再根据分支的情况选择使用左中位数还是右中位数；</p><p>说明：这里再多说一句。如果从代码可读性角度来说，只要是你认为好想的逻辑分支，就把它写在前面，并且加上你的注释，这样方便别人理解，而另一个分支，你就不必考虑它的逻辑了。有的时候另一个分支的逻辑并不太好想，容易把自己绕进去。如果你练习做得多了，会形成条件反射。</p><p>我简单总结了一下，左右分支的规律就如下两点：</p><p>如果第 1 个分支的逻辑是“左边界排除中位数”（left = mid + 1），那么第 2 个分支的逻辑就一定是“右边界不排除中位数”（right = mid），反过来也成立；</p><p>如果第 2 个分支的逻辑是“右边界排除中位数”（right = mid - 1），那么第 2 个分支的逻辑就一定是“左边界不排除中位数”（left = mid），反之也成立。</p><p>“反过来也成立”的意思是：如果在你的逻辑中，“边界不能排除中位数”的逻辑好想，你就把它写在第 1 个分支，另一个分支是它的反面，你可以不用管逻辑是什么，按照上面的规律直接给出代码就可以了。能这么做的理论依据就是“排除法”。</p><p>在「力扣」第 287 题：寻找重复数的题解《二分法（Python 代码、Java 代码）》和这篇题解的评论区中，有我和用户<br>@fighterhit 给出的代码，在一些情况下，我们先写了不排除中位数的逻辑分支，更合适的标准就是“哪个逻辑分支好想，就先写哪一个”，欢迎大家参与讨论。</p><p><strong>优点：</strong><br>分支条数只有 2 条，代码执行效率更高，不用在每一轮循环中单独判断中位数是否符合题目要求，写分支的逻辑的目的是尽量排除更多的候选元素，而判断中位数是否符合题目要求我们放在最后进行，这就是第 5 点；</p><p>说明：每一轮循环开始都单独判断中位数是否符合要求，这个操作不是很有普适性，因为从统计意义上说，中位数直接就是你想找的数的概率并不大，有的时候还要看看左边，还要看看右边。不妨就把它放在最后来看，把候选区间“夹逼”到只剩 11 个元素的时候，视情况单独再做判断即可。</p><p><strong>注意事项 1：</strong><br>左中位数还是右中位数选择的标准根据分支的逻辑而来，标准是每一次循环都应该让区间收缩，当候选区间只剩下 22 个元素的时候，为了避免死循环发生，选择正确的中位数类型。如果你实在很晕，不防就使用有 22 个元素的测试用例，就能明白其中的原因，另外在代码出现死循环的时候，建议你可以将左边界、右边界、你选择的中位数的值，还有分支逻辑都打印输出一下，出现死循环的原因就一目了然了；</p><p><strong>注意事项 2：</strong><br>如果能确定要找的数就在候选区间里，那么退出循环的时候，区间最后收缩成为 11 个数后，直接把这个数返回即可；如果你要找的数有可能不在候选区间里，区间最后收缩成为 11 个数后，还要单独判断一下这个数是否符合题意。</p><p>最后给出两个模板，大家看的时候看注释，不必也无需记忆它们。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191203181446.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191203181505.png" alt=""></p><p>说明：我写的时候，一般是先默认将中位数写成左中位数，再根据分支的情况，看看是否有必要调整成右中位数，即是不是要在 (right - left) 这个括号里面加 11 。</p><p>虽说是两个模板，区别在于选中位数，中位数根据分支逻辑来选，原则是区间要收缩，且不出现死循环，退出循环的时候，视情况，有可能需要对最后剩下的数单独做判断。</p><p>我想我应该是成功地把你绕晕了，如果您觉得啰嗦的地方，就当我是“重要的事情说了三遍”吧，确实是重点的地方我才会重复说。当然，最好的理解这个模板的方法还是应用它。在此建议您不妨多做几道使用“二分查找法”解决的问题，用一下我说的这个模板，在发现问题的过程中，体会这个模板好用的地方，相信你一定会和我一样爱上这个模板的。</p><p>在「力扣」的探索版块中，给出了二分查找法的 3 个模板，我这篇文章着重介绍了第 2 个模板，但是我介绍的角度和这个版块中给出的角度并不一样，第 1 个模板被我“嫌弃”了，第 3 个模板我看过了，里面给出的例题也可以用第 2 个模板来完成，如果大家有什么使用心得，欢迎与我交流。</p><p>来源：<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">力扣（LeetCode）</a>，作者：liweiwei1419</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;leetcode35&quot;&gt;&lt;a href=&quot;#leetcode35&quot; class=&quot;headerlink&quot; title=&quot;leetcode35&quot;&gt;&lt;/a&gt;leetcode35&lt;/h3&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;你可以假设数组中无重复元素。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://removeif.github.io/categories/algorithm/"/>
    
    
      <category term="二分查找" scheme="https://removeif.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Github Issue 作为博客微型数据库的应用</title>
    <link href="https://removeif.github.io/2019/11/28/tools/Github-Issue-%E4%BD%9C%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%BE%AE%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%BA%94%E7%94%A8.html"/>
    <id>https://removeif.github.io/2019/11/28/tools/Github-Issue-作为博客微型数据库的应用.html</id>
    <published>2019-11-28T14:02:05.000Z</published>
    <updated>2019-11-28T14:16:29.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>众所周知，对于hexo框架搭建的静态博客，难免会产生一些动态的数据，比如一些碎碎念、友链、音乐、时间轴等微型数据。目前一般的做法:</p><p>a.是创建一个json数据，来存储这些微型数据，但是如果数据太多的话，一是比较慢，二是有个硬伤问题，就是json数据不能分页请求，只能一次拿完，太多的话网络带宽占用太多。<br><a id="more"></a></p><p>b.或者有的直接后台写一些接口服务啥的，还得在买个服务器部署上去，然后博客中访问接口。</p><p>c.或者有些可能就直接写到html中。</p><p>对于a、c方法都比较麻烦，每次更新了都要编译部署，不能很方便的动态更新。对于b的话，成本以及技术要求可能就更多一些了。</p><p>基于上面出现的问题，目前想到的一个解决方案就是，利用github 的issue作为一个微型数据库。能够很方便的动态更新，也能分页，也不需要啥json文件，想想都很方便。</p><h3 id="issue数据库使用步骤"><a href="#issue数据库使用步骤" class="headerlink" title="issue数据库使用步骤"></a>issue数据库使用步骤</h3><h4 id="issue的创建"><a href="#issue的创建" class="headerlink" title="issue的创建"></a>issue的创建</h4><p>先创建一个Repository，对于此Repository可以专门作为微型的数据库，取名issue_database。创建好之后建立一些issue</p><p>如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191128213154.png" alt=""></p><p>目前博客中，所有的动态数据都放到issue中了。</p><h4 id="issue中存储数据"><a href="#issue中存储数据" class="headerlink" title="issue中存储数据"></a>issue中存储数据</h4><p>对于创建好的issue，就可以往里面写数据了，比如我的友链数据为issue：blog_friends</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191128213427.png" alt=""></p><p>对于issue中存储的数据最好存json格式的，因为可以方便后面取出来使用。存储好数据后，如果太多的话，可以点击hide,隐藏起来。同时这个issue最好给<code>Lock conversation</code>这样的好处是，防止别人往里面加些脏数据，只能自己往里写数据。哈哈，一般也没有闲的无聊的网友恶作剧。这样就存储好数据了。</p><h4 id="博客中获取issue数据"><a href="#博客中获取issue数据" class="headerlink" title="博客中获取issue数据"></a>博客中获取issue数据</h4><p>博客中通过js获取issue中的数据，以博客友链为例，以下是获取代码，以及处理</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// author by removef</span></span><br><span class="line"><span class="hljs-comment">// https://removeif.github.io/</span></span><br><span class="line">$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//获取处理友链数据，来自issue，一次取完</span></span><br><span class="line">    $.getJSON(<span class="hljs-string">"https://api.github.com/repos/removeif/issue_database/issues/2/comments?per_page=100&amp;client_id=46a9f3481b46ea0129d8&amp;client_secret=79c7c9cb847e141757d7864453bcbf89f0655b24"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> data = [];</span><br><span class="line">        <span class="hljs-keyword">var</span> source1;</span><br><span class="line">        source1 = source;</span><br><span class="line">      <span class="hljs-comment">// 以后每次更新的都在后面，此处倒序，按时间降序排</span></span><br><span class="line">        source1.reverse();</span><br><span class="line">      <span class="hljs-comment">// 把所有的数据放到data的列表中</span></span><br><span class="line">        $.each(source1, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i, e</span>) </span>&#123;</span><br><span class="line">            data.push(...JSON.parse(e.body));</span><br><span class="line">        &#125;);</span><br><span class="line">      </span><br><span class="line">        $.each(data, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i, e</span>) </span>&#123;</span><br><span class="line">          <span class="hljs-comment">// 博客中html文件的构建，渲染</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中client_id、client_secret在另一篇文章中<strong><a href="https://removeif.github.io/2019/09/19/%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB.html">博客源码分享</a></strong>有详细的说明,可以查看一下。这样就能获取到相应的数据，进行操作。</p><h4 id="issue数据的更新"><a href="#issue数据的更新" class="headerlink" title="issue数据的更新"></a>issue数据的更新</h4><p>比如想更新任意一项数据都可以进github中对应的仓库的issue下进行更新，添加。然后实时去博客中查看。</p><h3 id="扩展一下"><a href="#扩展一下" class="headerlink" title="扩展一下"></a>扩展一下</h3><p>对于有些爱唠叨的人（比如我），弄个类似碎碎念的东西就比较实用了。之前想过各种方案，存json数据太不方便；后台写个服务部署服务器也太麻烦。最后思来想去还是利用了下现成的优秀项目<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">gitalk</a>,稍稍改改就能很好使用。</p><h4 id="博客中的碎碎念"><a href="#博客中的碎碎念" class="headerlink" title="博客中的碎碎念"></a>博客中的碎碎念</h4><p>对于博主而言，有发表框和修改的操作，能够方便发表和修改。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191128215148.png" alt=""></p><p>可能有时候还会发表一些图片，对图片的样式做了一些控制</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191128215345.png" alt=""></p><p>对于网友的话只能查看以及点赞加❤️</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191128215555.png" alt=""></p><p>做法就是源码中改下返回html的文件内容，如果是管理员和非管理员返回一些不同的元素，能够很好的实现碎碎念的功能。<br>查看<a href="https://removeif.github.io/self-talking/">碎碎念</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>静态博客的动态数据是个痛点，GitHub Issue有很多可利用的地方。多去探索发掘其中的奥妙。</p><p>利用GitHub Issue来解决目前也是一种解决方法。希望后面会出现更好的解决方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;众所周知，对于hexo框架搭建的静态博客，难免会产生一些动态的数据，比如一些碎碎念、友链、音乐、时间轴等微型数据。目前一般的做法:&lt;/p&gt;
&lt;p&gt;a.是创建一个json数据，来存储这些微型数据，但是如果数据太多的话，一是比较慢，二是有个硬伤问题，就是json数据不能分页请求，只能一次拿完，太多的话网络带宽占用太多。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具教程" scheme="https://removeif.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
      <category term="主题工具" scheme="https://removeif.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具教程" scheme="https://removeif.github.io/tags/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>苹果6s ios12 nfc 模拟门禁</title>
    <link href="https://removeif.github.io/2019/11/23/ios/%E8%8B%B9%E6%9E%9C6s-ios12-nfc-%E6%A8%A1%E6%8B%9F%E9%97%A8%E7%A6%81.html"/>
    <id>https://removeif.github.io/2019/11/23/ios/苹果6s-ios12-nfc-模拟门禁.html</id>
    <published>2019-11-23T12:51:32.000Z</published>
    <updated>2019-11-23T13:54:47.357Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，ios系统封闭了对NFC的功能使用。据了解，国外是可以使用的，国内不行，实在搞不懂，有NFC又不能用，这不是浪费资源，多此一举嘛！<br><a id="more"></a></p><h3 id="设备信息"><a href="#设备信息" class="headerlink" title="设备信息"></a>设备信息</h3><p><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123204913.png" alt="设备信息"></div><br><strong>本机信息6s ios12.4 16G</strong><br>ios 11 直接就能读出卡，没这么复杂。<br>ios 12 可以使用，比较复杂。<br>ios 13 好像不能使用。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="越狱"><a href="#越狱" class="headerlink" title="越狱"></a>越狱</h4><p>使用之前需要设备能够越狱，关于越狱后的一系列安全问题请自行百度。越狱方法可以进<a href="https://www.feng.com/" target="_blank" rel="noopener">威锋论坛</a><br>找到自己机型版块里的对应教程。<br>本机是通过Windows爱思助手，一键越狱完成。</p><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>源为图中倒数第三个P开头那个，插件为插件图中打钩的那个，有些插件和源的不能用，目前测试这个源和插件是可用的。</p><p><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212225.png" alt="源"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212307.png" alt="插件"><div></div></div></p><h4 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h4><p><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212532.png" alt="图1"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212614.png" alt="图2"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212642.png" alt="图3"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212703.png" alt="图4"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212727.png" alt="图5"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212755.png" alt="图6"></div><br>1.图1，如果是ios11,点击最上面的scan按钮，靠近门禁卡或公交卡就能读出来，但是iOS12读不出。<br>2.图2，点最后一项。<br>3.图3，点击Connect按钮，把卡靠近手机后壳。<br>4.图4，已经读出UID。<br>5.图5，把UID填上。<br>6.图6，然后点击Start按钮，如图开始模拟nfc卡。靠近刷卡机刷卡。<br>我添加的是门禁卡，亲测成功。也能读取添加公交卡，没测试，应该是可以的。<br>每次只能模拟一张卡，使用另外一张需要手动更换UID。</p><h3 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h3><p>操作中造成的一切损失与博主无关，请自行掂量谨慎操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，ios系统封闭了对NFC的功能使用。据了解，国外是可以使用的，国内不行，实在搞不懂，有NFC又不能用，这不是浪费资源，多此一举嘛！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ios" scheme="https://removeif.github.io/categories/ios/"/>
    
    
      <category term="ios" scheme="https://removeif.github.io/tags/ios/"/>
    
      <category term="nfc" scheme="https://removeif.github.io/tags/nfc/"/>
    
  </entry>
  
  <entry>
    <title>常见隔夜菜谨慎食用</title>
    <link href="https://removeif.github.io/2019/11/18/health/%E5%B8%B8%E8%A7%81%E9%9A%94%E5%A4%9C%E8%8F%9C%E8%B0%A8%E6%85%8E%E9%A3%9F%E7%94%A8.html"/>
    <id>https://removeif.github.io/2019/11/18/health/常见隔夜菜谨慎食用.html</id>
    <published>2019-11-18T08:05:43.000Z</published>
    <updated>2019-11-18T10:04:16.229Z</updated>
    
    <content type="html"><![CDATA[<p>我们有许多习惯，总是重复来，重复去，就像上世纪中的人们带着保温盒去上班，现在的人又重回带着饭盒去公司的现象。自己带饭去公司吃的话，不仅大大地节省了一笔吃外卖的费用，而且菜色也可以随便换。但是，很多人带的都是前一天晚上就准备好的隔夜菜，这样对我们的身体健康到底是有益还是有害呢?<br><a id="more"></a></p><h3 id="隔夜菜的危害大"><a href="#隔夜菜的危害大" class="headerlink" title="隔夜菜的危害大"></a>隔夜菜的危害大</h3><p>节俭归节俭，殊不知，隔夜菜不仅营养流失严重，而且还会产生对身体有危害的物质。要提醒大家的是，<code>隔夜蔬菜、海鲜</code>不要吃，肉类食用时一定要蒸热熟透，以防食物储存时间长，腐败变质，导致食物中毒。</p><p>据说，<code>胃癌发病率低，与不吃隔夜蔬菜的习惯有关</code>。由于部分绿叶类蔬菜中含有较多的硝酸盐类，煮熟后假如放置的时间过久，在细菌的分解作用下，硝酸盐便会还原成亚硝酸盐，有致癌作用，加热也不能去除。</p><p><strong>健康吃法</strong>：通常<strong>茎叶类蔬菜硝酸盐含量最高</strong>，<strong>瓜类蔬菜稍低</strong>，<strong>根茎类和花菜类居中</strong>。因此，假如同时购买了不同种类的蔬菜，应该先吃茎叶类的，比如大白菜、菠菜等。假如预备多做一些菜第二天热着吃的话，应尽量<code>少做茎叶类蔬菜</code>，而<code>选择瓜类蔬菜</code>。</p><h3 id="五种隔夜菜千万别吃"><a href="#五种隔夜菜千万别吃" class="headerlink" title="五种隔夜菜千万别吃"></a>五种隔夜菜千万别吃</h3><p><strong>绿叶菜隔夜最危险</strong>。通常茎叶类蔬菜硝酸盐含量最高，瓜类蔬菜稍低，根茎类和花菜类居中。因此，如果同时购买了大量蔬菜，应该先吃叶菜类的，比如大白菜、菠菜等。如果准备多做一些菜第二天热着吃，应尽量少做茎叶类蔬菜，而选择瓜类蔬菜。</p><p><strong>隔夜海鲜损肝肾</strong>。螃蟹、鱼类、虾类等海鲜，隔夜后会产生蛋白质降解物，损伤肝、肾功能。如果实在买多了，可以把生海鲜用保鲜袋或保鲜盒装好，放入冰箱冷冻，下次再烹调。</p><p><strong>半熟蛋易致病</strong>。很多人都爱吃蛋黄软软的半熟蛋，可是这种蛋杀菌不彻底，再加上鸡蛋营养丰富，格外容易滋生细菌，食用后会发生危险。如果蛋已熟透，而且低温密封保存得当，隔夜再吃是没有问题的。</p><p><strong>银耳蘑菇要当心</strong>。不论是野生的还是人工栽培的银耳、蘑菇等，都容易残留很多硝酸盐。如果放的时间实在有点久，就只能忍痛扔掉。</p><p><strong>汤别放金属器皿里</strong>。熬汤费时费力，人们往往熬一大锅，一连吃好几天。剩汤如果长时间盛在铝锅、铁锅内，会析出对人体有害的物质。存汤的最好办法是，汤里不要放盐之类的调味料，煮好汤用干净的勺子盛出当天要喝的，喝不完的，最好是用瓦锅或保鲜盒存放在冰箱里。</p><h3 id="隔夜菜的保存和食用"><a href="#隔夜菜的保存和食用" class="headerlink" title="隔夜菜的保存和食用"></a>隔夜菜的保存和食用</h3><p>因为蔬菜对于健康有明确的好处，我们不可能因为“可能”有硝酸盐和亚硝酸盐的存在就不吃。对许多人来说，买一次菜吃几天也是很普通很平常的事情。所以，保存蔬菜，就成了食品健康中很重要的问题。</p><p>蔬菜中亚硝酸盐的产生，原料是蔬菜中的硝酸盐，转化条件主要是细菌生长，“隔夜”只是时间长短的问题。减少亚硝酸盐的产生，可以多管齐下。首先，减少蔬菜尤其是绿叶蔬菜的保存时间，增加买菜频率。其次，需要保存的蔬菜，洗净包好可以减少携带的细菌。做好没吃完的蔬菜，也可以封好保存在冰箱中。</p><p>“隔夜”并非亚硝酸盐产生的关键，加热也不会增加致癌物的含量。当然，蔬菜中的许多种维生素，在加热的时候会被破坏，多次加热的蔬菜也比较难吃。从“ 好吃”的角度来说，“隔夜菜”确实比较差;从营养的角度说，多次加热也没什么好处。</p><h3 id="常见的蔬菜分类"><a href="#常见的蔬菜分类" class="headerlink" title="常见的蔬菜分类"></a>常见的蔬菜分类</h3><p><strong>瓜类蔬菜</strong>种类较多,主要有黄瓜、西葫芦、南瓜、节瓜、<a href="https://www.baidu.com/s?wd=青瓜&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">青瓜</a>、丝瓜、云南小瓜、苦瓜、白瓜、茄瓜、毛瓜、<a href="https://www.baidu.com/s?wd=瓠瓜&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">瓠瓜</a>、<a href="https://www.baidu.com/s?wd=佛手瓜&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">佛手瓜</a>、<a href="https://www.baidu.com/s?wd=蛇瓜&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">蛇瓜</a>等。其中，黄瓜为果菜兼用的<a href="https://www.baidu.com/s?wd=大众&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">大众</a>蔬菜，南瓜、苦瓜是药食兼用的保健蔬菜，冬瓜为秋淡季的主要蔬菜，其它瓜类则风味各异，都是膳食佳品。瓜类蔬菜在栽培中具有以下通性：<br>1、瓜类蔬菜均为喜温耐热性作物，生长期间需要充足的光照。<br>2、瓜类蔬菜根系<a href="https://www.baidu.com/s?wd=再生能力&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">再生能力</a>弱，栽培上除直播外，育苗移栽的要保护好根系，培育壮苗。<br>3、瓜类蔬菜均为蔓性作物，生产中通过设立支架可提高产品的产量与品质。<br>4、大部分瓜类蔬菜的采收要及时，防止产品生理成熟后降低品质。<br>5、瓜类蔬菜均为雌雄异花作物，虫媒<a href="https://www.baidu.com/s?wd=异花授粉&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">异花授粉</a></p><p><strong>蔬菜植物</strong>的产品器官有根、茎、叶、花、果等5类，因此按产品器官分类也分成5种。<br><strong>(1)根菜类</strong>：这类莱的产品(食用)器官为肉质根或块根。<br>    ①肉质根类菜：萝卜、胡萝卜、大头菜(<a href="https://www.baidu.com/s?wd=根用芥菜&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">根用芥菜</a>)、芜普、<a href="https://www.baidu.com/s?wd=芜菁甘蓝&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">芜菁甘蓝</a>和根用甜菜等。<br>    ②块根类菜：豆薯和葛等。</p><p><strong>(2)茎菜类</strong>：这类蔬菜食用部分为茎或茎的变态。<br>    ①地下茎类：马铃薯、菊芋、莲藕、姜、荸荠、慈菇和芋等。<br>    ②地上茎类：茭白、石刁柏、竹笋、莴苣笋、<a href="https://www.baidu.com/s?wd=球茎甘蓝&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">球茎甘蓝</a>和榨菜等。</p><p><strong>(3)叶莱类</strong>：这类蔬菜以普通叶片或叶球、叶丛、变态叶为产品器官。<br>    ①普通叶菜类：小白菜、芥菜、菠菜、芹菜和苋菜等。<br>    ②结球叶莱类：<a href="https://www.baidu.com/s?wd=结球甘蓝&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">结球甘蓝</a>、大白菜、<a href="https://www.baidu.com/s?wd=结球莴苣&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">结球莴苣</a>和<a href="https://www.baidu.com/s?wd=包心芥菜&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">包心芥菜</a>等。<br>    ③辛番叶菜类：葱、韭菜、芜荽和茴香等。<br>    ④鳞茎菜类：洋葱、大蒜和百合等。</p><p><strong>(4)花菜类</strong>：这类蔬菜以花、肥大的花茎或花球为产品器官，如花椰菜、金针菜、青花菜、紫菜蔓、 朝鲜蓟和芥蓝等。</p><p><strong>(5)果菜类</strong>：这类蔬菜以嫩果实或成熟的果实为产品器官。<br>    ①茄果类：茄子、番茄和辣椒等。<br>    ②荚果类：豆类菜，菜豆、肛豆、刀豆、毛豆、豌豆、蚕豆、眉豆、扁豆和四棱豆等。<br>    ③瓠果类：黄瓜、南瓜、冬瓜、丝瓜、菜瓜、瓠瓜和蛇瓜等，以及西瓜和甜瓜等鲜食的瓜类。</p><p>参考文章:<br><a href="http://shipin.people.com.cn/n/2015/1026/c85914-27740921.html" target="_blank" rel="noopener">参考链接1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们有许多习惯，总是重复来，重复去，就像上世纪中的人们带着保温盒去上班，现在的人又重回带着饭盒去公司的现象。自己带饭去公司吃的话，不仅大大地节省了一笔吃外卖的费用，而且菜色也可以随便换。但是，很多人带的都是前一天晚上就准备好的隔夜菜，这样对我们的身体健康到底是有益还是有害呢?&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="health" scheme="https://removeif.github.io/categories/health/"/>
    
    
      <category term="health" scheme="https://removeif.github.io/tags/health/"/>
    
  </entry>
  
  <entry>
    <title>马拉松-2019西昌最美赛道邛海马拉松</title>
    <link href="https://removeif.github.io/2019/11/10/marathon/%E9%A9%AC%E6%8B%89%E6%9D%BE-2019%E8%A5%BF%E6%98%8C%E6%9C%80%E7%BE%8E%E8%B5%9B%E9%81%93%E9%82%9B%E6%B5%B7%E9%A9%AC%E6%8B%89%E6%9D%BE.html"/>
    <id>https://removeif.github.io/2019/11/10/marathon/马拉松-2019西昌最美赛道邛海马拉松.html</id>
    <published>2019-11-10T02:03:35.000Z</published>
    <updated>2019-11-12T01:42:59.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最美赛道，2019西昌邛海湿地马拉松于2019.11.09举行。<br><a id="more"></a></p></blockquote><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>比赛之前抱佛脚的方式晚上跑了几晚，还是训练太少，导致最后的悲剧产生，怨不得别人还是自己不努力，捂脸.jpg。<br>以下是比赛之前的部分数据。总共跑了6次。</p><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110101312.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110101333.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110101358.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110101412.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110101429.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110101555.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110101615.jpg" alt=""></div><h3 id="路上风景"><a href="#路上风景" class="headerlink" title="路上风景"></a>路上风景</h3><p>从成都出发去西昌，一路上风景还是很美的，盘山高速立于半空之中，很刺激。途中的岩石，丛林，纷繁各异。<br>不得不惊叹祖国的大好河山，以及大自然的鬼斧神工。<br>车上位置不太好，也拍了几张。<br>途中流彩。</p><div class="img-x"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102533.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102629.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102653.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102729.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102746.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102820.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102911.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102934.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102953.jpg" alt=""></div><h3 id="赛前"><a href="#赛前" class="headerlink" title="赛前"></a>赛前</h3><p>比赛之前领了相关的参赛包。找好了相应的住宿，然后休息。</p><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104003.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104025.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104046.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104105.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104121.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104141.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104157.jpg" alt=""></div><h3 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h3><p>整个赛道中风景很美，最美赛道也不是吹的，哈哈。<br>赛中流彩1</p><div class="img-x"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104953.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105016.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105044.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105112.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105135.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105159.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105352.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105417.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105436.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105453.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105513.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105531.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105555.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105614.jpg" alt=""></div><br>赛中流彩2<br><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110120604.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110120703.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110110218.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110110239.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110120818.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110120933.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110121042.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110121208.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110114345.jpg" alt=""></div><h3 id="完赛"><a href="#完赛" class="headerlink" title="完赛"></a>完赛</h3><p>人生不经历一场全程马拉松真的不知道自己身体有多差，跑到30KM之后基本靠走，抽筋，一会儿左脚一会右脚，太难了。<br>归根到底还是前期准备太少了，跑的太少了，不能临时抱佛脚啊。没有捷径，得一步一步的积累啊。这就是血淋淋的案例啊。<br>跑两步，抽一下，又不得不停下来走，真的是太难了，之前跑过两次半马，没出现这个情况，可能我的极限就是30KM了吧。<br>最后还是坚持走完了，用时<code>5小时8分钟</code>，赶在6小时关门前跑完了。第一次全马，也算PB了吧。<br>全马数据。</p><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110115052.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110115113.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110115127.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110115143.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110115156.jpg" alt=""></div><h3 id="奖牌"><a href="#奖牌" class="headerlink" title="奖牌"></a>奖牌</h3><p>奖牌还是挺不错的，挺有纪念意义的。人生第一次全马，也可能是最后一次，庆幸自己坚持下来安全完赛，给自己点个赞👍！</p><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110115954.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110120101.png" alt=""></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>人生就像一场马拉松，有悲有乐，有意外有惊喜，沿途有各种美丽的风景，遇见。这一路肯定不会一番风顺，希望我们遇到困难险阻时都能乘风破浪，坚持到最后。<br>当我们到了人生暮年的时候，回想起过去，也能都感觉到这人生不虚此行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最美赛道，2019西昌邛海湿地马拉松于2019.11.09举行。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="marathon" scheme="https://removeif.github.io/categories/marathon/"/>
    
    
      <category term="marathon" scheme="https://removeif.github.io/tags/marathon/"/>
    
  </entry>
  
  <entry>
    <title>算法成长之路leetcode1-4</title>
    <link href="https://removeif.github.io/2019/11/05/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode1-4.html"/>
    <id>https://removeif.github.io/2019/11/05/algorithm/算法成长之路leetcode1-4.html</id>
    <published>2019-11-05T10:18:47.000Z</published>
    <updated>2019-11-07T05:31:41.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1.Two Sum"></a>1.<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a></h2><h3 id="desc"><a href="#desc" class="headerlink" title="desc"></a>desc</h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br><a id="more"></a></p><p><strong>Example:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><h4 id="s-eg1"><a href="#s-eg1" class="headerlink" title="s.eg1."></a>s.eg1.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//24 ms38 MB s.O(n^2) k.O(1)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span>[] result =<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length-<span class="hljs-number">1</span>;i++)&#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                    result[<span class="hljs-number">0</span>] = i;</span><br><span class="line">                    result[<span class="hljs-number">1</span>] = j;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eg2"><a href="#eg2" class="headerlink" title="eg2."></a>eg2.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 3 ms37.2 MB s.O(n) k.O(n)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; cache = <span class="hljs-keyword">new</span> HashMap();</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(cache.get(nums[i]) != <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;cache.get(nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            cache.put(target-nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2.Add Two Numbers"></a>2.<a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">Add Two Numbers</a></h2><h3 id="des"><a href="#des" class="headerlink" title="des"></a>des</h3><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h3><h4 id="eg1"><a href="#eg1" class="headerlink" title="eg1."></a>eg1.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 2 ms44.7 MB</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">         <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>; <span class="hljs-comment">// 进位</span></span><br><span class="line">         ListNode head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);</span><br><span class="line">         ListNode cur = head; <span class="hljs-comment">// 一定要用两个链表，不能用一个操作</span></span><br><span class="line">       <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> ||l2 != <span class="hljs-keyword">null</span>|| carry != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// lastSum当最后一位刚好进1的时候，需要在循环</span></span><br><span class="line">           </span><br><span class="line">            <span class="hljs-keyword">int</span> l1v =  l1 == <span class="hljs-keyword">null</span>?<span class="hljs-number">0</span>:l1.val;</span><br><span class="line">            <span class="hljs-keyword">int</span> l2v =  l2 == <span class="hljs-keyword">null</span>?<span class="hljs-number">0</span>:l2.val;</span><br><span class="line">            <span class="hljs-keyword">int</span> temp =l1v+l2v+carry;</span><br><span class="line">            ListNode node;</span><br><span class="line">            <span class="hljs-keyword">if</span>(temp&gt;=<span class="hljs-number">10</span>)&#123;</span><br><span class="line">               node = <span class="hljs-keyword">new</span> ListNode(temp-<span class="hljs-number">10</span>);</span><br><span class="line">               lastSum = <span class="hljs-number">1</span>;</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">               node = <span class="hljs-keyword">new</span> ListNode(temp);</span><br><span class="line">               lastSum = <span class="hljs-number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-keyword">null</span>) l2 = l2.next;</span><br><span class="line">         </span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3.Longest Substring Without Repeating Characters"></a>3.<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></h2><h3 id="desc-1"><a href="#desc-1" class="headerlink" title="desc"></a>desc</h3><p>Given a string, find the length of the longest substring without repeating characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h3><h4 id="eg1-1"><a href="#eg1-1" class="headerlink" title="eg1."></a>eg1.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//2 ms 24.05% 36.9 MB 95.35%</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; strSet = <span class="hljs-keyword">new</span> HashSet();</span><br><span class="line">        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span>(s != <span class="hljs-keyword">null</span> &amp;&amp; s.length() &gt;<span class="hljs-number">0</span>)&#123;</span><br><span class="line">            <span class="hljs-keyword">char</span> ss[] = s.toCharArray(); <span class="hljs-comment">//利用toCharArray方法转换</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ss.length-<span class="hljs-number">1</span>; i++) &#123;</span><br><span class="line">                strSet.add(ss[i]);</span><br><span class="line">                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j&lt;ss.length; j++)&#123;</span><br><span class="line">                    <span class="hljs-keyword">int</span> oL = strSet.size();</span><br><span class="line">                    strSet.add(ss[j]);</span><br><span class="line">                    <span class="hljs-keyword">int</span> cL = strSet.size();</span><br><span class="line">                    <span class="hljs-keyword">if</span>(oL != cL)&#123; <span class="hljs-comment">// 不相等时记下个数</span></span><br><span class="line">                        <span class="hljs-keyword">if</span>(cL &gt; maxLen)&#123;</span><br><span class="line">                            maxLen = cL;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 相等时 跳出此次循环 清空set</span></span><br><span class="line">                           strSet.clear();</span><br><span class="line">                           <span class="hljs-keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span>(maxLen == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 全相等时</span></span><br><span class="line">                maxLen = <span class="hljs-number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eg2-1"><a href="#eg2-1" class="headerlink" title="eg2."></a>eg2.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 2 ms37.3 MB</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="hljs-keyword">int</span> leftIndex = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录最左边相等时的值，然后向右滑动窗口</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; chars.length; j++) &#123;</span><br><span class="line">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> innerIndex = leftIndex; innerIndex &lt; j; innerIndex++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (chars[innerIndex] == chars[j]) &#123;</span><br><span class="line">              maxLength = Math.max(maxLength, j - leftIndex);</span><br><span class="line">              leftIndex = innerIndex + <span class="hljs-number">1</span>;</span><br><span class="line">              <span class="hljs-keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> Math.max(chars.length - leftIndex, maxLength);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4.Median of Two Sorted Arrays"></a>4.<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">Median of Two Sorted Arrays</a></h2><h3 id="desc-2"><a href="#desc-2" class="headerlink" title="desc"></a>desc</h3><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><p><strong>Example 1:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><h3 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h3><h4 id="eg1-2"><a href="#eg1-2" class="headerlink" title="eg1."></a>eg1.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 20 ms  10.07%</span></span><br><span class="line"><span class="hljs-comment">// 2.2 MB 99.84%</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> maxL = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (nums1.length &gt;= nums2.length) &#123;</span><br><span class="line">            maxL = nums1.length;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            maxL = nums2.length;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; newList = <span class="hljs-keyword">new</span> ArrayList(maxL);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxL; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (i &lt; nums1.length) &#123;</span><br><span class="line">                newList.add(nums1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (i &lt; nums2.length) &#123;</span><br><span class="line">                newList.add(nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> size = newList.size();</span><br><span class="line">        <span class="hljs-keyword">int</span> index = size / <span class="hljs-number">2</span>;</span><br><span class="line">        newList.sort(Comparator.comparing(Integer::valueOf));</span><br><span class="line">        <span class="hljs-keyword">if</span> (size % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> (newList.get(index) + newList.get(index - <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span>d;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> newList.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eg2-2"><a href="#eg2-2" class="headerlink" title="eg2."></a>eg2.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> n = nums1.length + nums2.length;</span><br><span class="line">        <span class="hljs-keyword">double</span> res = <span class="hljs-number">0.0</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            res = (findKth(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n / <span class="hljs-number">2</span>) + findKth(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            res = findKth(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKth</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> start1, <span class="hljs-keyword">int</span> start2, <span class="hljs-keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (start1 &gt;= nums1.length) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> nums2[start2 + k - <span class="hljs-number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (start2 &gt;= nums2.length) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> nums1[start1 + k - <span class="hljs-number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">int</span> left = start1 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &gt;= nums1.length ? Integer.MAX_VALUE : nums1[start1 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>];</span><br><span class="line">        <span class="hljs-keyword">int</span> right = start2 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &gt;= nums2.length ? Integer.MAX_VALUE : nums2[start2 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>];</span><br><span class="line">        <span class="hljs-keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> findKth(nums1, nums2, start1 + k / <span class="hljs-number">2</span>, start2, k - k / <span class="hljs-number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> findKth(nums1, nums2, start1, start2 + k / <span class="hljs-number">2</span>, k - k / <span class="hljs-number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eg3"><a href="#eg3" class="headerlink" title="eg3."></a>eg3.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 二分查找、分治算法</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//m:A数组的长度</span></span><br><span class="line">        <span class="hljs-keyword">int</span> m = A.length;</span><br><span class="line">        <span class="hljs-comment">//n:B数组的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> n = B.length;</span><br><span class="line">        <span class="hljs-comment">//如果A的长度大于B</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (m &gt; n) &#123; <span class="hljs-comment">// to ensure m&lt;=n</span></span><br><span class="line">            <span class="hljs-comment">//交换AB数组，确保m&lt;=n</span></span><br><span class="line">            <span class="hljs-keyword">int</span>[] temp = A; A = B; B = temp;</span><br><span class="line">            <span class="hljs-keyword">int</span> tmp = m; m = n; n = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//设置两个指针，iMin为头指针，IMAX为尾指针，halfLen为中位数指针</span></span><br><span class="line">        <span class="hljs-keyword">int</span> iMin = <span class="hljs-number">0</span>, iMax = m, halfLen = (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;</span><br><span class="line">        <span class="hljs-comment">//如果头指针走向不大于尾指针，进行循环</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (iMin &lt;= iMax) &#123;</span><br><span class="line">            <span class="hljs-comment">//i为中位数</span></span><br><span class="line">            <span class="hljs-keyword">int</span> i = (iMin + iMax) / <span class="hljs-number">2</span>;</span><br><span class="line">            <span class="hljs-comment">//j为</span></span><br><span class="line">            <span class="hljs-keyword">int</span> j = halfLen - i;</span><br><span class="line">            <span class="hljs-keyword">if</span> (i &lt; iMax &amp;&amp; B[j - <span class="hljs-number">1</span>] &gt; A[i])&#123;</span><br><span class="line">                iMin = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// i is too small</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; iMin &amp;&amp; A[i - <span class="hljs-number">1</span>] &gt; B[j]) &#123;</span><br><span class="line">                iMax = i - <span class="hljs-number">1</span>; <span class="hljs-comment">// i is too big</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// i is perfect</span></span><br><span class="line">                <span class="hljs-keyword">int</span> maxLeft = <span class="hljs-number">0</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123; maxLeft = B[j-<span class="hljs-number">1</span>]; &#125;</span><br><span class="line">                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123; maxLeft = A[i - <span class="hljs-number">1</span>]; &#125;</span><br><span class="line">                <span class="hljs-keyword">else</span> &#123; maxLeft = Math.max(A[i - <span class="hljs-number">1</span>], B[j - <span class="hljs-number">1</span>]); &#125;</span><br><span class="line">                <span class="hljs-keyword">if</span> ( (m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> ) &#123; <span class="hljs-keyword">return</span> maxLeft; &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">int</span> minRight = <span class="hljs-number">0</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span> (i == m) &#123; minRight = B[j]; &#125;</span><br><span class="line">                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == n) &#123; minRight = A[i]; &#125;</span><br><span class="line">                <span class="hljs-keyword">else</span> &#123; minRight = Math.min(B[j], A[i]); &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">return</span> (maxLeft + minRight) / <span class="hljs-number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Two-Sum&quot;&gt;&lt;a href=&quot;#1-Two-Sum&quot; class=&quot;headerlink&quot; title=&quot;1.Two Sum&quot;&gt;&lt;/a&gt;1.&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Two Sum&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;desc&quot;&gt;&lt;a href=&quot;#desc&quot; class=&quot;headerlink&quot; title=&quot;desc&quot;&gt;&lt;/a&gt;desc&lt;/h3&gt;&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://removeif.github.io/categories/algorithm/"/>
    
    
      <category term="二分查找" scheme="https://removeif.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="分治算法" scheme="https://removeif.github.io/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://removeif.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="滑动窗口" scheme="https://removeif.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>2019成长记01</title>
    <link href="https://removeif.github.io/2019/10/30/private/2019%E6%88%90%E9%95%BF%E8%AE%B001.html"/>
    <id>https://removeif.github.io/2019/10/30/private/2019成长记01.html</id>
    <published>2019-10-30T09:54:02.000Z</published>
    <updated>2019-10-31T08:45:02.105Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="不好意思，密码没对哦，在检查检查呢！" data-whm="不好意思，信息无法验证！">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="嗨，请准确无误地输入密码查看哟！">    <label for="hbePass">嗨，请准确无误地输入密码查看哟！</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="5bdbbc1065a66576ee2e09e6a267a1af41586f736339edad59373b58b08e900f">49d4672d87adb783416f01c7b149643aa790bb4559fa05a3b871756fb9212ce51830603ea9c9e58917565a354166954d50e2ad8b557cd5eb5772d6d390425d13161fbd884b5146e77fadccc8dd9e7e18a2b1e90af7a2991c59f7e674e9f41d3388184c35d12e78c3b3f69dc2357bc5bcd305f330a1dda7560f7223d8bf898adf70045a70cac2d6325b1c65f4f846aeaae23d0df357d455cb1620f5ed257fadec8aa18f464c73330a156a727733cd467c541e53dcde7ed8692499a636ba7061a0d1e531758e874e1a3c362da7b8726c111fdc2845db60901b417b9e021ad64b403b1d7c0e6d63a3370ba59da03339688d9c0c62c671bd5e70a1e952e1b35bf96a6654ce220be82166d4af08feac234ec0e77b6ffb7b55c68beab3adc80e61177b086a210c7cb969a491852bb0831fb35383b248c74af9ad86e56069a9c9a47d4d39eea775c3eb84f0d5b8308f7b839f7e02472f49d55f525d331712dc670b321004071a169c84336b6d37a3234aaa5f26f304e0f6964ae56fc288f4b8fc529c878571d867f4a8034ae962871b92adf5a96d7c1e0c48da3ea285ce975481a53bdcab1760acc085c97030073bfa80932ad406aec86c4316f069f56dbd532ffbc71717679527071820e521a563101b4e84900f8b60fe3c8fc2d726ebcd1e1454f862a874af27d8ef0a47a8a4af0ed877e874afe4141c871ceb3cfe9649ae1743cd19ff07ce0d8a89daaa998e1c243467554071d11683cb00feea3e4fa1a373ac8f0d30a656374064999b555776249117d6709a67d87adc8fc1bbe710f52ca962c7ef551404664ce62a9972607121ab8bf08c8b50ecbcf007ed06c1946d93f6b2b3ebd903201856aba38752014993bdfd93b6e61de7e12dc40719f94a85a53a207318ed16cafbfbc87407bc4bb31f61580b6431b5898ce79f99568c1ed52bd76a5a2014e2e9ff9f4fc23d4d0cac1e187dba4cc91de1b8ff9ec5b13c414f634d7b21f57227a225fae0bcfe2f1180140a345936a127226e39e4d80a1eb6f46382df39651f4c49ca891d798a9051a414b4601cb0e4863a29b6c4b5b642d0f052b698c13108b217c5754d1cabf2702142fba7ff9a8b2b4425d042b9394286efbca814cb262902b363067f595f685ba94e8500ca6d4ba0e2d0fb1a112dc6d6a7fc91126d88a36e96ba24be31d41070d17a2c197dd8146f504da5f51e372cef02a01ff4576520967f0432295e0392c4e755101eb8ee6d3bdc87083de0c9b869efb29b80b34ddbad0a34adf59e3b4e6e4f7130ba3ed429ada7031272fd1f2135fb75c1cfc97651247494236e9be148e09feb63b425f46ddc5786978fd1157d5471874ad4da5512d03138876183e8dd95b21687b19653fda37f045d4c246400df29f8f3ba62e2bcbd8bf7284c15c14a63424237e78575845c3793bfcca831c79b3e3100cca06cf2abb80116257426a1c6bf755facd7952b34efb81650943e972d22a10a87c74316a97604445e61cb388c1913ef8d164dfa925e937765f68151440ff587f793a01c1413770e466618a9c6ce41c30f90186450b40f400638bc4010a1b91850e1fb44b3d0ce455a002c1ecdb545de4d496971cae00d01b6b7c924c5d3dadf65aaafa4b5d51a62a9da2308fb7c45a73ec68b997511c8b695a15d7fb8545cb97bd76f69060e5574e920d0560b4982e1dd884e36754c778baa69c7eb064329e9ed32a7b7abd9de40f9ea2872615dbd4aa9faaae13944abaed8e56dd287d0fc87e2331cce80b3588b5f25f41e6492f07df8379f640eddfd10eba7bbf5e43e81476344a2f25e27da7ae558ffb3ec4fcbbfee9fa1c969848401c9cd969cabb93f6fa1db8647f1280b8f6eedde1ac8e20f83392b535bdab829f67faa3c7f4a154eca4581ca271b22399ee684a950c8db811a51258f16324d81098d14aac2a122044d2e34800c964842f432e86c5ba741b995ea8eda26683b9da60a7e1e7cfe2fc15dcd900c5a042bb3c8f341ec531b65bb41c4dc2be6dff0c5659286eb540ef2a3f7674b8350964e0504df5a8440e760b7dd70c4c60c6d80820cb2576dadefd4007b5c98e4f2256205d6cf360d8ede5b58dfef41a0be4b79245b01bfe07576470964c1dc7ee603f9b08e4735f668ab805d12195f118308687fe77c193bcdd73a0aed6abc376fb73ddf193d84a66a658de616f33f4770f3cceaf2012cad495f956c3329a8ab211e9cbd78f5a733b94f77f7b2b546e42842587b7de558f7f8fbb2c6b3e313e6bf3d025fe8d57a0862f1f54fe49fea0ebe07a470280b6eb75310e75296c0fc4045462c7e567ccb2ef070efda925a9c476d3ba15b912110fe8c836ea8f9f2da6ed5fb28279997307fd091e5655dc4ac882c640f88bb841133b47160a389fad67bc194231f0fadd4649a7f3e1bb5d4c2c5fcaddc50948457884c3d494d71f24d35e10e24522b23dbe4bf8cff561dc250c5000698eb86e4cae3fb47164b4149b0b0d4bde078ae1e1ae5e5b4f16e9a8ce54fbad694ddf3c8c047ecb4a02ee90963c5c25e2653b2bc314c80b1f465da4fb2dcd84aebefb22707d6fce8a5e0628281c4f1cb905362b8aa830a622f328ba065008b9c208e30790e0ad19e18cc2e2fd504092216b418dbe9213c998ea7d1f4b42ef849e072c44ba3de2a64c6daf2f0eef5c3b192137baf9482fd8e5eb55a57d089fadf66c80b85e5907f43054ee4e7b3a86e8a8cb93b515961192a30d08b2834230d05a67d31a7f316d0327fb1d50ae690d234c797f5c05ddeea8cc7060c9a40fe4bfb90e3b21d8605feb98803879afc7f268699e7570764de689266dc2f99c49648d5a678d1efb17a184863de45b44911441956679353e0cac16c2bc646909095da0a6806ef255d283c9805de8d0136903402e12a75c0467bfc7b70f8bc6185683b7df27a3ddf66ad04fcf687d88b1429d2469d0b5fd56aaa0c78c12b4951686729598cb764c79db31a6393aa39ed8b8c801d6a097a057a2fef7a505fa9728f001acac08e108cb141cac3f2d2c5af063c69b577c32b250e418a436d828a9f3f8433457a09803f6d79134e6eaac00cb69cafe200d175c133227c2e057b426a4966ceef781d4edb74cd37f00dad623199461014b368ef1b87f2a572fdff2a112ad08e48da386b06263538f321f91c9e8db1d956818540ba02f023ab337be548db30e4db9427c81e062167aa27230b5fc985800054d654e75dcf841311a8864d0a531c48963eb65d991f748eeb075c2959b0607c3b37a346011b081f795cb46ea1bbfd4edce3ed2aab93602b3afea71401348d7880d7c6d69d3206ddd39c6489dc710e6ceba656bd7ba386f49c58fa59aaaa22ce08439f10ba4054ce445d79c9d45d197dea27e732dc1f4f8634ec8ed4fcba298b6f6e81c0fe139e13ae3482ca06ebe2c0eca68a6439dcce26a9f4c03a4697b1c8a10d23452975ebfd5f0520f6a9b04ec9a52de12bc9f9d27dd535fe159c95dd471eafa68f26e646fbabca4ce43b62c11f7873bdcdd92e71d8a1fd33d720c3b28a8464d96b541584c73dfb3820019382cc9bc7270277034c2a9d437d961d7282bd8b9659aaf22ca77989b64dfeda40db271d57041f8c39a1d83755c60042fd81aea1d74ac34d237604097641eb82133dad97df8fb9839eb84646143d32d0009ceddf70f5938aaee7a05aab9e72be7d452b5f471578602bd74a671b8d397dfd093c87a1884bba41987623d65154a2de13504e8c30a57c6a0cc11ec6dfcfcfdbbccaec2ec709e5552554fc71334365fb48a3b2202bac9d070b626a079d284889672609132390f562868cfefc7cdbf2f0ff00f8c2d463b47139bbff2fa925d21e5e4b4d8318d734ccc02eff0ff8f67cdbd15994f922653605589346057f78097c563516357e008196679abf80852d67908bb2cbc1219f883b239a048cd77766040da4a528e0fd3603fe3cb1eb94422d62e5244b9359c2b7165dcfaa837f623fefdb08e1e50d360f3042d5ddb5b5fd8247f1d50b02dba2c4753e98fb706a7fe9622e190516fa477ace2b348228b0e192df3d0e63efd0ab2d7968b606706883446c5a49599c3b97f0a2ef94a2cda8066a84bc775e3bbd1bfd3d0eff89967fe1abe05a17f7cf56d3cc7a7b6d24176d2de7f679874db0911accfc976def51b8de70dfc3ffdde847b619211025bc8a0baff5654d380955df126651c5dbf21731128bc754a2cdafdee6e52445107c55cbefbfebd86defb38661fd01e83c9409fd6ea86eea4800d1630ce3c32ce35126f776bf8f3043f9dddc0c0184fc1b176f460fc4eac294dedbb0727430d127cac679304daccc0bff0ab5ee609a327b21610dae2c81fa6d5fffe0455c2940912ca5a93b3b58666930ad7ec7f21bb4989c1c033040035db2bb322a6d48486c19ecb6951e9842b8ea101a517437f4c23972f2a52bca879a5f1af18aba4f5bff8c0290dc97106382862224fa581272d57d779936348f02f9956c87ae859fafaebe49c7cface878950470e63cc8c93e0215bc745191dd6fd6edb1db52ed2ac81d6f695f5fcf0a309a1e1de815e7af07abc0d64b3b081ef2fb6b518af5ac9a65576b3825d3067876e1b6e5b4270713661f43e1577de8577b1119dfb9fe27c7b5392b66f439f1f8add1b676a7a16a58f31fcb28487023dd7a7e54b63208ea5c8d5f092603e7f539227851ce5a6c0618d844fe1061d405c1659dafc9ad7642fb727b3356839ecbb07b7fc17b7c44e14c3b9dd01ef1995f45f3595dc7be855b8b218df825fbe05f442daf95f245a3b9d41c48d852aab19a910e1cf9797802cf795d31fbcd34545b68bcd4b47aa623675502b3df77090d4b46eea490a8a1d5d67530ecd3c545e94544838346f8e49966f1caa18f8ea37923402616b6490ba53c5ae3b24f2e385c93c509b1c7ead3d799c1a9ac8b30306f41fbbb544400314a94039e35c8163c6f25e1995a60e8b83af9fa64646755e3a162121bcda0e7ba25b6db335c9275f4ee6f2b773afab12c23a58a114cc620d6e3b822566aa2df3937f1fe9612c5ef615f815548f34e4fe4be3e5094d6938b009ce139b79eb61ade391e4cd695c087b97087e4f8fbe64bec5e9a760100751b7e31ce8c2a92d55f69dc175b75c001590c0f0934428bbfcd8632aa63bf3c598c5f894e0c56b0f7bfad5a4637714d6d8f08028ba27bdc00f3a7a39fa06fac5a96689f7b17da9e35503def707d51456144a180c09db4d0d26999cf8e1222e3c88804e10f288a639ef1ceaa0a616ee2462da659816dee9a18ab2303c6596b06af5c6a60e9618f372afede69f0ae3d0b176d899c99adf9dff91bbb26ddb17502e8c630d51491c50a82d35a485deca28076b0d0655c82b2a0573c8d76bd2cfcef3f89c5ad5302071e10bf4417842ed3ffd07b3359603b799e366cb81f308a9843abdba9d6ab468e9201347b8b223319f8e5aff86232670939e1dee6064ced4aa3328dbfca6a3c61b167e7a5eadd02c725b40af752dd51a0391b1281ed10f24788c3d6c099ea401bd636879eb0bb7d0e6351268bc28fa10b1b72ff36d160ebe7b940b445c4ab3c9f915ecb7647b62ec70fd52ed208a62478a1a265aeefd187f488bbef526a02ebe788a96038bcf29a415b906651472dce50091f5448bb0fd04ed5716ac11584540cbc1d91724e18ce246690ee9644b4b0308b67cbcd7e6510cfb14459498b37896e0c399d2fc76b4d75e5d1f3a9f9fdcacf1df654adf6d23e20c34a0529b665e4591473bc0cc2430b2ef3cee8b944ee3e23ab2f172d8d105c8c8f284fb5e91643dde1e0041b4361f78aa6cc4c55e7d97455101b7278ed4ef72d54147b15462207ade97d22e610956b5bcd94182d555eeffefd2ac48d54ba7b02361d25a473563aad9d977824b570ee6db74a3d5ea7a0e07ebb731049e91625709ae088e7442ff3e3977c4c68eb8178347855d24409a75f1dac539a7228f2e08e3da52a2d82c62f3672843ce355590e75aad3ea892da8aa0a7a962bd7cf0249dc5a723795fbb39ca2da755054c45f60c0c887d2edddc01d6a7213842bda45f271e270206256c83057d43b619342e76ed6df50bb4f1a9f73540d3a57560ab7e2b35060257191963662166a365229deb900996059b99eb05aaba78555dc869c9ac9b0960acd6bafa91a72857c0a3aee7302be6fcd7ed00cea4e0787c56852234a6879fe2e1c4795a56912b4c6e1adad874225e9655b4319091fac7495068c82c72a68454e705760729f3a30f86a90c2a5a9933823979f761914a83423b71ce02260a1afced1014efac496cea1d4dac374e71a6339a5ee7c77845308e6ba815375f5d92f238d7e225ac6d9fc8f326463ca01a12c59798676e4f8b736422fb6d5c70805b3fdaa3d181989436457b5b48103326c263d7eaf546718341b4f23dc39f3aae09bc06d641d8d607e7fdbee9174ee1b2cb454c249e699d0a061c690a1c6b08e594549d53b5ec2633e855ef7a7c881d8735eb78600ab1ed394cccd4fb4ba41e327394419fd6d1af1258e47e8508409ca308a31059a5f3e283f2944a4538800b98b9287ea6f3ff71386c4399b1c71f70d69d1390438390f44b9ced642d5cb6c635d28da76cc3fa3612e4f171942f8c964116c89e4d01a9e5c31a02c8ff1e931fe1ba3a174ff4cbb25</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      咦，这是一篇加密文章，好像需要输入密码才能查看呢！
    
    </summary>
    
    
      <category term="private" scheme="https://removeif.github.io/categories/private/"/>
    
    
      <category term="think" scheme="https://removeif.github.io/tags/think/"/>
    
  </entry>
  
  <entry>
    <title>替代web-cookie存储方案实现</title>
    <link href="https://removeif.github.io/2019/10/23/front/%E6%9B%BF%E4%BB%A3web-cookie%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://removeif.github.io/2019/10/23/front/替代web-cookie存储方案实现.html</id>
    <published>2019-10-23T10:33:34.000Z</published>
    <updated>2019-10-23T10:35:27.417Z</updated>
    
    <content type="html"><![CDATA[<p>随着移动网络的发展与演化，我们手机上现在除了有原生 App，还能跑“WebApp”——它即开即用，用完即走。一个优秀的 WebApp 甚至可以拥有和原生 App 媲美的功能和体验。<br>WebApp 优异的性能表现，有一部分原因要归功于浏览器存储技术的提升。cookie存储数据的功能已经很难满足开发所需，逐渐被WebStorage、IndexedDB所取代，本文将介绍这几种存储方式的差异和优缺点。<br><a id="more"></a></p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="1、Cookie的来源"><a href="#1、Cookie的来源" class="headerlink" title="1、Cookie的来源"></a>1、Cookie的来源</h3><p><strong>Cookie 的本职工作并非本地存储，而是“维持状态”</strong>。因为<strong>HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存</strong>，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。</p><p>在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了Cookie。它就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。</p><p>我们可以把Cookie 理解为一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。</p><p>在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p><h3 id="2、什么是Cookie及应用场景？"><a href="#2、什么是Cookie及应用场景？" class="headerlink" title="2、什么是Cookie及应用场景？"></a>2、什么是Cookie及应用场景？</h3><p><strong>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储</strong>。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的set-cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。</p><p><strong>Cookie 以键值对的形式存在</strong>。</p><p>典型的应用场景有：</p><ul><li>记住密码，下次自动登录；</li><li>购物车功能；</li><li>记录用户浏览数据，进行商品（广告）推荐。</li></ul><h3 id="3、Cookie的原理及生成方式"><a href="#3、Cookie的原理及生成方式" class="headerlink" title="3、Cookie的原理及生成方式"></a>3、Cookie的原理及生成方式</h3><p>Cookie的原理：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191023180445.png" alt=""></p><p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie信息发送给服务器，服务端会辨别用户身份，另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p><p>Cookie的生成方式主要有两种：</p><ul><li><strong>生成方式一：http response header中的set-cookie</strong></li></ul><p>我们可以通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值。</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2018 07:28:00 GMT;//可以指定一个特定的过期时间（Expires）或有效期（Max-Age）</span><br></pre></td></tr></table></figure><ul><li><strong>生成方式二：js中可以通过document.cookie可以读写cookie，以键值对的形式展示</strong></li></ul><p>例如我们在掘金社区控制台输入以下三句代码，便可以在Chrome 的 Application 面板查看生成的cookie：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">document</span>.cookie=<span class="hljs-string">"userName=hello"</span></span><br><span class="line"><span class="hljs-built_in">document</span>.cookie=<span class="hljs-string">"gender=male"</span></span><br><span class="line"><span class="hljs-built_in">document</span>.cookie=<span class="hljs-string">'age=20;domain=.baidu.com'</span></span><br></pre></td></tr></table></figure><p><strong>Domain 标识指定了哪些域名可以接受Cookie</strong>。如果没有设置domain，就会自动绑定到执行语句的当前域。 如果设置为”.baidu.com”,则所有以”baidu.com”结尾的域名都可以访问该Cookie，所以在掘金社区上读取不到第三条代码存储Cookie值。</p><h3 id="4、Cookie的缺陷"><a href="#4、Cookie的缺陷" class="headerlink" title="4、Cookie的缺陷"></a>4、Cookie的缺陷</h3><ul><li><strong>Cookie 不够大</strong></li></ul><p>Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。此外很多浏览器对一个站点的cookie个数也是有限制的。</p><p>这里需注意：各浏览器的cookie每一个<code>name=value</code>的value值大概在4k，所以4k并不是一个域名下所有的cookie共享的,而是一个name的大小。</p><ul><li><strong>过多的 Cookie 会带来巨大的性能浪费</strong></li></ul><p>Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。</p><p>cookie是用来维护用户信息的，而域名(domain)下所有请求都会携带cookie，但对于静态文件的请求，携带cookie信息根本没有用，此时可以通过cdn（存储静态文件的）的域名和主站的域名分开来解决。 - 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。</p><h3 id="5、Cookie与安全"><a href="#5、Cookie与安全" class="headerlink" title="5、Cookie与安全"></a>5、Cookie与安全</h3><p>HttpOnly 不支持读写，浏览器不允许脚本操作document.cookie去更改cookie， 所以为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="hljs-number">21</span> Oct <span class="hljs-number">2015</span> <span class="hljs-number">07</span>:<span class="hljs-number">28</span>:<span class="hljs-number">00</span> GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><p>标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><p>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。</p><p><strong>HTML5中新增了本地存储的解决方案——Web Storage，它分成两类：sessionStorage和localStorage</strong>。这样有了WebStorage后，cookie能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。</p><h2 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h2><h3 id="1、LocalStorage的特点"><a href="#1、LocalStorage的特点" class="headerlink" title="1、LocalStorage的特点"></a>1、LocalStorage的特点</h3><ul><li>保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据；</li><li>大小为5M左右；</li><li>仅在客户端使用，不和服务端进行通信；</li><li>接口封装较好。</li></ul><p>基于上面的特点，LocalStorage可以作为浏览器本地缓存方案，用来提升网页首屏渲染速度(根据第一请求返回时，将一些不变信息直接存储在本地)。</p><h3 id="2、存入-读取数据"><a href="#2、存入-读取数据" class="headerlink" title="2、存入/读取数据"></a>2、存入/读取数据</h3><p>localStorage保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用setItem方法。它接受两个参数，第一个是键名，第二个是保存的数据。 </p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="hljs-string">"key"</span>,<span class="hljs-string">"value"</span>);</span><br></pre></td></tr></table></figure><p>读取数据使用getItem方法。它只有一个参数，就是键名。 </p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> valueLocal = localStorage.getItem(<span class="hljs-string">"key"</span>);</span><br></pre></td></tr></table></figure><p>具体步骤，请看下面的例子：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.localStorage)&#123;</span></span><br><span class="line"><span class="hljs-javascript">  localStorage.setItem（<span class="hljs-string">'name'</span>,<span class="hljs-string">'world'</span>）</span></span><br><span class="line"><span class="hljs-javascript">  localStorage.setItem（“gender<span class="hljs-string">','</span>famale<span class="hljs-string">'）</span></span></span><br><span class="line"><span class="hljs-undefined">&#125;</span></span><br><span class="line"><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"gender"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript"><span class="hljs-keyword">var</span> name=localStorage.getItem(<span class="hljs-string">'name'</span>)</span></span><br><span class="line"><span class="hljs-javascript"><span class="hljs-keyword">var</span> gender=localStorage.getItem(<span class="hljs-string">'gender'</span>)</span></span><br><span class="line"><span class="hljs-javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'name'</span>).innerHTML=name</span></span><br><span class="line"><span class="hljs-javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'gender'</span>).innerHTML=gender</span></span><br><span class="line"><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、使用场景"><a href="#3、使用场景" class="headerlink" title="3、使用场景"></a>3、使用场景</h3><p>LocalStorage在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 LocalStorage 来做。</p><p>这里给大家举个例子，考虑到 LocalStorage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：</p><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>sessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，<strong>即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享</strong>；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage的属性和方法与LocalStorage完全一样。</p><h3 id="1、sessionStorage的特点"><a href="#1、sessionStorage的特点" class="headerlink" title="1、sessionStorage的特点"></a>1、sessionStorage的特点</h3><ul><li>会话级别的浏览器存储；</li><li>大小为5M左右；</li><li>仅在客户端使用，不和服务端进行通信；</li><li>接口封装较好。</li></ul><p>基于上面的特点，sessionStorage 可以有效对表单信息进行维护，比如刷新时，表单信息不丢失。</p><h3 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><p>sessionStorage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 sessionStorage就主要是存储你本次会话的浏览足迹：</p><p>lasturl 对应的就是你上一次访问的 URL 地址，这个地址是即时的。当你切换 URL 时，它随之更新，当你关闭页面时，留着它也确实没有什么意义了，干脆释放吧。这样的数据用 sessionStorage 来处理再合适不过。</p><h3 id="3、sessionStorage-、localStorage-和-cookie-之间的区别"><a href="#3、sessionStorage-、localStorage-和-cookie-之间的区别" class="headerlink" title="3、sessionStorage 、localStorage 和 cookie 之间的区别"></a>3、sessionStorage 、localStorage 和 cookie 之间的区别</h3><ul><li>共同点：都是保存在浏览器端，且都遵循同源策略。</li><li>不同点：在于生命周期与作用域的不同</li></ul><p>作用域：localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191023181403.png" alt=""></p><p>生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191023181420.png" alt=""></p><p>Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——<strong>它只能存储字符串</strong>，要想得到对象，我们还需要先对字符串进行一轮解析。对于对象存储</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (COMMENT_CACHE != <span class="hljs-string">''</span>) &#123;</span><br><span class="line">            <span class="hljs-comment">// 异常不影响结果，继续往下执行</span></span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                COMMENT = <span class="hljs-built_in">JSON</span>.parse(COMMENT_CACHE);</span><br><span class="line">                COMMENT_ARR = COMMENT[<span class="hljs-string">"data"</span>];</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (e) &#123;</span><br><span class="line">                COMMENT_CACHE = <span class="hljs-string">''</span>;</span><br><span class="line">                <span class="hljs-built_in">console</span>.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (COMMENT_ARR.length &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                localStorage.setItem(COMMENT_CACHE_KEY, <span class="hljs-built_in">JSON</span>.stringify(resultMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！</p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>ndexedDB 是一种低级API，<strong>用于客户端存储大量结构化数据(包括文件和blobs)</strong>。该API使用索引来实现对该数据的高性能搜索。IndexedDB 是一个运行在浏览器上的非关系型数据库。</p><p>既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。</p><h3 id="1、IndexedDB的特点"><a href="#1、IndexedDB的特点" class="headerlink" title="1、IndexedDB的特点"></a>1、IndexedDB的特点</h3><ul><li>键值对储存</li></ul><p>IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p><ul><li>异步</li></ul><p>IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p><ul><li>支持事务</li></ul><p>IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p><ul><li>同源限制</li></ul><p>IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p><ul><li>储存空间大</li></ul><p>IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p><ul><li>支持二进制储存</li></ul><p>IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p><h3 id="2、IndexedDB的常见操作"><a href="#2、IndexedDB的常见操作" class="headerlink" title="2、IndexedDB的常见操作"></a>2、IndexedDB的常见操作</h3><p>在IndexedDB大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求——响应的模式。</p><ul><li>建立打开IndexedDB——<code>window.indexedDB.open(&quot;testDB&quot;)</code></li></ul><p>这条指令并不会返回一个DB对象的句柄，我们得到的是一个<code>IDBOpenDBRequest</code>对象，而我们希望得到的DB对象在其result属性中。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191023181750.png" alt=""></p><p>除了result，IDBOpenDBRequest接口定义了几个重要属性：</p><ul><li>onerror: 请求失败的回调函数句柄；</li><li>onsuccess:请求成功的回调函数句柄；</li><li>onupgradeneeded:请求数据库版本变化句柄。</li></ul><p>如下使用：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">openDB</span>(<span class="hljs-params">name</span>)</span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> request=<span class="hljs-built_in">window</span>.indexedDB.open(name)<span class="hljs-comment">//建立打开IndexedDB</span></span><br><span class="line">  request.onerror=<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'open indexdb error'</span>)</span><br><span class="line">&#125;</span><br><span class="line">request.onsuccess=<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">  myDB.db=e.target.result<span class="hljs-comment">//这是一个 IDBDatabase对象，这就是IndexedDB对象</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(myDB.db)<span class="hljs-comment">//此处就可以获取到db实例</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> myDB=&#123;</span><br><span class="line">  name:<span class="hljs-string">'testDB'</span>,</span><br><span class="line">  version:<span class="hljs-string">'1'</span>,</span><br><span class="line">  db:<span class="hljs-literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">openDB(myDB.name)</span><br><span class="line">&lt;<span class="hljs-regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>控制台得到一个 IDBDatabase对象，这就是IndexedDB对象：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191023181829.png" alt=""></p><ul><li>关闭IndexedDB：</li></ul><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closeDB</span>(<span class="hljs-params">db</span>)</span>&#123;</span><br><span class="line">    db.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除IndexedDB：</li></ul><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteDB</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">  indexedDB.deleteDatabase(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单示例</p><h3 id="object-store"><a href="#object-store" class="headerlink" title="object store"></a>object store</h3><p>有了数据库后我们自然希望创建一个表用来存储数据，但indexedDB中没有表的概念，而是objectStore，一个数据库中可以包含多个objectStore，objectStore是一个灵活的数据结构，可以存放多种类型数据。也就是说一个objectStore相当于一张表，里面存储的每条数据和一个键相关联。</p><p>我们可以使用每条记录中的某个指定字段作为键值（keyPath），也可以使用自动生成的递增数字作为键值（keyGenerator），也可以不指定。选择键的类型不同，objectStore可以存储的数据结构也有差异</p><table><thead><tr><th>键类型</th><th>存储数据</th></tr></thead><tbody><tr><td>不使用</td><td>任意值，但是没添加一条数据的时候需要指定键参数</td></tr><tr><td>keyPath</td><td>Javascript对象，对象必须有一属性作为键值</td></tr><tr><td>keyGenerator</td><td>任意值</td></tr><tr><td>都使用</td><td>Javascript对象，如果对象中有keyPath指定的属性则不生成新的键值，如果没有自动生成递增键值，填充keyPath指定属性</td></tr></tbody></table><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 调用</span></span><br><span class="line"><span class="hljs-keyword">var</span> myDB=&#123;</span><br><span class="line">            name:<span class="hljs-string">'test'</span>,</span><br><span class="line">            version:<span class="hljs-number">3</span>,</span><br><span class="line">            db:<span class="hljs-literal">null</span></span><br><span class="line">        &#125;;</span><br><span class="line">        openDB(myDB.name,myDB.version);</span><br><span class="line">        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">            closeDB(myDB.db);</span><br><span class="line">            deleteDB(myDB.name);</span><br><span class="line">        &#125;,<span class="hljs-number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//给object store添加数据</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">openDB</span> (<span class="hljs-params">name,version</span>) </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> version=version || <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">var</span> request=<span class="hljs-built_in">window</span>.indexedDB.open(name,version);</span><br><span class="line">            request.onerror=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">                <span class="hljs-built_in">console</span>.log(e.currentTarget.error.message);</span><br><span class="line">            &#125;;</span><br><span class="line">            request.onsuccess=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">                myDB.db=e.target.result;</span><br><span class="line">            &#125;;</span><br><span class="line">            request.onupgradeneeded=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">                <span class="hljs-keyword">var</span> db=e.target.result;</span><br><span class="line">                <span class="hljs-keyword">if</span>(!db.objectStoreNames.contains(<span class="hljs-string">'students'</span>))&#123;</span><br><span class="line">                    db.createObjectStore(<span class="hljs-string">'students'</span>,&#123;<span class="hljs-attr">keyPath</span>:<span class="hljs-string">"id"</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'DB version changed to '</span>+version);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="hljs-comment">// 数据</span></span><br><span class="line"><span class="hljs-keyword">var</span> students=[&#123; </span><br><span class="line">            id:<span class="hljs-number">1001</span>, </span><br><span class="line">            name:<span class="hljs-string">"Byron"</span>, </span><br><span class="line">            age:<span class="hljs-number">24</span> </span><br><span class="line">        &#125;,&#123; </span><br><span class="line">            id:<span class="hljs-number">1002</span>, </span><br><span class="line">            name:<span class="hljs-string">"Frank"</span>, </span><br><span class="line">            age:<span class="hljs-number">30</span> </span><br><span class="line">        &#125;,&#123; </span><br><span class="line">            id:<span class="hljs-number">1003</span>, </span><br><span class="line">            name:<span class="hljs-string">"Aaron"</span>, </span><br><span class="line">            age:<span class="hljs-number">26</span> </span><br><span class="line">        &#125;];</span><br><span class="line"><span class="hljs-comment">// 添加</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addData</span>(<span class="hljs-params">db,storeName</span>)</span>&#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> transaction=db.transaction(storeName,<span class="hljs-string">'readwrite'</span>); </span><br><span class="line">            <span class="hljs-keyword">var</span> store=transaction.objectStore(storeName); </span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;students.length;i++)&#123;</span><br><span class="line">                store.add(students[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">openDB(myDB.name,myDB.version);</span><br><span class="line">        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">            addData(myDB.db,<span class="hljs-string">'students'</span>);</span><br><span class="line">        &#125;,<span class="hljs-number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// keyGenerate</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">openDB</span> (<span class="hljs-params">name,version</span>) </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> version=version || <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">var</span> request=<span class="hljs-built_in">window</span>.indexedDB.open(name,version);</span><br><span class="line">            request.onerror=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">                <span class="hljs-built_in">console</span>.log(e.currentTarget.error.message);</span><br><span class="line">            &#125;;</span><br><span class="line">            request.onsuccess=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">                myDB.db=e.target.result;</span><br><span class="line">            &#125;;</span><br><span class="line">            request.onupgradeneeded=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">                <span class="hljs-keyword">var</span> db=e.target.result;</span><br><span class="line">                <span class="hljs-keyword">if</span>(!db.objectStoreNames.contains(<span class="hljs-string">'students'</span>))&#123;</span><br><span class="line">                    db.createObjectStore(<span class="hljs-string">'students'</span>,&#123;<span class="hljs-attr">autoIncrement</span>: <span class="hljs-literal">true</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'DB version changed to '</span>+version);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 查找数据</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDataByKey</span>(<span class="hljs-params">db,storeName,value</span>)</span>&#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> transaction=db.transaction(storeName,<span class="hljs-string">'readwrite'</span>); </span><br><span class="line">            <span class="hljs-keyword">var</span> store=transaction.objectStore(storeName); </span><br><span class="line">            <span class="hljs-keyword">var</span> request=store.get(value); </span><br><span class="line">            request.onsuccess=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123; </span><br><span class="line">                <span class="hljs-keyword">var</span> student=e.target.result; </span><br><span class="line">                <span class="hljs-built_in">console</span>.log(student.name); </span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 更新数据</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateDataByKey</span>(<span class="hljs-params">db,storeName,value</span>)</span>&#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> transaction=db.transaction(storeName,<span class="hljs-string">'readwrite'</span>); </span><br><span class="line">            <span class="hljs-keyword">var</span> store=transaction.objectStore(storeName); </span><br><span class="line">            <span class="hljs-keyword">var</span> request=store.get(value); </span><br><span class="line">            request.onsuccess=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123; </span><br><span class="line">                <span class="hljs-keyword">var</span> student=e.target.result; </span><br><span class="line">                student.age=<span class="hljs-number">35</span>;</span><br><span class="line">                store.put(student); </span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//删除数据及object store 调用object store的delete方法根据键值删除记录</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteDataByKey</span>(<span class="hljs-params">db,storeName,value</span>)</span>&#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> transaction=db.transaction(storeName,<span class="hljs-string">'readwrite'</span>); </span><br><span class="line">            <span class="hljs-keyword">var</span> store=transaction.objectStore(storeName); </span><br><span class="line">            store.delete(value); </span><br><span class="line">        &#125;</span><br><span class="line"><span class="hljs-comment">// 调用object store的clear方法可以清空object store</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearObjectStore</span>(<span class="hljs-params">db,storeName</span>)</span>&#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> transaction=db.transaction(storeName,<span class="hljs-string">'readwrite'</span>); </span><br><span class="line">            <span class="hljs-keyword">var</span> store=transaction.objectStore(storeName); </span><br><span class="line">            store.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 调用数据库实例的deleteObjectStore方法可以删除一个object store，这个就得在onupgradeneeded里面调用了</span></span><br><span class="line"><span class="hljs-keyword">if</span>(db.objectStoreNames.contains(<span class="hljs-string">'students'</span>))&#123; </span><br><span class="line">                    db.deleteObjectStore(<span class="hljs-string">'students'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正是浏览器存储、缓存技术的出现和发展，为我们的前端应用带来了无限的转机。近年来基于存储、缓存技术的第三方库层出不绝，此外还衍生出了 PWA 这样优秀的 Web 应用模型。</p><p>总结下本文几个核心观点：</p><ul><li>Cookie 的本职工作并非本地存储，而是“维持状态”；</li><li>Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制，不与服务端发生通信；</li><li>IndexedDB 用于客户端存储大量结构化数据。</li></ul><p>参考文章:<br><a href="https://www.cnblogs.com/xuanbiyijue/p/8053970.html" target="_blank" rel="noopener">参考链接1</a><br><a href="https://mp.weixin.qq.com/s/st6oOlX4IZkJeeUZziilHg" target="_blank" rel="noopener">参考链接2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着移动网络的发展与演化，我们手机上现在除了有原生 App，还能跑“WebApp”——它即开即用，用完即走。一个优秀的 WebApp 甚至可以拥有和原生 App 媲美的功能和体验。&lt;br&gt;WebApp 优异的性能表现，有一部分原因要归功于浏览器存储技术的提升。cookie存储数据的功能已经很难满足开发所需，逐渐被WebStorage、IndexedDB所取代，本文将介绍这几种存储方式的差异和优缺点。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端技术" scheme="https://removeif.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端技术" scheme="https://removeif.github.io/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>用栈实现队列/用队列实现栈</title>
    <link href="https://removeif.github.io/2019/10/23/data-structure/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html"/>
    <id>https://removeif.github.io/2019/10/23/data-structure/用栈实现队列-用队列实现栈.html</id>
    <published>2019-10-23T10:30:03.000Z</published>
    <updated>2019-10-23T10:36:09.610Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>队列是一种<strong>先进先出</strong>的数据结构，栈是一种<strong>先进后出</strong>的数据结构。<br><a id="more"></a></p></blockquote><p>队列是一种<strong>先进先出</strong>的数据结构，栈是一种<strong>先进后出</strong>的数据结构，形象一点就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191023173025.png" alt=""></p><p>这两种数据结构底层其实都是数组或者链表实现的，只是 API 限定了它们的特性，那么今天就来看看如何使用「栈」的特性来实现一个「队列」，如何用「队列」实现一个「栈」。</p><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p>首先，队列的 API 如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/** 添加元素到队尾 */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/** 删除队头的元素并返回 */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/** 返回队头元素 */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/** 判断队列是否为空 */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用两个栈<code>s1, s2</code>就能实现一个队列的功能（这样放置栈可能更容易理解）：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191023173204.png" alt=""></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; s1, s2;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        s1 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s2 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用<code>push</code>让元素入队时，只要把元素压入<code>s1</code>即可，比如说<code>push</code>进 3 个元素分别是 1,2,3，那么底层结构就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191023173442.png" alt=""></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** 添加元素到队尾 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    s1.push(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果这时候使用<code>peek</code>查看队头的元素怎么办呢？按道理队头元素应该是 1，但是在<code>s1</code>中 1 被压在栈底，现在就要轮到<code>s2</code>起到一个中转的作用了：</p><p>当<code>s2</code>为空时，可以把<code>s1</code>的所有元素取出再添加进<code>s2</code>，这时候s2中元素就是先进先出顺序了。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191023173739.png" alt=""></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** 返回队头元素 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (s2.isEmpty())</span><br><span class="line">        <span class="hljs-comment">// 把 s1 元素压入 s2</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (!s1.isEmpty())</span><br><span class="line">            s2.push(s1.pop());</span><br><span class="line">    <span class="hljs-keyword">return</span> s2.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，对于<code>pop</code>操作，只要操作<code>s2</code>就可以了。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** 删除队头的元素并返回 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 先调用 peek 保证 s2 非空</span></span><br><span class="line">    peek();</span><br><span class="line">    <span class="hljs-keyword">return</span> s2.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，如何判断队列是否为空呢？如果两个栈都为空的话，就说明队列为空：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** 判断队列是否为空 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，就用栈结构实现了一个队列，核心思想是利用两个栈互相配合。</p><p>值得一提的是，这几个操作的时间复杂度是多少呢？其他操作都是 O(1)，有点意思的是<code>peek</code>操作，调用它时可能触发<code>while</code>循环，这样的话时间复杂度是 O(N)，但是大部分情况下<code>while</code>循环不会被触发，时间复杂度是 O(1)。由于<code>pop</code>操作调用了<code>peek</code>，它的时间复杂度和<code>peek</code>相同。</p><p>像这种情况，可以说它们的<strong>最坏时间复杂度</strong>是 O(N)，因为包含<code>while</code>循环，<strong>可能</strong>需要从<code>s1</code>往<code>s2</code>搬移元素。</p><p>但是它们的<strong>均摊时间复杂度</strong>是 O(1)，这个要这么理解：对于一个元素，最多只可能被搬运一次，也就是说<code>peek</code>操作平均到每个元素的时间复杂度是 O(1)。</p><h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><p>如果说双栈实现队列比较巧妙，那么用队列实现栈就比较简单粗暴了，只需要一个队列作为底层数据结构。首先看下栈的 API：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/** 添加元素到栈顶 */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/** 删除栈顶的元素并返回 */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/** 返回栈顶元素 */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/** 判断栈是否为空 */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先说<code>push</code>API，直接将元素加入队列，同时记录队尾元素，因为队尾元素相当于栈顶元素，如果要<code>top</code>查看栈顶元素的话可以直接返回：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="hljs-keyword">int</span> top_elem = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/** 添加元素到栈顶 */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// x 是队列的队尾，是栈的栈顶</span></span><br><span class="line">        q.offer(x);</span><br><span class="line">        top_elem = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/** 返回栈顶元素 */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> top_elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的底层数据结构是先进先出的队列，每次<code>pop</code><strong>只能从队头取元素</strong>；但是栈是后进先出，也就是说<code>pop</code>API 要从队尾取元素。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191023174741.png" alt=""></p><p>解决方法简单粗暴，把队列前面的都取出来再加入队尾，让之前的队尾元素排到队头，这样就可以取出了：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191023174812.png" alt=""></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** 删除栈顶的元素并返回 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> size = q.size();</span><br><span class="line">    <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">        q.offer(q.poll());</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 之前的队尾元素已经到了队头</span></span><br><span class="line">    <span class="hljs-keyword">return</span> q.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现还有一点小问题就是，原来的队尾元素被提到队头并删除了，但是<code>top_elem</code>变量没有更新，我们还需要一点小修改：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** 删除栈顶的元素并返回 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> size = q.size();</span><br><span class="line">    <span class="hljs-comment">// 留下队尾 2 个元素</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">2</span>) &#123;</span><br><span class="line">        q.offer(q.poll());</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 记录新的队尾元素</span></span><br><span class="line">    top_elem = q.peek();</span><br><span class="line">    q.offer(q.poll());</span><br><span class="line">    <span class="hljs-comment">// 删除之前的队尾元素</span></span><br><span class="line">    <span class="hljs-keyword">return</span> q.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，API<code>empty</code>就很容易实现了，只要看底层的队列是否为空即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** 判断栈是否为空 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> q.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，用队列实现栈的话，pop 操作时间复杂度是 O(N)，其他操作都是 O(1)。</p><p>个人认为，用队列实现栈没啥亮点，但是<strong>用双栈实现队列是值得学习的。</strong></p><p>出栈顺序本来就和入栈顺序相反，但是从栈<code>s1</code>搬运元素到<code>s2</code>之后，<code>s2</code>中元素出栈的顺序就变成了队列的先进先出顺序，这个特性有点类似「负负得正」，确实不容易想到。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191023175326.png" alt=""></p><p>参考文章:<br><a href="https://mp.weixin.qq.com/s/y8d1_5_PjcfZCshEBjn7RQ" target="_blank" rel="noopener">参考链接1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;队列是一种&lt;strong&gt;先进先出&lt;/strong&gt;的数据结构，栈是一种&lt;strong&gt;先进后出&lt;/strong&gt;的数据结构。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://removeif.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis的内存淘汰策略问题</title>
    <link href="https://removeif.github.io/2019/10/17/database/redis/Redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98.html"/>
    <id>https://removeif.github.io/2019/10/17/database/redis/Redis的内存淘汰策略问题.html</id>
    <published>2019-10-17T10:20:48.000Z</published>
    <updated>2019-10-17T10:26:15.884Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是基于内存的key-value数据库，因为系统的内存大小有限，所以我们在使用Redis的时候可以配置Redis能使用的最大的内存大小。<br><a id="more"></a></p><h3 id="Redis配置内存"><a href="#Redis配置内存" class="headerlink" title="Redis配置内存"></a>Redis配置内存</h3><h5 id="1、通过配置文件配置"><a href="#1、通过配置文件配置" class="headerlink" title="1、通过配置文件配置"></a>1、通过配置文件配置</h5><p>通过在Redis安装目录下面的redis.conf配置文件中添加以下配置设置内存大小</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//设置Redis最大占用内存大小为100M</span></span><br><span class="line">maxmemory </span><br><span class="line"><span class="hljs-number">100</span>mb</span><br></pre></td></tr></table></figure><p>redis的配置文件不一定使用的是安装目录下面的redis.conf文件，启动redis服务的时候是可以传一个参数指定redis的配置文件的</p><h5 id="2、通过命令修改"><a href="#2、通过命令修改" class="headerlink" title="2、通过命令修改"></a>2、通过命令修改</h5><p>Redis支持运行时通过命令动态修改内存大小</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//设置Redis最大占用内存大小为100M</span></span><br><span class="line"><span class="hljs-number">127.0</span>.0.1:<span class="hljs-number">6379</span>&gt; config set maxmemory <span class="hljs-number">100</span>mb</span><br><span class="line"><span class="hljs-comment">//获取设置的Redis能使用的最大内存大小</span></span><br><span class="line"><span class="hljs-number">127.0</span>.0.1:<span class="hljs-number">6379</span>&gt; config get maxmemory</span><br></pre></td></tr></table></figure><p>如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存</p><h3 id="Redis的内存淘汰"><a href="#Redis的内存淘汰" class="headerlink" title="Redis的内存淘汰"></a>Redis的内存淘汰</h3><p>既然可以设置Redis最大占用内存大小，那么配置的内存就有用完的时候。那在内存用完的时候，还继续往Redis里面添加数据不就没内存可用了吗？</p><p>实际上Redis定义了几种策略用来处理这种情况：</p><p><strong>noeviction(默认策略)</strong>：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</p><p><strong>allkeys-lru</strong>：从所有key中使用LRU算法进行淘汰</p><p><strong>volatile-lru</strong>：从设置了过期时间的key中使用LRU算法进行淘汰</p><p><strong>allkeys-random</strong>：从所有key中随机淘汰数据</p><p><strong>volatile-random</strong>：从设置了过期时间的key中随机淘汰</p><p><strong>volatile-ttl</strong>：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰</p><p>当使用<strong>volatile-lru</strong>、<strong>volatile-random</strong>、<strong>volatile-ttl</strong>这三种策略时，如果没有key可以被淘汰，则和<strong>noeviction</strong>一样返回错误</p><h5 id="如何获取及设置内存淘汰策略"><a href="#如何获取及设置内存淘汰策略" class="headerlink" title="如何获取及设置内存淘汰策略"></a>如何获取及设置内存淘汰策略</h5><p>获取当前内存淘汰策略：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br></pre></td></tr></table></figure><p>通过配置文件设置淘汰策略（修改redis.conf文件）：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><p>通过命令修改淘汰策略：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config <span class="hljs-built_in">set</span> maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h3><h5 id="什么是LRU"><a href="#什么是LRU" class="headerlink" title="什么是LRU?"></a>什么是LRU?</h5><p>上面说到了Redis可使用最大内存使用完了，是可以使用LRU算法进行内存淘汰的，那么什么是LRU算法呢？</p><p><strong>LRU(Least Recently Used)</strong>，即最近最少使用，是一种缓存置换算法。在使用内存作为缓存的时候，缓存的大小一般是固定的。当缓存被占满，这个时候继续往缓存里面添加数据，就需要淘汰一部分老的数据，释放内存空间用来存储新的数据。这个时候就可以使用LRU算法了。其核心思想是：如果一个数据在最近一段时间没有被用到，那么将来被使用到的可能性也很小，所以就可以被淘汰掉。</p><h5 id="使用java实现一个简单的LRU算法"><a href="#使用java实现一个简单的LRU算法" class="headerlink" title="使用java实现一个简单的LRU算法"></a>使用java实现一个简单的LRU算法</h5><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span>&lt;<span class="hljs-title">k</span>, <span class="hljs-title">v</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//容量</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;</span><br><span class="line">    <span class="hljs-comment">//当前有多少节点的统计</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;</span><br><span class="line">    <span class="hljs-comment">//缓存节点</span></span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;k, Node&lt;k, v&gt;&gt; nodeMap;</span><br><span class="line">    <span class="hljs-keyword">private</span> Node&lt;k, v&gt; head;</span><br><span class="line">    <span class="hljs-keyword">private</span> Node&lt;k, v&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.valueOf(capacity));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="hljs-keyword">this</span>.nodeMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="hljs-comment">//初始化头节点和尾节点，利用哨兵模式减少判断头结点和尾节点为空的代码</span></span><br><span class="line">        Node headNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);</span><br><span class="line">        Node tailNode = <span class="hljs-keyword">new</span> Node(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);</span><br><span class="line">        headNode.next = tailNode;</span><br><span class="line">        tailNode.pre = headNode;</span><br><span class="line">        <span class="hljs-keyword">this</span>.head = headNode;</span><br><span class="line">        <span class="hljs-keyword">this</span>.tail = tailNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(k key, v value)</span> </span>&#123;</span><br><span class="line">        Node&lt;k, v&gt; node = nodeMap.get(key);</span><br><span class="line">        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (count &gt;= capacity) &#123;</span><br><span class="line">                <span class="hljs-comment">//先移除一个节点</span></span><br><span class="line">                removeNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = <span class="hljs-keyword">new</span> Node&lt;&gt;(key, value);</span><br><span class="line">            <span class="hljs-comment">//添加节点</span></span><br><span class="line">            addNode(node);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">//移动节点到头节点</span></span><br><span class="line">            moveNodeToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;k, v&gt; <span class="hljs-title">get</span><span class="hljs-params">(k key)</span> </span>&#123;</span><br><span class="line">        Node&lt;k, v&gt; node = nodeMap.get(key);</span><br><span class="line">        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            moveNodeToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Node node = tail.pre;</span><br><span class="line">        <span class="hljs-comment">//从链表里面移除</span></span><br><span class="line">        removeFromList(node);</span><br><span class="line">        nodeMap.remove(node.key);</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeFromList</span><span class="hljs-params">(Node&lt;k, v&gt; node)</span> </span>&#123;</span><br><span class="line">        Node pre = node.pre;</span><br><span class="line">        Node next = node.next;</span><br><span class="line"></span><br><span class="line">        pre.next = next;</span><br><span class="line">        next.pre = pre;</span><br><span class="line"></span><br><span class="line">        node.next = <span class="hljs-keyword">null</span>;</span><br><span class="line">        node.pre = <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(Node&lt;k, v&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//添加节点到头部</span></span><br><span class="line">        addToHead(node);</span><br><span class="line">        nodeMap.put(node.key, node);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(Node&lt;k, v&gt; node)</span> </span>&#123;</span><br><span class="line">        Node next = head.next;</span><br><span class="line">        next.pre = node;</span><br><span class="line">        node.next = next;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveNodeToHead</span><span class="hljs-params">(Node&lt;k, v&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//从链表里面移除</span></span><br><span class="line">        removeFromList(node);</span><br><span class="line">        <span class="hljs-comment">//添加节点到头部</span></span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">k</span>, <span class="hljs-title">v</span>&gt; </span>&#123;</span><br><span class="line">        k key;</span><br><span class="line">        v value;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(k key, v value)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.key = key;</span><br><span class="line">            <span class="hljs-keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码实现了一个简单的LUR算法，代码很简单，也加了注释，仔细看一下很容易就看懂。</p><h3 id="LRU在Redis中的实现"><a href="#LRU在Redis中的实现" class="headerlink" title="LRU在Redis中的实现"></a>LRU在Redis中的实现</h3><h5 id="近似LRU算法"><a href="#近似LRU算法" class="headerlink" title="近似LRU算法"></a>近似LRU算法</h5><p>Redis使用的是近似LRU算法，它跟常规的LRU算法还不太一样。近似LRU算法通过随机采样法淘汰数据，每次随机出5（默认）个key，从里面淘汰掉最近最少使用的key。</p><p>可以通过maxmemory-samples参数修改采样数量：例：maxmemory-samples 10 maxmenory-samples配置的越大，淘汰的结果越接近于严格的LRU算法</p><p>Redis为了实现近似LRU算法，给每个key增加了一个额外增加了一个24bit的字段，用来存储该key最后一次被访问的时间。</p><h5 id="Redis3-0对近似LRU的优化"><a href="#Redis3-0对近似LRU的优化" class="headerlink" title="Redis3.0对近似LRU的优化"></a>Redis3.0对近似LRU的优化</h5><p>Redis3.0对近似LRU算法进行了一些优化。新算法会维护一个候选池（大小为16），池中的数据根据访问时间进行排序，第一次随机选取的key都会放入池中，随后每次随机选取的key只有在访问时间小于池中最小的时间才会放入池中，直到候选池被放满。当放满后，如果有新的key需要放入，则将池中最后访问时间最大（最近被访问）的移除。</p><p>当需要淘汰的时候，则直接从池中选取最近访问时间最小（最久没被访问）的key淘汰掉就行。</p><h5 id="LRU算法的对比"><a href="#LRU算法的对比" class="headerlink" title="LRU算法的对比"></a>LRU算法的对比</h5><p>我们可以通过一个实验对比各LRU算法的准确率，先往Redis里面添加一定数量的数据n，使Redis可用内存用完，再往Redis里面添加n/2的新数据，这个时候就需要淘汰掉一部分的数据，如果按照严格的LRU算法，应该淘汰掉的是最先加入的n/2的数据。生成如下各LRU算法的对比图</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191017174208.png" alt=""></p><p>你可以看到图中有三种不同颜色的点：</p><ul><li>浅灰色是被淘汰的数据</li><li>灰色是没有被淘汰掉的老数据</li><li>绿色是新加入的数据</li></ul><p>我们能看到Redis3.0采样数是10生成的图最接近于严格的LRU。而同样使用5个采样数，Redis3.0也要优于Redis2.8。</p><h5 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h5><p>LFU算法是Redis4.0里面新加的一种淘汰策略。它的全称是Least Frequently Used，它的核心思想是根据key的最近被访问的频率进行淘汰，很少被访问的优先被淘汰，被访问的多的则被留下来。<br>LFU算法能更好的表示一个key被访问的热度。假如你使用的是LRU算法，一个key很久没有被访问到，只刚刚是偶尔被访问了一次，那么它就被认为是热点数据，不会被淘汰，而有些key将来是很有可能被访问到的则被淘汰了。如果使用LFU算法则不会出现这种情况，因为使用一次并不会使一个key成为热点数据。<br>LFU一共有两种策略：</p><p>volatile-lfu：在设置了过期时间的key中使用LFU算法淘汰key<br>allkeys-lfu：在所有的key中使用LFU算法淘汰数据<br>设置使用这两种淘汰策略跟前面讲的一样，不过要注意的一点是这两周策略只能在Redis4.0及以上设置，如果在Redis4.0以下设置会报错</p><p>参考文章:<br><a href="https://www.cnblogs.com/johnnyblog/p/11479649.html" target="_blank" rel="noopener">参考链接1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis是基于内存的key-value数据库，因为系统的内存大小有限，所以我们在使用Redis的时候可以配置Redis能使用的最大的内存大小。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="redis" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
    
    
      <category term="redis" scheme="https://removeif.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>原码补码异或与位运算移位知识点</title>
    <link href="https://removeif.github.io/2019/10/17/java/basic/%E5%8E%9F%E7%A0%81%E8%A1%A5%E7%A0%81%E5%BC%82%E6%88%96%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97%E7%A7%BB%E4%BD%8D%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://removeif.github.io/2019/10/17/java/basic/原码补码异或与位运算移位知识点.html</id>
    <published>2019-10-17T10:20:09.000Z</published>
    <updated>2019-10-21T03:23:49.100Z</updated>
    
    <content type="html"><![CDATA[<p>异或，英文为exclusive OR，缩写成xor<br>异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号为“⊕”，计算机符号为“xor”。其运算法则为：<br>a⊕b = (¬a ∧ b) ∨ (a ∧¬b)<br>如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。<br>异或也叫半加运算，其运算法则相当于不带进位的二进制加法：二进制下用1表示真，0表示假，则异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1），这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。<br><a id="more"></a></p><h3 id="byte、bit"><a href="#byte、bit" class="headerlink" title="byte、bit"></a>byte、bit</h3><p>字节（Byte）/比特位（bit）<br><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">B是Byte的缩写，B就是Byte，也就是字节（Byte）；b是bit的缩写，b就是bit，也就是比特位（bit）。</span><br><span class="line">B与b不同，注意区分，KB是千字节，Kb是千比特位。</span><br><span class="line"></span><br><span class="line"><span class="hljs-number">1</span>MB（兆字节） = <span class="hljs-number">1024</span>KB（千字节）= <span class="hljs-number">1024</span>*<span class="hljs-number">1024B</span>(字节) = <span class="hljs-number">1048576B</span>(字节)；</span><br><span class="line"><span class="hljs-number">8b</span>it（比特位）= <span class="hljs-number">1B</span>yte（字节）；</span><br><span class="line"><span class="hljs-number">1024B</span>yte（字节）= <span class="hljs-number">1</span>KB(千字节)；</span><br><span class="line"><span class="hljs-number">1024</span>KB（千字节）= <span class="hljs-number">1</span>MB（兆字节）;</span><br><span class="line"><span class="hljs-number">1024</span>MB = <span class="hljs-number">1</span>GB;</span><br><span class="line"><span class="hljs-number">1024</span>GB = <span class="hljs-number">1</span>TB;</span><br></pre></td></tr></table></figure></p><h3 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h3><p>其实数据存储在内存中都是存储的二进制，二进制又可分为原码、反码、补码。最终存储在内存中的是“补码”。</p><p>一个正数的原码、反码、补码都是它的二进制表现形式。(无符号数没有原码、反码和补码一说。只有带符号数才存在不同的编码方式。)</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如：<span class="hljs-number">9</span> == <span class="hljs-keyword">int</span> == <span class="hljs-number">4</span>个字节 == <span class="hljs-number">1</span>个字节等于<span class="hljs-number">8</span>位 == 整形有<span class="hljs-number">32</span>位</span><br><span class="line">正数的原码：</span><br><span class="line"><span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">1001</span></span><br><span class="line">正数的反码就是正数的原码：</span><br><span class="line"><span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">1001</span></span><br><span class="line">正数的补码也是整数的原码：</span><br><span class="line"><span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">1001</span></span><br></pre></td></tr></table></figure><p>二进制的第一位是符号位，0代表整数，1代表负数。</p><p>一个负数的原码是首位为1的二进制数。反码是符号位不变，其他位取反。补码是反码加1。</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如：<span class="hljs-number">-9</span></span><br><span class="line">原码为首位为<span class="hljs-number">1</span>的二进制数：</span><br><span class="line"><span class="hljs-number">1000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">1001</span></span><br><span class="line">反码为符号位不变，其他位取反：</span><br><span class="line"><span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">0110</span></span><br><span class="line">补码是反码加<span class="hljs-number">1</span>：</span><br><span class="line"><span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> <span class="hljs-number">0111</span></span><br></pre></td></tr></table></figure><h4 id="为什么会有原码反码补码？"><a href="#为什么会有原码反码补码？" class="headerlink" title="为什么会有原码反码补码？"></a>为什么会有原码反码补码？</h4><ol><li>由于最高位是符号位，如果是0就代表正数，1就代表是负数。</li><li>那么直接存储原码，计算机在计算的时候还需要先判断最高位才能计算，效率比较低</li><li>为了方便计算机计算，所以有了反码和补码，然后计算机就不需要判断符号位了，只做加法运算就可以了。</li></ol><p>计算十进制的表达式：1 - 1 = 0</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">1</span> - <span class="hljs-number">1</span> == <span class="hljs-number">1</span> + (<span class="hljs-number">-1</span>)</span><br><span class="line"> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span>(原码)</span><br><span class="line">+<span class="hljs-number">1000</span> <span class="hljs-number">0001</span>(原码)</span><br><span class="line">----------------</span><br><span class="line"> <span class="hljs-number">1000</span> <span class="hljs-number">0010</span>(原码) == <span class="hljs-number">-2</span></span><br></pre></td></tr></table></figure><p>如果用原码表示，让符号位参与计算，显然对于减法来说是不正确的。这也是计算机内部不以原码表示的原因。</p><ul><li>为了解决原码做减法的问题，出现了反码：</li></ul><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">1</span> - <span class="hljs-number">1</span> == <span class="hljs-number">1</span> + (<span class="hljs-number">-1</span>)</span><br><span class="line"> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span>(反码)</span><br><span class="line">+<span class="hljs-number">1111</span> <span class="hljs-number">1110</span>(反码)</span><br><span class="line">----------------</span><br><span class="line"> <span class="hljs-number">1111</span> <span class="hljs-number">1111</span>(反码) 转成原码 -&gt; <span class="hljs-number">1000</span> <span class="hljs-number">0000</span> == <span class="hljs-number">-0</span></span><br></pre></td></tr></table></figure><p>通常我们用最高的有效位来表示数的符号（当用8位来表示一个整数时，第8位即为最高有效位，当用16位来表示一个整数时，第16位即为最高有效位。）0表示正号、1表示负号，这种正负号数字化的机内表示形式就称为“机器数”，而相应的机器外部用正负号表示的数称为“真值”。将一个真值表示成二进制字串的机器数的过程就称为编码。</p><ul><li>于是补码出现了，解决了0的符号问题以及两个编码的问题，0的编码就只有+0，-0已经等于-128了。</li></ul><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">1</span> - <span class="hljs-number">1</span> == <span class="hljs-number">1</span> + (<span class="hljs-number">-1</span>)</span><br><span class="line"> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span>(补码)</span><br><span class="line">+<span class="hljs-number">1111</span> <span class="hljs-number">1111</span>(补码)</span><br><span class="line">----------------</span><br><span class="line"><span class="hljs-number">10000</span> <span class="hljs-number">0000</span>(补码) </span><br><span class="line">第一位溢出后转成原码 -&gt; <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> == <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure><h3 id="与、或、异或运算"><a href="#与、或、异或运算" class="headerlink" title="与、或、异或运算"></a>与、或、异或运算</h3><h4 id="1-与运算（-amp-）"><a href="#1-与运算（-amp-）" class="headerlink" title="1.与运算（&amp;）"></a>1.与运算（&amp;）</h4><p>参加运算的两个数据，按二进制位进行“与”运算。</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">运算规则：<span class="hljs-number">0</span>&amp;<span class="hljs-number">0</span>=<span class="hljs-number">0</span>;   <span class="hljs-number">0</span>&amp;<span class="hljs-number">1</span>=<span class="hljs-number">0</span>;    <span class="hljs-number">1</span>&amp;<span class="hljs-number">0</span>=<span class="hljs-number">0</span>;     <span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>=<span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">   即：两位同时为“<span class="hljs-number">1</span>”，结果才为“<span class="hljs-number">1</span>”，否则为<span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line">例如：<span class="hljs-number">3</span>&amp;<span class="hljs-number">5</span>  即 <span class="hljs-number">0000</span> <span class="hljs-number">0011</span> &amp; <span class="hljs-number">0000</span> <span class="hljs-number">0101</span> = <span class="hljs-number">0000</span> <span class="hljs-number">0001</span>   因此，<span class="hljs-number">3</span>&amp;<span class="hljs-number">5</span>的值得<span class="hljs-number">1</span>。</span><br><span class="line"></span><br><span class="line">例如：<span class="hljs-number">9</span>&amp;<span class="hljs-number">5</span>  即 <span class="hljs-number">0000</span> <span class="hljs-number">1001</span> (<span class="hljs-number">9</span>的二进制补码)&amp;<span class="hljs-number">00000101</span> (<span class="hljs-number">5</span>的二进制补码) =<span class="hljs-number">00000001</span> (<span class="hljs-number">1</span>的二进制补码)可见<span class="hljs-number">9</span>&amp;<span class="hljs-number">5</span>=<span class="hljs-number">1</span>。</span><br></pre></td></tr></table></figure><h4 id="2-或运算（-）"><a href="#2-或运算（-）" class="headerlink" title="2.或运算（|）"></a>2.或运算（|）</h4><p>参加运算的两个对象，按二进制位进行“或”运算。</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运算规则：<span class="hljs-number">0</span>|<span class="hljs-number">0</span>=<span class="hljs-number">0</span>；   <span class="hljs-number">0</span>|<span class="hljs-number">1</span>=<span class="hljs-number">1</span>；   <span class="hljs-number">1</span>|<span class="hljs-number">0</span>=<span class="hljs-number">1</span>；    <span class="hljs-number">1</span>|<span class="hljs-number">1</span>=<span class="hljs-number">1</span>；</span><br><span class="line">即 ：参加运算的两个对象只要有一个为<span class="hljs-number">1</span>，其值为<span class="hljs-number">1</span>。</span><br><span class="line">例如:<span class="hljs-number">3</span>|<span class="hljs-number">5</span>　即 <span class="hljs-number">0000</span> <span class="hljs-number">0011</span> | <span class="hljs-number">0000</span> <span class="hljs-number">0101</span> = <span class="hljs-number">0000</span> <span class="hljs-number">0111</span>   因此，<span class="hljs-number">3</span>|<span class="hljs-number">5</span>的值得<span class="hljs-number">7</span>。　</span><br><span class="line"></span><br><span class="line">例如：<span class="hljs-number">9</span>|<span class="hljs-number">5</span>可写算式如下： <span class="hljs-number">00001001</span>|<span class="hljs-number">00000101</span> =<span class="hljs-number">00001101</span> (十进制为<span class="hljs-number">13</span>)可见<span class="hljs-number">9</span>|<span class="hljs-number">5</span>=<span class="hljs-number">13</span></span><br></pre></td></tr></table></figure><h4 id="3-异或运算（-）"><a href="#3-异或运算（-）" class="headerlink" title="3.异或运算（^）"></a>3.异或运算（^）</h4><p>参加运算的两个数据，按二进制位进行“异或”运算。</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运算规则：<span class="hljs-number">0</span>^<span class="hljs-number">0</span>=<span class="hljs-number">0</span>；   <span class="hljs-number">0</span>^<span class="hljs-number">1</span>=<span class="hljs-number">1</span>；   <span class="hljs-number">1</span>^<span class="hljs-number">0</span>=<span class="hljs-number">1</span>；   <span class="hljs-number">1</span>^<span class="hljs-number">1</span>=<span class="hljs-number">0</span>；</span><br></pre></td></tr></table></figure><p>即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：<span class="hljs-number">9</span>^<span class="hljs-number">5</span>可写成算式如下： <span class="hljs-number">00001001</span>^<span class="hljs-number">00000101</span>=<span class="hljs-number">00001100</span> (十进制为<span class="hljs-number">12</span>)可见<span class="hljs-number">9</span>^<span class="hljs-number">5</span>=<span class="hljs-number">12</span></span><br></pre></td></tr></table></figure><h3 id="位、移位运算"><a href="#位、移位运算" class="headerlink" title="位、移位运算"></a>位、移位运算</h3><p>一个字节数占 <code>8</code> 位，将 <code>a</code>，<code>b</code> 转换为二进制：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="hljs-number">0000</span> <span class="hljs-number">1111</span></span><br><span class="line">b = <span class="hljs-number">1111</span> <span class="hljs-number">0001</span></span><br></pre></td></tr></table></figure><p><strong>Note</strong>：计算机使用补码表示</p><p>位与运算符：仅当两个操作数同一下标的值均为 1 时，结果才为 1</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &amp; b = <span class="hljs-number">0000</span> <span class="hljs-number">1111</span> &amp; <span class="hljs-number">1111</span> <span class="hljs-number">0001</span> = <span class="hljs-number">0000</span> <span class="hljs-number">0001</span>(补) = <span class="hljs-number">0000</span> <span class="hljs-number">0001</span>(原) = <span class="hljs-number">1</span></span><br></pre></td></tr></table></figure><p>位或运算符：只要两个操作数同一下标的值有一个为 1 时，结果就为 1</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a | b = <span class="hljs-number">0000</span> <span class="hljs-number">1111</span> &amp; <span class="hljs-number">1111</span> <span class="hljs-number">0001</span> = <span class="hljs-number">1111</span> <span class="hljs-number">1111</span>(补) = <span class="hljs-number">1000</span> <span class="hljs-number">0001</span>(原) = <span class="hljs-number">-1</span></span><br></pre></td></tr></table></figure><p>位异或运算符：只有两个操作数同意下标的值不相等时，结果才为 1</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a ^ b = <span class="hljs-number">0000</span> <span class="hljs-number">1111</span> ^ <span class="hljs-number">1111</span> <span class="hljs-number">0001</span> = <span class="hljs-number">1111</span> <span class="hljs-number">1110</span>(补) = <span class="hljs-number">1000</span> <span class="hljs-number">0010</span>(原) = <span class="hljs-number">-2</span></span><br></pre></td></tr></table></figure><p>位取反运算符：按位取反每一位</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~a = ~<span class="hljs-number">0000</span> <span class="hljs-number">1111</span> = <span class="hljs-number">1111</span> <span class="hljs-number">0000</span>(补) = <span class="hljs-number">1001</span> <span class="hljs-number">0000</span>(原) = <span class="hljs-number">-16</span></span><br><span class="line">~b = ~<span class="hljs-number">1111</span> <span class="hljs-number">0001</span> = <span class="hljs-number">0000</span> <span class="hljs-number">1110</span>(补) = <span class="hljs-number">0000</span> <span class="hljs-number">1110</span>(原) = <span class="hljs-number">14</span></span><br></pre></td></tr></table></figure><p><strong>Note 1</strong>：byte 或者 short 类型数值进行位运算后，返回的是 int 类型数值（没有找到资料说明在位运算之前是否已经进行了转换，不过先将 a，b 转换为 int 类型二进制再进行计算的结果和上面一致）</p><p><strong>Note 2</strong>：位运算符的操作不排除符号位</p><h4 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h4><p>Java 提供了 3 种移位运算符</p><ul><li>左移运算符（left shift operator）：&lt;&lt;</li><li>右移运算符（right shift operator）：&gt;&gt;</li><li>无符号右移运算符（unsigned right shift operator）：&gt;&gt;&gt;</li></ul><p>对于移位运算符而言，左侧操作数表示要移动的二进制数，右侧操作数表示要移动的位数</p><p>进行移位操作时，需要注意以下几点：</p><p>对于 byte 或者 short 类型数值，进行移位操作时，会先转换为 int 类型，然后进行移位（如果是 long 类型，则不变）</p><p>对于右侧操作数而言，在进行移位之前，先转换为二进制数（补码）。如果左侧数是 int 类型，则取右侧操作数最右端 5 位数值进行移动；如果是 long 类型数值，则取右侧操作数最右端 6 位数值进行移动</p><h4 id="左移运算符：数值位向左移动指定位数"><a href="#左移运算符：数值位向左移动指定位数" class="headerlink" title="左移运算符：数值位向左移动指定位数"></a>左移运算符：数值位向左移动指定位数</h4><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">15</span> &lt;&lt; <span class="hljs-number">3</span> = <span class="hljs-number">0x0000000f</span> &lt;&lt; <span class="hljs-number">3</span> = <span class="hljs-number">0x00000078</span>(补，原) = <span class="hljs-number">120</span></span><br><span class="line"><span class="hljs-number">15</span> &lt;&lt; <span class="hljs-number">-61</span> = <span class="hljs-number">0x0000000f</span> &lt;&lt; <span class="hljs-number">0xffffffc3</span>(左侧是 <span class="hljs-keyword">int</span> 类型，取右侧 <span class="hljs-number">5</span> 位) = <span class="hljs-number">0x0000000f</span> &lt;&lt; <span class="hljs-number">3</span> = <span class="hljs-number">0x00000078</span>(补，原) = <span class="hljs-number">120</span></span><br><span class="line"><span class="hljs-number">15</span> &lt;&lt; <span class="hljs-number">35</span> = <span class="hljs-number">0x0000000f</span> &lt;&lt; <span class="hljs-number">0x00000023</span>(左侧是 <span class="hljs-keyword">int</span> 类型，取右侧 <span class="hljs-number">5</span> 位) = <span class="hljs-number">0x0000000f</span> &lt;&lt; <span class="hljs-number">3</span> = <span class="hljs-number">0x00000078</span>(补，原) = <span class="hljs-number">120</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-number">-15</span> &lt;&lt; <span class="hljs-number">3</span> = <span class="hljs-number">0xfffffff1</span> &lt;&lt; <span class="hljs-number">3</span> = <span class="hljs-number">0xffffff88</span>(补) = <span class="hljs-number">0x80000078</span>(原） = <span class="hljs-number">-120</span></span><br><span class="line"><span class="hljs-number">-15</span> &lt;&lt; <span class="hljs-number">-61</span> = <span class="hljs-number">0xfffffff1</span> &lt;&lt; <span class="hljs-number">0xffffffc3</span>(左侧是 <span class="hljs-keyword">int</span> 类型，取右侧 <span class="hljs-number">5</span> 位) = <span class="hljs-number">0xfffffff1</span> &lt;&lt; <span class="hljs-number">3</span> = <span class="hljs-number">0xffffff88</span>(补) = <span class="hljs-number">0x80000078</span>(原） = <span class="hljs-number">-120</span></span><br><span class="line"><span class="hljs-number">-15</span> &lt;&lt; <span class="hljs-number">35</span> = <span class="hljs-number">0xfffffff1</span> &lt;&lt; <span class="hljs-number">0x00000023</span>(左侧是 <span class="hljs-keyword">int</span> 类型，取右侧 <span class="hljs-number">5</span> 位) = <span class="hljs-number">0xfffffff1</span> &lt;&lt; <span class="hljs-number">3</span> = <span class="hljs-number">0xffffff88</span>(补) = <span class="hljs-number">0x80000078</span>(原） = <span class="hljs-number">-120</span></span><br></pre></td></tr></table></figure><h4 id="右移运算符：数字位向右移动指定位数（如果左操作数是正数，高位补-0-；如果是负数，高位补-1）"><a href="#右移运算符：数字位向右移动指定位数（如果左操作数是正数，高位补-0-；如果是负数，高位补-1）" class="headerlink" title="右移运算符：数字位向右移动指定位数（如果左操作数是正数，高位补 0 ；如果是负数，高位补 1）"></a>右移运算符：数字位向右移动指定位数（如果左操作数是正数，高位补 0 ；如果是负数，高位补 1）</h4><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">15</span> &gt;&gt; <span class="hljs-number">3</span> = <span class="hljs-number">0x0000000f</span> &gt;&gt; <span class="hljs-number">3</span> = <span class="hljs-number">0x00000001</span> = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-number">-15</span> &gt;&gt; <span class="hljs-number">3</span> = <span class="hljs-number">0xfffffff1</span> &gt;&gt; <span class="hljs-number">3</span> = <span class="hljs-number">0xfffffffe</span>(补) = <span class="hljs-number">0x80000002</span>(原) = <span class="hljs-number">-2</span></span><br></pre></td></tr></table></figure><h4 id="无符号右移运算符：功能和右移运算符一样，不过无论正负，高位均补-0"><a href="#无符号右移运算符：功能和右移运算符一样，不过无论正负，高位均补-0" class="headerlink" title="无符号右移运算符：功能和右移运算符一样，不过无论正负，高位均补 0"></a>无符号右移运算符：功能和右移运算符一样，不过无论正负，高位均补 0</h4><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">15</span> &gt;&gt;&gt; <span class="hljs-number">3</span> = <span class="hljs-number">0x0000000f</span> &gt;&gt;&gt; <span class="hljs-number">3</span> = <span class="hljs-number">0x00000001</span> = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-number">-15</span> &gt;&gt; <span class="hljs-number">3</span> = <span class="hljs-number">0xfffffff1</span> &gt;&gt;&gt; <span class="hljs-number">3</span> = <span class="hljs-number">0x1ffffffe</span>(补，原) = <span class="hljs-number">2</span>^<span class="hljs-number">29</span> - <span class="hljs-number">2</span> = <span class="hljs-number">536870910</span></span><br></pre></td></tr></table></figure><p><strong>Note 1</strong>：移位运算时，从符号位开始操作</p><p><strong>Note 2</strong>：由结果可知，左移一位相当于乘以2，右移一位相当于除以 2</p><p>参考文章:<br><a href="https://blog.csdn.net/u012005313/article/details/78543809" target="_blank" rel="noopener">参考链接1</a><br><a href="https://www.jianshu.com/p/3fc8fde344dd" target="_blank" rel="noopener">参考链接2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异或，英文为exclusive OR，缩写成xor&lt;br&gt;异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号为“⊕”，计算机符号为“xor”。其运算法则为：&lt;br&gt;a⊕b = (¬a ∧ b) ∨ (a ∧¬b)&lt;br&gt;如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。&lt;br&gt;异或也叫半加运算，其运算法则相当于不带进位的二进制加法：二进制下用1表示真，0表示假，则异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1），这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://removeif.github.io/categories/java/"/>
    
      <category term="java基础" scheme="https://removeif.github.io/categories/java/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://removeif.github.io/tags/java/"/>
    
      <category term="科普" scheme="https://removeif.github.io/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>2019年国庆70周年阅兵完整图文解说(收藏!)</title>
    <link href="https://removeif.github.io/2019/10/13/2019%E5%B9%B4%E5%9B%BD%E5%BA%8670%E5%91%A8%E5%B9%B4%E9%98%85%E5%85%B5%E5%AE%8C%E6%95%B4%E5%9B%BE%E6%96%87%E8%A7%A3%E8%AF%B4.html"/>
    <id>https://removeif.github.io/2019/10/13/2019年国庆70周年阅兵完整图文解说.html</id>
    <published>2019-10-13T11:34:24.000Z</published>
    <updated>2019-11-07T05:31:41.138Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>问：你在哪个瞬间觉得中国很强大？<br>答：就是现在！<br>开国大典的时候飞机不够，您说飞两遍，现在再也不需要飞两遍了，要多少有多少。<br>这盛世，如你所愿吧，山河犹在，国泰民安。当年送你的十里长安街，如今已是十里繁荣！<br><a id="more"></a></p></blockquote><p><em>多图预警，加载较慢，好事多磨，请耐心等待!!!</em></p><h4 id="阅兵解说"><a href="#阅兵解说" class="headerlink" title="阅兵解说"></a>阅兵解说</h4><p><strong>海霞：</strong>今天是你的生日，我的中国。在这个不同寻常的节日，相信每一位中华儿女都会从心底里说一句，我爱你，中国。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013165456.png" alt=""></p><p><strong>康辉：</strong>70年风雨兼程，天安门广场上的红飘带寓意着红色基因连接历史，现实与未来。<br><strong>海霞：</strong>今天的天安门广场是世界瞩目的中心，今天的中国正前所未有的靠近世界舞台中心。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013165820.png" alt=""><br><strong>康辉：</strong>长安街上，人民军队精神抖擞，这支曾经穿草鞋，拿梭镖走上征途的队伍，现在已经拥有了自己的航母和新一代隐身战机，正阔步迈向世界一流军队。此时此刻，4名上将，2名中将，100多名少将，近15000名官兵列队完毕，等待接受统帅的检阅，接受祖国和人民的检阅。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013170124.png" alt=""><br><strong>海霞：</strong>长安街两侧身穿节日盛装的10万游行群众已集结完毕，一个多小时后，他们将组成一个个方阵，从天安门前通过，向全世界展示自由生动，欢愉活泼。70年前中国人的平均预期寿命只有三十五岁，七十年后的今天已经达到七十七岁，七十年来不断创造奇迹的中国让世界刮目相看。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013170428.png" alt=""><br><strong>康辉：</strong>新中国用短短几十年的时间走过了西方发达国家几百年的工业化历程，70年前的中国满目疮痍积贫积弱，今天中国已经成为世界第二大经济体，是全球经济发展的第一引擎。</p><p><strong>海霞：</strong>长安街始建于明代，寓意长治久安，回望长安大街，它记载着一个国家的兴衰和曾经有过的悲伤挣扎，奋斗喜悦，也记载着我们浴血奋战得解放，披荆斩棘成大道，砥砺奋进新时代的伟大征程。今天走在中国特色社会主义道路上我们无比自豪，无比自信。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013170703.png" alt=""></p><p><strong>康辉：</strong>黄河长江的浪，长城内外的风，起起伏伏，多少仁人志士上下求索。<br><strong>海霞：</strong>革命先行者孙中山，凝视着天安门广场，他曾经奋力让黑暗的中国走向黎明。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013170852.png" alt=""><br><strong>康辉：</strong>开国领袖毛泽东注视着天安门广场，他让沉睡的东方雄狮昂起了头颅。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013171025.png" alt=""><br><strong>海霞：</strong>1949年一唱雄鸡天下白,中国迈进新纪元。<br><strong>康辉：</strong>此时此刻，地域不同，口音不同的人们汇聚在这里，有56个民族的兄弟姐妹，有港澳台同胞和海外侨胞，有关心和支持中国发展的外国友人，我们将共同见证历史。<br><strong>康辉：</strong>中央广播电视总台。<br><strong>海霞：</strong>中央广播电视总台。<br><strong>康辉：</strong>这里是中华人民共和国首都北京。<br><strong>海霞：</strong>我们在这里向全球直播，庆祝中华人民共和国成立70周年大会。<br><strong>康辉：</strong>一个必将载入史册的国家盛典即将开始。<br><strong>康辉：</strong>习近平，李克强，栗战书，汪洋，王沪宁，赵乐际，韩正，王岐山等党和国家领导人来到了天安门城楼，江泽民，胡锦涛同志来到了天安门城楼。他们和全国亿万人民一起庆祝中华人民共和国70华诞。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013171324.png" alt=""><br><strong>海霞：</strong>今天在天安门城楼参加庆典的，还有中共中央、全国人大常委会、国务院、全国政协、中央军委的领导同志和部分老同志代表，国家勋章、国家荣誉称号获得者代表等。<br><strong>康辉：</strong>来自全国各条战线的英雄模范人物，各界各族代表，香港、澳门、台湾同胞和海外侨胞代表以及在京重要外宾，各国驻华使节，外国专家等到现场观礼。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013171534.png" alt=""><br><strong>康辉：</strong>五十六门礼炮，70响轰鸣，仿佛历史跃动的脉搏诉说着五十六个民族的中华儿女七十载春华秋实的拼博。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013171840.png" alt=""><br><strong>海霞：</strong>隆隆炮声如冲锋的战士前赴后继，如燃烧的火炬薪火相传，我们的共和国就这样筚路蓝缕一路走来。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013172112.png" alt=""><br><strong>康辉：</strong>正步铿锵堂堂气，寒光闪耀凛凛威。<br><strong>海霞：</strong>从人民英雄纪念碑到五星红旗升起，短短几百步距离，浓缩着革命先烈奋斗的历程，无数苦苦求索奋勇牺牲的先辈凝望着我们，踩下一个个坚实的脚印。<br><strong>康辉：</strong>一切向前走都不能忘记走过的路，走的再远，走到再光辉的未来，也不能忘记为什么出发。<br><strong>海霞：</strong>一个崭新的时代，从我们手中诞生，民族复兴的梦想，正由我们去实现。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013172252.png" alt=""></p><p><strong>康辉：</strong>古老的中国、年轻的中国、充满希望的中国；遥远的世界、连通的世界、命运与共的世界，将共同见证我们这一代人的新长征。<br><strong>海霞：</strong>义勇军进行曲，这不屈的旋律,必胜的强音，即将再次唱响，让我们心跳随他跃动，让我们的脚步随他前进，前进，前进进!<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013172502.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013172741.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013172856.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013173015.png" alt=""></p><p><strong>康辉：</strong>标兵，是阅兵场上标定位置界线的军人，60名标兵以标准的正步，走向指定位置。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013173123.png" alt=""><br><strong>海霞：</strong>脚踏着祖国大地。人民军队牢记宗旨，担当使命，用忠诚用热血，为国家富强，民族振兴，人民幸福，建立了不朽功勋。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013173247.png" alt=""><br><strong>康辉：</strong>与祖国共奋进，人民军队由单一军种的军队发展成为诸军兵种联合基本实现机械化，加快迈向信息化的强大军队。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013173524.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013173436.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013173700.png" alt=""><br><strong>海霞：</strong>这次国庆阅兵增设了一个庄严的仪式，习近平主席将在党旗、国旗和军旗前，向三面光辉的旗帜行注目礼。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013173818.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013174415.png" alt=""><br><strong>康辉：</strong>这次阅兵，是中国特色现代军事力量体系建设成果的充分展示，集中体现、信息主导、体系支撑、精兵作战、联合制胜的特点。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013174604.png" alt=""><br><strong>海霞：</strong>这是中国特色社会主义进入新时代的首次国庆阅兵。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013174750.png" alt=""><br><strong>康辉：</strong>这是共和国武装力量改革重塑后的首次整体亮相。<br><strong>海霞：</strong>现在，习近平主席乘坐的检阅车已经从折返点返回。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013174918.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013175028.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013175217.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013175344.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013175441.png" alt=""><br><strong>康辉：</strong>建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队，这是党的重托，也是人民的期盼。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013175559.png" alt=""><br><strong>海霞：</strong>整齐的方阵，展现了共和国钢铁长城的时代风貌；铿锵的誓言，传递了全军将士对统帅的信赖、拥戴。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013175833.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013175905.png" alt=""><br><strong>康辉：</strong>关山飞渡的新征程，离不开登高望远的领路人。坚持以习近平新时代中国特色社会主义思想为指导，深入贯彻习近平强军思想，增强四个意识，坚定四个自信，做到两个维护，贯彻军委主席负责制，全军官兵思想上高度自觉，政治上高度自觉，行动上高度自觉。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013180021.png" alt=""></p><p><strong>海霞：</strong>为巩固中国共产党领导，和社会主义制度提供战略支撑，为捍卫国家主权统一领土完整提供战略支撑。为维护国家海外利益提供战略支撑。为促进世界和平与发展，提供战略支撑。人民军队，重任在肩，奋勇向前。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013180248.png" alt=""><br><strong>康辉：</strong>刚刚接受了统帅检阅的徒步方队，现在已经调整完队形，驾驶车辆和操作装备的官兵，也已经进入自己的战斗岗位。<br><strong>康辉：</strong>空中梯队的战机已经陆续起飞，一会儿，他们将飞越天安门广场，接受检阅。<br><strong>康辉：</strong>分列式即将开始，47个地面方队，12个空中梯队，将从天安门前豪迈地通过。<br><strong>海霞：</strong>强国，必须强军，军强才能国安。党的十八大以来，党中央、中央军委和习主席领导人民军队，以党在新时代的强军目标为引领，贯彻新时代军事战略方针，政治建军，铸就忠诚，改革强军体系重塑，科技兴军跨越发展，依法治军严明纲纪，练兵备战锻造胜战之师，面向未来，塑造世界一流军队，人民军队体质一心、节奏一心、格局一心、面貌一心、中国特色强军之路，越走越宽广。</p><p><strong>康辉：</strong>旗帜引领方向，旗帜凝聚力量。空中护旗梯队，破空而来，拉开了分列式的序幕。<br><strong>海霞：</strong>20架直升机汇成巨大70字样，象征着中华人民共和国走过的70年光辉历程。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013180358.png" alt=""><br><strong>康辉：</strong>回望历史，放眼世界，今天的中国，比历史上任何时期都更接近中华民族伟大复兴的目标，比历史上任何时期，都更需要建设一支强大的人民军队。<br><strong>海霞：</strong>正在走来的15个地面徒步方队，来自战略战役联合作战指挥机构，诸军兵种部队，院校科研单位等。这种组合方式，体现了解放军、武警部队、民兵三结合的武装力量体制。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013180715.png" alt=""><br><strong>康辉：</strong>鲜红的旗帜迎风招展，中国人民解放军仪仗方队，高擎党旗、国旗、军旗阔步走来。人民军队永远是中国共产党领导下的军队，永远是国家的捍卫者，永远是社会主义的捍卫者，永远是人民利益的捍卫者。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013180930.png" alt=""><br><strong>海霞：</strong>紧随三面旗帜，领导指挥方队接受检阅，领队是姜国平少将、陈作松少将。27位将军和325位校尉军官，来自军委机关、五大战区、各军兵种和武警部队，展现了我军领导指挥体制改革后的崭新面貌，体现了练兵先练将。<br><strong>康辉：</strong>现在走来的是陆军方队，领队是林向阳少将、唐兴华少将。<br> 作为人民军队中最早诞生的军种，从战火硝烟中一路走来。人民陆军加快提高精确作战、立体作战、全域作战、多能作战、持续作的战能力。<br><strong>海霞：</strong>海军方队走过来了。领队是周名贵少将、梁旭少将。从浅蓝走向深蓝，从近海防御走向远海防卫，与新中国同龄的人民海军一路劈波斩浪，纵横万里海疆，勇闯远海大洋。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013181121.png" alt=""><br><strong>康辉：</strong>现在走过来的是空军方队。领队是景涛少将、赵永远少将。人民空军成立不久后就开赴战场，为捍卫和平而战。70年搏击长空，逐梦蓝天，与共和国一起展翅高飞h今天的人民空军，正向着空天一体，攻防兼备的战略目标迈进。<br><strong>海霞：</strong>现在走过来的是火箭军方队，领队是薛今峰少将、张凤中少将。<br> 火箭军的常规导弹和核导弹，动于九天之上，打得越来越远，越来越准，越来越难以防御，经过半个多世纪的潜心砺剑，火箭军已成为核常兼备、全域慑战的战略军种。<br><strong>康辉：</strong>战略支援部队方队首次出现在国庆阅兵中，领队是王学武少将、康怀海少将。战略支援部队在改革强军中诞生，为人民军队输送现代战争内功，是维护国家安全的新型作战力量。</p><p><strong>海霞：</strong>联勤保障部队方队，也是第一次亮相天安门广场，领队是刘向东少将，任延兵少将。兵马为重，保障先行，现代战争需要规模精良的能源和物资供应，需要科学高效精准，从不掉链子的联合保障。<br><strong>康辉：</strong>现在接受检阅的是武警部队方队，领队是赵东方少将、张卫国少将。多能一体，维稳维权。武警部队常年奋战在执勤、处突、反恐、维权执法和抢险救援第一线，维护国家安全政治安全和社会稳定，保卫人民美好生活，永远做党和人民的忠诚卫士。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013181525.png" alt=""><br><strong>海霞：</strong>女兵方队走过来了,领队是程晓健少将、唐冰少将。352名女兵来自各军兵种和武警部队，飒爽英姿五尺枪，她们在火热军营中放飞青春成就梦想。     <img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013181641.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013181902.png" alt=""> </p><p><strong>康辉：</strong>现在走过来的是院校科研方队，领队是衣述强少将、栾复新少将。受阅队员来自军事科学院、国防大学、国防科技大学。面向战场、面向部队、面向未来，培养-流军事人才，军事科研工作开创崭新局面。<br><strong>海霞：</strong>文职人员方队首次亮相阅兵场，领队是王海涛、王华岩。汇聚天下英才，壮大强军事业，伴随着人民军队改革重塑，各方面的优秀人才汇入军营，用知识和智慧助力国防和军队现代化。<br><strong>康辉：</strong>现在走过来的是预备役部队方队，领队是高新江大校、徐振刚预备役大校。建设祖国有作为，保卫祖国有能力，预备役部队是人民解放军的后备力量，和现役部队一体建设运用稳步推进。<br><strong>海霞：</strong>现在走过来的是民兵方队，领队是赵冰清、廖炜炜。受阅女民兵来自首都各行各业。民兵源自百姓，定期接受军事训练，保持战斗能力。兵民是胜利之本，高技术战争条件下，人民战争依然是克敌制胜的重要法宝。<br><strong>康辉：</strong>蓝色贝雷帽，荒漠迷彩服，维和部队方队阔步走来。领队是徐有泽少将、马宝川少将。我国是联合国安理会常任理事国中派出维和官兵最多的国家。2500多名中国军人坚守在7个维和任务区，8000人的维和部队待命出征。先后有13名维和勇士牺牲在异国他乡。中国军人用热血和生命，谱写了维护世界和平的大国担当。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013182035.png" alt=""><br><strong>海霞：</strong>轰鸣声由远而近，装备方队即将进场。受阅的70个型号装备，均为中国制造，40%是首次亮相，32支装备方队编为7个作战模块，按照联合作战编程接受检阅。<br><strong>海霞：</strong>由全军荣誉功勋部队代表组成的战旗方队正浩荡而来。领队是五大战区主要指挥员，他们是刘粤军上将、王建武中将、赵宗岐上将.李桥铭中将、朱生岭上将。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013182149.png" alt=""><br><strong>康辉：</strong> 100面鲜红的战旗迎风飘扬! 100个英雄部队的荣誉称号气壮天地!为什么战旗美如画，英雄的鮮血染红了她。人民军队基因永不磨面，红色血脉永远传承。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013182255.png" alt=""><br><strong>海霞：</strong>机动作战，勇往直前，陆上作战模块即将接受检阅。<br><strong>海霞：</strong>坦克方队气势磅礴，领队是李明少将。22辆99A坦克呈”箭”形布阵，如战场霹雳，长驱直入。99A坦克是我国自主研发的主战坦克，具备优异的火力、机动、防护、和信息化水平。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013182351.png" alt=""></p><p><strong>康辉：</strong>紧随而来的轻型装甲方队，领队是邝德旺少将、王永胜少将。<br> 方队由15式新型轻型坦克、04A式履带步战车和履带指挥车混合编成，这些机械化、信息化装备，能够快速部署、快速反应、快速突击，是陆上应急作战的“急先锋”。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013182510.png" alt=""><br><strong>海霞：</strong>现在驶来的是海军陆战队抽组的两栖突击车方队，领队是祝传生少将、沙成录少将。受阅的05A式两栖装甲突击车既能陆地作战，也可以近海航渡，向目标海滩发起攻击，让我军在抢滩登陆作战中，进攻矛头更锋利，防护盾牌更坚固。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013182649.png" alt=""><br><strong>康辉：</strong>空降兵战车方队接受检阅，领队是邱火林少将、陈涛少将。<br> 受阅的轻型履带式步战车，可以空投敌人纵深地带，要害目标附近，让空降兵一落地，手头就有重家伙。他们从天而降，雷霆一击，是联合作战体系中的尖刀利刃。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013182755.png" alt=""><br><strong>海霞：</strong>自行火炮方队，领队是张剑锋少将、何纪抗少将。箱式火箭炮，集远程压制精确打击和信息化作战于一体，一次调炮，多点攻击，155车载加榴炮，是新型炮兵压制武器型，火力更猛，精度更高，机动性更强。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013182913.png" alt=""><br><strong>康辉：</strong>现在驶来的是反坦克导弹方队。领队是邹美余少将、李振领少将。受阅的红箭10反坦克导弹，既能精确打击地面目标，又能抗击低空低速的飞行。目前，我军已经形成多种发射类别、多种射程、多种制导方式的反坦克装备体系。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013183017.png" alt=""><br><strong>海霞：</strong>特战装备方队，领队是田越少将、王信民少将。全地形车，机动灵活，空中突击旋翼机展翅欲飞。两型装备适应复杂战场环境，兵力兵器实现快速投送，灵活布局，是破袭突击、出奇制胜的拳头力量。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013183132.png" alt=""><br><strong>康辉：</strong>紧随而来的是武警反恐突击方队，领队是刘兴立少将、王再发少将。受阅的反恐突击车和防暴装甲车，灵活机动，具备多种打击能力，能灵活地选择攻防手段，是武警部队维护国家安全和社会稳定的重要装备。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013183432.png" alt=""><br><strong>海霞：</strong>乘风破浪，向海图强!海上作战模块即将接受检阅!<br><strong>海霞：</strong>首先开过来的是岸舰导弹方队，领队是王显峰少将、吴育红少将。受阅的鹰击12B岸舰导弹可以打击大中型水面舰，对海突击威力大，反应迅速射程远，是沿海防御体系的坚实盾牌。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013183632.png" alt=""><br><strong>康辉：</strong>舰舰/潜舰导弹方队开过来了，领队是刘杰少将、姜平少将。受阅的鹰击18和鹰击18A导弹是我国新一代的反舰巡航导弹，藏得好，打得准，威力大，是海上联合打击体系的利剑。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013183742.png" alt=""><br><strong>海霞：</strong>舰载防空武器方队，领队是刘宏伟少将、张宝军少将。受阅的海红旗9B，红旗16，红旗10和万发炮，共同构成远程、中程、近程和末端对空防御体系，可以拦击高速来袭的敌方战机和导弹，为海上舰艇编队撑起一方立体保护网。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013184010.png" alt=""><br><strong>康辉：</strong>铸盾长空，御敌千里，防空反导模块即将接受检阅。<br><strong>康辉：</strong>预警雷达方队，领队是李国平少将、张磊少将。受阅装备是我国新一代高机动多功能雷达,能够探测和锁定飞机导弹等空天目标，提前发现这些不速之客!<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013184105.png" alt=""><br><strong>海霞：</strong>地空导弹第一方队，领队是刘明豹少将、韩宪锋少将。受阅的红旗9B远程地空导弹和红旗22中远程地空导弹，能够在复杂电磁环境下拦截多种空袭兵器，构筑起区域防空的坚固屏障!<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013184211.png" alt=""><br><strong>康辉：</strong>地空导弹第二方队，领队是朱瑞少将、董玉江少将。八套红旗12A地空导弹蓄势待发，四套红旗六弹炮系统昂首向前。远中近程结合，高中低空衔接，重要一点防空能力有效提升。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013184320.png" alt=""><br><strong>海霞：</strong>野战防空导弹方队，领队是张帆少将、裴晓昌少将。受阅的红旗17A、红旗16B两型防空导弹，机动性能强，反应速度快，拦截精度高，为野战防空提供了多种手段。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013184426.png" alt=""><br><strong>康辉：</strong>信息主导，体系制胜!即将接受检阅的是信息作战模块。<br><strong>康辉：</strong>首先开过来的是信息作战第一方队，领队是徐桂明少将、孟繁浩少将。受阅的信息侦测、数据干扰作战车组，侦察干扰能力强，既能独立遂行作战任务，又能支援战略方向联合作战，是无形战场上的神兵利器。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013184624.png" alt=""><br><strong>海霞：</strong>信息作战第二方队，领队是李发义少将、杨小康少将。受阅的三型侦察干扰车和区域拦阻式干扰车，具有部署灵活、机动性强等特点。新型电子对抗装备，为我军赢得复杂电磁环境下战场主动提供坚实支撑。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013184744.png" alt=""><br><strong>康辉：</strong>信息作战第三方队，领队是孙宝泰少将、景贤舫少将。受阅的频谱监测车，无线电接入节点车、卫星通信车和散射通信车，是联合作战体系制胜的可靠通信保障,能确保部队在严酷战争环境下通信畅通，耳聪目明。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013184830.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013185112.png" alt=""><br><strong>海霞：</strong>信息作战第四方队，领队是邓洪勤少将、金锋少将。气象水文观测车、地形勘测车、预报保障车、测绘导航车，能快速获取处理和传输战场环境信息，让指挥员对战场条件了如指掌!是我军全域作战的重要保障力量。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013185254.png" alt=""><br><strong>康辉：</strong>智能对抗，引领前沿，无人作战模块即将接受检阅。<br><strong>康辉：</strong>无人作战第一方队，领队是姜鹏少将、顾庆友少将。高空高速无人侦察机，侦察校射无人机，小型近程侦察无人机和中程高速无人机，能时时感知战场态势，精准引导，火力打击!<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013185410.png" alt=""><br><strong>海霞：</strong>无人作战第二方队，领队是王燕崎少将、乔亚军少将。受阅的攻击2无人机能够提供强大的火力支援，攻击11无人机能够对敌人纵深目标实施精确打击，反辐射无人机能够对敌人纵深目标实施精确打击，反辐射无人机可以压制摧毁防风预警系统。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013185534.png" alt=""><br><strong>康辉：</strong>无人作战第三方队，领队是李广泉少将、徐贵福少将。中国受阅的两型侦察干扰无人机和水下无火潜航器，上天入海，纵横驰程，是我军新型作战力量创新发展的显著成果。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013185659.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013185732.png" alt=""><br><strong>海霞：</strong>联合作战，保障先行，后勤装备保障模块即将接受检阅。<br><strong>海霞：</strong>现在开过来的是武警供应方队，领队是白忠斌少将、徐宝龙少将。受阅装备由野战近程车，野战站台车，运加油车，主食加工方舱混编而成。有了它们，官兵饮水吃饭，战场应急装卸，装备加油补给都更有保障。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013185843.png" alt=""><br><strong>康辉：</strong>正在接受检阅的是抢修抢救方队，领队是沈竹君少将、汤辛少将。受阅的野战手术方舱，装备抢救车，拆装修理车，装甲抢救车和装甲抢修车，共同构成了现代战场上人员和装备的移动医院。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013185918.png" alt=""><br><strong>海霞：</strong>大国长剑，浩荡东风，战略打击模块即将接受检阅。<br><strong>海霞：</strong>首先通过的是东风-17常规导弹方队，领队是张建强少将、王新国少将。东风快递，使命必达。首次公开亮相的东风-17常规导弹，具备全天候、无依托、强突防等特点，可对中近程目标实施精确打击。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013190023.png" alt=""><br><strong>康辉：</strong>现在通过的是长剑-100巡航导弹方队，领队是樊具贤少将、李家勤少将。作为长剑系列中的最新型号，长剑-100首次亮相国庆阅兵。这款超音速巡航导弹精度高、射程远、反应速快，长剑在手，敢缚苍龙!<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013190135.png" alt=""><br><strong>海霞：</strong>东风26核常兼备导弹方队正接受检阅，领队是张继春少将、刘同江少将。种导弹既能装核弹头，也能装常规弹头，可以跨区域机动，灵活选择发射阵地，精确打击地面、地下、海上目标。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013190307.png" alt=""><br><strong>康辉：</strong>巨浪-2导弹方队开过来了，领队是吴栋柱少将、初恩涛少将。巨浪-2型导弹是我国第二代潜射远程弹道导弹，它承担着支撑国家海基核威慑的重任。潜入深海,悄无声息，巨浪奔腾，威震海天。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013190427.png" alt=""><br><strong>海霞：</strong>东风-31甲改核导弹方队，领队是袁德华少将、何骏少将。这种导弹是我国自主研制的第二代固体洲际战略核导弹，机动性能好，生存能力强，部署转换快，打击精度高，担负着震慑强敌与核反击作战的重要使命。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013190631.png" alt=""><br><strong>康辉：</strong>东风-5B核导弹方队，领队是汪晓初少将、邓荣珍少将。东风浩荡，雷霆万钧，东风-5B液体洲际战略核导弹，突防能力强、毁伤威力大，是维护国家主权、捍卫民族尊严的重器。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013190748.png" alt=""><br><strong>海霞：</strong>装备方队最后一个出场的是东风一41核导弹方队，领队是赵秋领少将、孙乐少将。战略制衡、战略慑控、战略决胜，东风41洲际战略核导弹是我国战略核力量的重要支撑。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013190901.png" alt=""><br><strong>康辉：</strong>从弹道导弹到巡航导弹，从常规导弹到核导弹,它们是支撑强国梦、强军梦的坚强实力，是维护和平、捍卫和平的坚强盾牌。<br><strong>海霞：</strong>展翅长空，傲视苍穹，空中梯队即将接受检阅。<br><strong>康辉：</strong>领队机梯队率先飞临。<br><strong>康辉：</strong>空军司令员丁来杭上将在空警2000预警机.上担任指挥。空军八一飞行表演队的8架歼-10飞机护卫两翼，7道彩烟寓意着新中国70年的光辉历程。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013191116.png" alt=""><br><strong>海霞：</strong>预警指挥机梯队飞过来了空警500空警200预警机和运8指挥通信机分别由四架歼击机护卫，编成3个五机楔形梯队。长空千里眼，云天中军帐，国产预警机指挥控制、预警探测、识别跟踪能力稳步提升。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013191231.png" alt=""><br><strong>康辉：</strong>海上巡逻机梯队由空警500H预警机和首次亮相的运8反潜巡逻机组成第一楔队，空警200H、运8技术侦察机组成第二楔队，他们是维护国家领海领空安全，维护海洋权益的重要力量。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013191328.png" alt=""><br><strong>海霞：</strong>运输机梯队飞过来了。受阅的运20又称疯狂，它航程远，载重大，速度快，可以在复杂气象条件下执行长距离空中运输任务，使我军战略投送能力登上新高峰!和运20一起受阅的运9也是一款国产新型运输机。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013191439.png" alt=""><br><strong>康辉：</strong>现在飞过来的是支援保障机梯队。运9通信对抗飞机、心理战飞机、医疗救护机和运8远距离支援干扰及电子对抗侦察机,电子侦察机六型特种飞机分编为两个三级楔队，支援保障飞机的列装，有效提升了我军联合作战、全域作战的能力。<br><strong>海霞：</strong>轰炸机梯队正呼啸而来。三架轰6N,c6架轰6K分为三个三机楔队，第一次亮相的轰6N为国产新型远程战略轰炸机，可以空中授油，这两型轰炸机能够实施远程奔袭、大区域巡航和防区外打击。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013191620.png" alt=""><br><strong>康辉：</strong>加受油机梯队飞过来了。轰油-6伸出输油管，演示为歼10B战斗机空中加油。受油机距离加油机的加油锥套只有五米，长着翅膀的加油站，让战机有了更大的作战半径。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013191730.png" alt=""><br><strong>海霞：</strong>舰载机梯队接受检阅。歼15战机把人们的思绪带到了海天之间，带到了辽宁舰的甲板上。航母是现代海军的重器，舰载机是航母的刀锋!<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013191818.png" alt=""><br><strong>康辉：</strong>歼击机梯队进入我们的视野，5架歼20、5架歼16、5架歼10C战机组成三个楔队接受检阅。今天中国的歼击机家族不断壮天，为夺取战场制空权增添了制胜砝码。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013191912.png" alt=""><br><strong>海霞：</strong>陆航突击梯队正在接受检阅。五架直9武装侦察直升机组成的侦察警戒分队，九架直10武装直升机组成火力突击分队，三架直19武装直升机，六架直20战术通用直升机，九架直8B运输直升机混编为运输分队，八架直19武装直升机担任护卫任务，其中直20战术通用直升机是首次亮相阅兵场，飞旋的铁翼为陆军插上腾飞的翅膀。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013192000.png" alt=""><br><strong>康辉：</strong>最后接受检阅的是教练机梯队，有5架教10，5架歼教9，12架教8组成，其中教10加挂武器后可以执行空战任务。<br><strong>康辉：</strong>机群飞过，彩烟绚丽，余味悠长。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013192059.png" alt=""><br><strong>康辉：</strong>今天十万群众和70组彩车将组成36个方阵和3个情景式行进，以同心共筑中国梦为主题分为建国创业、改革开放、伟大复兴三个篇章，展现中国共产党团结带领全国各族人民从站起来、富起来到强起来的伟大征程。<br><strong>海霞：</strong>国旗方阵，国庆年号和国徽方阵、致敬方阵拉开了群众游行的序幕。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013192159.png" alt=""><br><strong>海霞：</strong>国旗方阵由高举巨幅国旗的1949名青年组成，70年前就在这里，五星红旗和世人初次见面，70年后的今天它比任何时候都闪耀惊艳。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013192325.png" alt=""><br><strong>康辉：</strong>2019名青年组成国庆年号和国徽方阵。1949到2019,70年栉风沐雨，70年砥砺奋进。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013192414.png" alt=""><br><strong>康辉：</strong>庄严神圣的国徽巍然屹立，这是我们伟大祖国的象征，代表着全体中国人民的尊严和力量。<br><strong>海霞：</strong>一曲《红旗颂》奏响，致敬方阵的21辆礼宾车徐徐驶来。第一辆礼宾车上，是6位新中国缔造者的亲属代表，3位老一辈科学家的家属代表和9位老红军、老八路军、老解放军。<br><strong>海霞：</strong>紧随而来的20辆礼宾车上也坐着老一辈党和国家、军队领导人亲属代表；老一辈建设者和家属代表；新中国成立前参加革命工作的老战士，老一辈军队退役英模、民兵英模和支前模范代表。<br><strong>康辉：</strong>一切向前走，都不能忘记走过的路。为了民族独立、人民解放和国家富强、人民幸福，无数先辈筑起了坚不可摧的血肉长城，铸就了坚强不屈的民族脊梁。<br><strong>海霞：</strong>一部民族史，一部奋斗史，一部英雄史。英雄胸前的勋章、奖章凝结着人民的敬意，后代手中的荣誉牌和纪念物铭刻着国家的记忆。一个有希望的民族不能没有英雄，一个有前途的国家不能没有先锋，今天，让我们再次向共和国的英雄和先锋致敬。<br><strong>康辉：</strong>今天，我们比历史上任何时期都更接近、更有信心和能力实现中华民族伟大复兴的目标。今天，老一辈的革命理想、优良传统和时代精神将继续激励我们，不忘初心、牢记使命、永远奋斗，向着这个宏伟目标奋勇前进!<br><strong>海霞：</strong>群众游行第一部分“建国创业”由5个方阵组成，打头的是“开天辟地”方阵。<br><strong>海霞：</strong>中国诞生了共产党，这是开天辟地的大事变。彩车上热血青年手持火把，拨开历史的迷雾，攀登真理的高峰，取来信念的火种，点亮革命的火炬，“星星之火”渐成燎原之势，荡涤风雨如磐的暗夜，燃烧成光耀中华的绚烂日出。</p><p><strong>康辉：</strong>从开天辟地到改天换地，凝结了一个民族刻骨铭心的磨难与觉醒、一个政党矢志不渝的奋斗与探索、一个国家波澜壮阔的进步与崛起。</p><p><strong>海霞：</strong>“浴血奋战”方阵中，三辆并行的彩车上，八一勋章、独立自由勋章和解放勋章熠熠生辉。金色勋章是建功立业的历历铭记，红色绶带是拼搏奋战的滚滚热血。抗击侵略，救亡图存，反抗压迫，争取自由，中国共产党团结带领中国人民浴血奋战28年，谱写了一曲气壮山河的英雄赞歌。为有牺牲多壮志，敢教日月换新天。牢记革命历史，传承红色基因，我们必将从胜利走向新的胜利！</p><p><strong>康辉：</strong>簇拥着毛泽东同志巨幅画像和标语的“建国伟业”方阵向我们走来。以毛泽东同志为主要代表的中国共产党人，创立了毛泽东思想，团结带领全党全国各族人民，取得了新民主主义革命的胜利，建立中华人民共和国，中华民族的发展进步从此开启了新纪元。中国人民，站起来了！五洲寰宇，换了人间！</p><p><strong>海霞：</strong>红旗漫卷，红绸翻飞，游行群众跳起了热情欢腾的“红绸舞”。“当家作主”方阵展现了亿万中国人民当家作主后的喜悦心情。彩车上的巨型雕塑，再现了“人民代表意气风发步出人民大会堂”的经典场景。中国人民，终于成为了国家的主人、社会的主人、自己命运的主人。</p><p><strong>康辉：</strong>“艰苦奋斗”方阵向我们走来。王进喜、时传祥……这每一个名字都让我们永远铭记。正是这种自力更生、艰苦奋斗的精神，让新中国从“一穷二白”中艰难走来，在砥砺奋进中拼搏成长。钢花飞溅、铁水奔流、石油流淌、麦浪滚滚，社会主义建设热火朝天。奋斗本身就是一种幸福。新时代，依然是属于奋斗者的时代！</p><p><strong>海霞：</strong>长安街上熙熙攘攘的自行车流，是属于一代人的青春记忆。少男少女拨响车铃穿梭而过，仿佛时光倒流，开启了第一段情境式行进“青春万岁”。</p><p><strong>海霞：</strong>一代青年有一代青年的青春之歌，实现中华民族伟大复兴，中国青年始终是先锋力量。</p><p><strong>康辉：</strong>群众游行第二部分“改革开放”由9个方阵组成。簇拥着邓小平同志巨幅画像和标语的“关键抉择”方阵正向我们走来。</p><p><strong>康辉：</strong>以邓小平同志为主要代表的中国共产党人，团结带领全党全国各族人民，创立了邓小平理论，作出实行改革开放的历史性决策，确立社会主义初级阶段基本路线，成功开创了中国特色社会主义。改革开放，是决定当代中国命运的关键一招，实现了中华民族从站起来到富起来的伟大飞跃！</p><p><strong>海霞：</strong>中国革命，从农村出发；中国改革，从农村突破。来自安徽凤阳小岗村、浙江安吉余村等地的农村改革领头人，和农民群众代表组成“希望田野”方阵，带着丰收的喜悦向我们走来。这是一块永远孕育着希望的热土。撒上火种，它就燃起燎原的烈焰；吹过春风，它就涌起翻滚的麦浪。</p><p><strong>康辉：</strong>时间就是金钱，效率就是生命。新中国在改革开放的浪潮中加快了前进的脚步。“春潮滚滚”方阵中，深圳、厦门等经济特区，万丈高楼平地起，谱写了改革开放的壮丽篇章。一代代的开拓者和建设者，以拓荒牛的精神，书写了一个个让世界瞩目的中国奇迹。</p><p><strong>海霞：</strong>簇拥着江泽民同志巨幅画像和标语的“与时俱进”方阵正向我们走来。以江泽民同志为主要代表的中国共产党人，团结带领全党全国各族人民，形成了“三个代表”重要思想，在严峻考验面前捍卫了中国特色社会主义，开创了全面改革开放新局面，成功把中国特色社会主义推向21世纪。世纪之交，风云际会，辉煌的成就，证明了中国特色社会主义制度的蓬勃生机和光明未来。</p><p><strong>康辉：</strong>港澳台同胞和各界群众组成了“一国两制”方阵，他们挥舞旗帜，欢呼致意，为共和国的生日献上儿女们最赤诚的祝福。“一国两制”伟大构想具有强大生命力。只要坚持全面准确理解和贯彻“一国两制”方针，严格按照宪法和基本法办事，香港和澳门必将拥有更加美好的明天。</p><p><strong>海霞：</strong>岁月如斯，不舍昼夜。“跨越世纪”方阵中，圆形日晷上流转着金色的光芒日历。世纪之初呱呱坠地的“世纪宝宝”，如今已长成英姿勃发的青年。源远流长的古老中国，历久弥新；跨越世纪的青春中国，风华正茂！</p><p><strong>康辉：</strong>簇拥着胡锦涛同志巨幅画像和标语的“科学发展”方阵向我们走来。以胡锦涛同志为主要代表的中国共产党人，团结带领全党全国各族人民，形成了科学发展观，形成中国特色社会主义事业总体布局，成功在新的历史起点上坚持和发展了中国特色社会主义。以人为本民心皆暖，和谐世界天下共赢。</p><p><strong>海霞：</strong>众志成城的彩车上，汶川县的映秀小学，红白镇的红顶民居，阿坝州的古堡新寨，这些都是在废墟上建立的新家园。时光荏苒，当年的“敬礼娃娃”，如今已经是青春少年。方阵中有参与抗击非典的医护工作人员，有参与汶川重建的解放军和武警部队官兵、救援队员、消防指战员、医疗队员、志愿者和各界群众。在无情灾害面前，我们万众一心，创造了抢险救灾和灾后重建的双重奇迹。</p><p><strong>康辉：</strong>“北京欢迎你”，这熟悉的旋律把我们拉回到了2008年那个盛夏。百年奥运，百年梦圆。只有上下一心的国家、富有进取心和想象力的国家，才能有那样的华彩呈现。“给中国一个机会，还世界一个奇迹”。2022年冬奥会，我们继续相约北京。</p><p><strong>海霞：</strong>激昂雄壮的鼓点催人奋进，中国功夫和舞狮表演的互动组合，开启了第二段情境式行进“东方雄狮”。睡狮早已醒来，雄狮昂首东方。美哉，我少年中国，与天不老！壮哉，我中国少年，与国无疆！</p><p><strong>康辉：</strong>群众游行第三部分“伟大复兴”由18个方阵组成。簇拥着习近平同志巨幅画像和标语的“伟大复兴”方阵向我们走来。党的十八大以来，以习近平同志为核心的党中央，团结带领全党全国各族人民，进行伟大斗争、建设伟大工程、推进伟大事业、实现伟大梦想，创立了习近平新时代中国特色社会主义思想，推动党和国家事业发生了历史性变革、取得了历史性成就。中国特色社会主义进入新时代！中华民族迎来了从站起来、富起来到强起来的伟大飞跃！</p><p><strong>海霞：</strong>科学技术是第一生产力，创新是引领发展的第一动力。科技创新领域的代表组成“创新驱动”方阵，自信昂扬地向我们走来。高铁、天宫、蛟龙，搭载着“天眼”“北斗”“C919大飞机”“长征三号”“天河二号”等大国重器，驰骋在科技强国的征途上。三辆彩车在行进中首尾相连，组成一列高速飞驰的“复兴号”，驶向更加美好的明天。</p><p><strong>康辉：</strong>“区域协调”方阵中，四条龙舟你追我赶，旋转“魔方”气象万千，东西南北纵横联动发展的新格局全面铺展。京津冀、长江经济带、粤港澳、长三角，“四大战略”齐头并进；西部开发、东北振兴、中部崛起、东部率先，“四大板块”协调发展。</p><p><strong>海霞：</strong>村口杨柳依依，院内海棠盛开，一幅幅农民画，描绘出新时代的美丽乡村。农村致富带头人、劳动模范和农民群众组成“乡村振兴”方阵向我们走来，产业兴旺、生态宜居、乡风文明、治理有效、生活富裕，中国农民的美好梦想正在变成现实。</p><p><strong>康辉：</strong>《宣誓号角》乐曲奏响，“民主法治”方阵向我们走来。彩车上，人民大会堂五星穹顶星光灿烂，《中华人民共和国宪法》庄严神圣，金色大手托起的，是我们共同捍卫人民民主的决心，是我们共同捍卫宪法法律尊严的承诺。</p><p><strong>海霞：</strong>56个民族56支花，56族兄弟姐妹是一家。“民族团结”方阵中的各族群众，手拉手，载歌载舞而来。彩车上“石榴瓶”光彩夺目，各民族像石榴籽一样紧紧抱在一起，血脉相连，风雨同舟。</p><p><strong>康辉：</strong>“人民有信仰，国家有力量，民族有希望”。“凝心铸魂”方阵走来，习近平新时代中国特色社会主义思想的火炬凝聚起强大的精神力量。强信心、聚民心、暖人心、筑同心，为国家立心，为民族立魂。14亿人一心谋发展，发展就有不竭动力。14亿人共爱一个家，祖国就欣欣向荣、日新月异。</p><p><strong>海霞：</strong>“中华文化”方阵彩车上好戏连台，乐手八音迭奏，舞者摇曳生姿，戏曲精彩绝伦，百花齐放，各展芳华。一个民族的复兴需要强大的物质力量，也需要强大的精神力量，文化兴国运兴，文化强民族强。</p><p><strong>康辉：</strong>“老师好！同学们好！”“立德树人”方阵中的师生代表们挥舞着校旗，簇拥着彩车从青春的歌声中走来。“打开的书本”生长出硕果累累的“知识树”，数据链组成的树干上耸立着“教育云”。三尺讲台系国运，只有德智体美劳全面发展的新一代才能真正肩负起民族复兴的重任。</p><p><strong>海霞：</strong>竞技体育成绩傲人，全民健身蓬勃开展，冬奥筹备卓有成效，冰雪运动快速普及。“体育强国”方阵的彩车，以“冰丝带”速滑馆造型为底座，以“首钢滑雪大跳台”造型为车体。北京冬奥会和冬残奥会的吉祥物“冰墩墩”和“雪容融”正在彩车上向大家招手示意。</p><p><strong>康辉：</strong>走在小康路上，一路歌美花香。来自独龙江乡、十八洞村等贫困地区驻村的“第一书记”出现在“脱贫攻坚”方阵的彩车上，6年时间，8000多万人脱贫，这是中国减贫史上的壮举，这是人类社会难以想象的奇迹！2020年，坚决打赢脱贫攻坚战，中华民族千百年来存在的绝对贫困问题将在我们这一代人的手里彻底解决。</p><p><strong>海霞：</strong>美好生活是什么？是环卫工人清扫的整洁环境，是快递小哥便捷的物流服务，是医生护士的悉心照料，是最美家庭的幸福相伴，是老年模特队的神采奕奕，是残障人士的方便出行。彩车上“幼有所育、学有所教、劳有所得、病有所医、老有所养、住有所居、弱有所扶”的生活场景一一呈现。美好生活从哪儿来？中国人的回答是：从奋斗中来。</p><p><strong>康辉：</strong>青山悠悠，绿水荡漾，生态环保战线的工作者组成“绿水青山”方阵。最严厉的环保执法，最大力度的环保投入，最深入人心的绿色生活理念，小到垃圾分类，大到江河治理。“绿水青山就是金山银山”这不仅是金句，更是中国最接地气的新发展理念。</p><p><strong>海霞：</strong>巨大的鲲鹏造型彩车，引领“中华儿女”方阵向我们走来。鲲鹏展翅，扶摇直上，象征着中华民族生生不息、展翅腾飞。紧随其后的是各省、自治区、直辖市和香港、澳门、台湾的彩车。</p><p><strong>康辉：</strong>第一辆是“首善北京”彩车；</p><p><strong>海霞：</strong>这是“新时代新天津”彩车；</p><p><strong>康辉：</strong>这是“盛世雄安”河北彩车；</p><p><strong>海霞：</strong>这是“奋进山西”彩车；</p><p><strong>康辉：</strong>这是“亮丽北疆”内蒙古彩车；</p><p><strong>海霞：</strong>这是“展翅腾飞”辽宁彩车；</p><p><strong>康辉：</strong>这是“速度吉林”彩车；</p><p><strong>海霞：</strong>这是“中华粮仓”黑龙江彩车；</p><p><strong>康辉：</strong>这是“奋进上海”彩车；</p><p><strong>海霞：</strong>这是“江苏智造”彩车；</p><p><strong>康辉：</strong>这是“潮涌之江”浙江彩车；</p><p><strong>海霞：</strong>这是“美好安徽”彩车；</p><p><strong>康辉：</strong>这是“高素质高颜值新福建”彩车；</p><p><strong>海霞：</strong>这是“金色赣鄱”江西彩车；</p><p><strong>康辉：</strong>这是“国泰民安”山东彩车；</p><p><strong>海霞：</strong>这是“出彩中原”河南彩车；</p><p><strong>康辉：</strong>这是“光耀湖北”彩车；</p><p><strong>海霞：</strong>这是“潇湘今朝”湖南彩车；</p><p><strong>康辉：</strong>这是“扬帆大湾”广东彩车；</p><p><strong>海霞：</strong>这是“壮美广西”彩车；</p><p><strong>康辉：</strong>这是“美好新海南”彩车；</p><p><strong>海霞：</strong>这是“魅力重庆”彩车；</p><p><strong>康辉：</strong>这是“逐梦兴川”四川彩车；</p><p><strong>海霞：</strong>这是“多彩贵州”彩车；</p><p><strong>康辉：</strong>这是“七彩云南”彩车；</p><p><strong>海霞：</strong>这是“幸福西藏”彩车；</p><p><strong>康辉：</strong>这是“壮阔三秦”陕西彩车；</p><p><strong>海霞：</strong>这是“交响丝路 如意甘肃”彩车；</p><p><strong>康辉：</strong>这是“中华水塔”青海彩车；</p><p><strong>海霞：</strong>这是“建设美丽新宁夏”彩车；</p><p><strong>康辉：</strong>这是“美丽新疆”彩车；</p><p><strong>海霞：</strong>这是“香港，进”彩车；</p><p><strong>康辉：</strong>这是“莲花绽放”澳门彩车；</p><p><strong>海霞：</strong>最后一辆是“宝岛台湾”彩车。</p><p><strong>康辉：</strong>一曲《千年之约》，婉转悠扬。中外青年携手前行，组成“人类命运共同体”方阵。彩车上，“一带一路”通古今，“友谊之桥”跨海陆，和平风帆共五洲。中国发展离不开世界，世界发展也需要中国。今天的节日，属于中国人民，也属于热爱和平的世界人民。</p><p><strong>海霞：</strong>“从严治党”彩车上是全国先进基层党组织代表和全国优秀党务工作者代表，中央八项规定精神、“民有所呼，我有所应”、“学习强国”等新时代的党建成果生动呈现。中国特色社会主义进入新时代，党内政治生态展现新气象，反腐败斗争取得压倒性胜利，全面从严治党取得重大成果。党的面貌焕然一新，党群关系、干群关系更加紧密。</p><p><strong>康辉：</strong>“不忘初心”方阵彩车上，焦裕禄、孔繁森、杨善洲等各个时期优秀共产党员的彩塑屹立山肩，全国优秀共产党员环立山腰，共产党人“全心全意为人民服务”承诺如山。</p><p><strong>海霞：</strong>七十载惊涛拍岸，九万里风鹏正举。“扬帆远航”方阵中的“中国号”巨轮两侧云帆徐徐升起，乘着新时代的浩荡东风，承载着14亿中国人民的梦想，劈波斩浪，扬帆远航。“直挂云帆济沧海”。中国共产党掌舵领航，“中国号”巨轮向着实现中华民族伟大复兴的目标，奋勇前进！</p><p><strong>康辉：</strong>红旗翻飞，鼓点激昂，2019名少先队员组成的行进乐团带来了第三段情境式行进“同心追梦”。少年当立凌云志，报效祖国会有时。中华民族伟大复兴的中国梦，终将在接续奋斗中成为现实。</p><p><strong>海霞：</strong>“我和我的祖国，一刻也不能分割”，这是我们心中永远的歌。<strong>康辉：</strong>5000名首都各界群众组成了“祖国万岁”方阵。</p><p><strong>海霞：</strong>70载风雨兼程，70载岁月峥嵘。</p><p><strong>康辉：</strong>70载沧桑巨变，70载春华秋实。</p><p><strong>海霞：</strong>祖国万岁大花篮，繁花锦簇，万紫千红，盘旋上升的红绸带寓意人民共和国发展蒸蒸日上。</p><p><strong>海霞：</strong>70年，弹指一挥间。70年，我们重整行装再出发。</p><p><strong>康辉：</strong>让我们紧密团结在以习近平同志为核心的党中央周围，高举中国特色社会主义伟大旗帜，以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想为指导，为实现“两个一百年”奋斗目标和中华民族伟大复兴的中国梦而努力奋斗！</p><p><strong>海霞：</strong>我们祝福祖国更加繁荣富强！</p><p><strong>康辉：</strong>我们祝福人民更加幸福安康！</p><p><strong>海霞、康辉：</strong>我们祝福明天更加灿烂辉煌！</p><p><strong>李克强：</strong>庆祝大会到此结束。</p><p>7万羽和平鸽展翅高飞，7万只气球腾空而起，伴着《歌唱祖国》的激昂旋律，庆祝大会圆满结束。<img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013192534.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013192744.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013192827.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013192908.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191013192937.png" alt=""></p><h4 id="人民日报评论"><a href="#人民日报评论" class="headerlink" title="人民日报评论"></a>人民日报评论</h4><blockquote><p>奋斗的史诗 复兴的伟力<br>——热烈庆祝中华人民共和国成立七十周年</p></blockquote><p>70年前的10月1日，第一面五星红旗冉冉升起，新生的人民共和国迎着朝阳出发，一路披荆斩棘，一路凯歌行进，把一个又一个胜利写在这片古老的土地上。</p><p>70年后，迎着又一个10月1日的晨曦，新长征路上的人民共和国，重整行装再出发。在新中国成立70周年的历史性时刻，近14亿中华儿女满怀喜悦和豪情，共庆人民共和国华诞，共享伟大祖国荣光！ </p><p>时间是伟大的书写者，记录走过的足迹，写下历史的华章。新中国成立70年来，中国大地沧海桑田，我们伟大祖国的面貌、伟大人民的面貌、中华民族的面貌发生了前所未有的大变化。70年风雨兼程，70年砥砺奋进，中国共产党带领人民开启筚路蓝缕的创业征程，掀起气壮山河的建设浪潮，闯出波澜壮阔的改革之路，张开拥抱世界的开放胸怀，创造了世所罕见的经济快速发展奇迹和社会长期稳定奇迹。以党的十八大为标志，中国特色社会主义进入新时代，中华民族迎来了从站起来、富起来到强起来的伟大飞跃。今天，曾经温饱不足的人们，即将迈入全面小康；曾经一穷二白的中国，巍然屹立于世界东方；曾经积贫积弱的民族，迎来伟大复兴的光明前景。正如习近平总书记豪迈宣示的：“历史充分证明，中国共产党和中国人民不仅善于打破一个旧世界，而且善于建设一个新世界。展望未来，中国的发展前景无限美好。” </p><p>雄关漫道真如铁，人间正道是沧桑。70年来新中国的发展历程，充满着苦难和辉煌、曲折和胜利、付出和收获。习近平总书记高度评价：“无论是在中华民族历史上，还是在世界历史上，这都是一部感天动地的奋斗史诗。”</p><p>1949—2019，这一部感天动地的奋斗史诗，印证了中国共产党人的初心和使命。实现中华民族伟大复兴，是近代以来中华民族最伟大的梦想。中国共产党一经成立，就义无反顾肩负起“为中国人民谋幸福、为中华民族谋复兴”的历史使命。近百年来，无论是弱小还是强大，无论是顺境还是逆境，我们党都初心不改、矢志不渝，团结带领人民历经千难万险，付出巨大牺牲，敢于面对曲折，勇于修正错误，攻克了一个又一个看似不可攻克的难关，创造了一个又一个彪炳史册的人间奇迹。新中国70年巨变的根本原因，70年历史性变革的内在逻辑，就是中国共产党的领导。中国共产党领导是中国特色社会主义最本质的特征，是中国特色社会主义制度的最大优势。在前进道路上，这个立志于千秋伟业的人民政党，牢记初心使命、推进自我革命，始终是中国人民和中华民族的主心骨，始终是复兴征程上的坚强领导核心。 </p><p>1949—2019，这一部感天动地的奋斗史诗，彰显了亿万人民的奋斗与豪情。“人民是共和国的坚实根基，人民是我们执政的最大底气。”亿万人胼手胝足的勤劳奋斗，成为一代又一代中国人的集体记忆；无数人奋勇向前的铿锵步履，汇成新中国70年发展壮大的雄浑乐章。今天，中国人民拥有的一切，都是拼搏奋斗干出来的，凝聚着追梦人的聪明才智，浸透着奋斗者的辛勤汗水。依靠人民的支持和信任，“与人民心心相印、与人民同甘共苦、与人民团结奋斗”，我们书写了无愧于时代、无愧于人民、无愧于历史的业绩。有创造历史的激情，有实现梦想的能力，有续写奇迹的信心，亿万人民撸起袖子加油干，一定能把我们的人民共和国建设得更加繁荣富强。 </p><p>1949—2019，这一部感天动地的奋斗史诗，铸就了中国特色社会主义的成功与辉煌。在新中国70年的持续探索中，特别是在改革开放40多年的伟大实践中，我们开创和发展了中国特色社会主义，从根本上改变了中国人民和中华民族的前途命运。治理中国这样一个大国不容易，但我们交出了一份优异的答卷。中国特色社会主义的巨大成功，用事实宣告了“历史终结论”的破产，宣告了各国最终都要以西方制度模式为归宿的单线式历史观的破产。70年来形成的中国特色社会主义制度和国家治理体系，显示出强大生命力和巨大优越性。今天，我们的道路越走越宽广、我们的理论不断发展、我们的制度日趋成熟、我们的文化持续繁荣。历史必将证明，中国特色社会主义，是一条引领中华民族走向伟大复兴的必由之路。</p><p>大道之行，天下为公。从一个积贫积弱的落后国家发展成为世界第二大经济体，中国靠的不是对外扩张和殖民掠夺，而是始终不渝走和平发展之路。70年来，中国专注于“把自己的事情办好”，走出了一条现代化的新路。多年来中国对世界经济增长贡献率超过30%，已连续13年成为世界经济增长的“第一引擎”，更以推动“一带一路”建设、构建人类命运共同体展现出一个大国担当、开放的胸怀。中国特色社会主义道路、理论、制度、文化不断发展，拓展了发展中国家走向现代化的途径，给世界上那些既希望加快发展又希望保持自身独立性的国家和民族提供了全新选择，为解决人类问题贡献了中国智慧和中国方案。世界命运握在各国人民手中，人类前途系于各国人民的抉择。中国人民愿同各国人民一道，推动人类命运共同体建设，共同创造人类的美好未来。 </p><p>时代大潮滚滚向前，复兴伟力不可阻挡。当今世界正经历百年未有之大变局，实现中华民族伟大复兴正处于关键时期，我们正在进行具有许多新的历史特点的伟大斗争。展望未来，决胜全面小康、开启强国征程，中华民族伟大复兴绝不是轻轻松松、敲锣打鼓就能实现的。对历史最好的致敬，是书写新的历史；对未来最好的把握，就是开创更美好的未来。让我们更加紧密地团结在以习近平同志为核心的党中央周围，增强“四个意识”、坚定“四个自信”、做到“两个维护”，万众一心、众志成城，在实现中华民族伟大复兴的新长征中创造新的更大奇迹！ </p><p>祝福伟大祖国更加繁荣昌盛！ 　　</p><p>祝福中华民族昂首走向复兴！</p><h4 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h4><p>慢慢看视频暂停截图上传，插入对应的文字后面，用时几个小时，整理不易，且看且珍惜。<br>转载请标明出处，由<a href="https://removeif.github.io/">辣椒の酱</a>收集整理。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;问：你在哪个瞬间觉得中国很强大？&lt;br&gt;答：就是现在！&lt;br&gt;开国大典的时候飞机不够，您说飞两遍，现在再也不需要飞两遍了，要多少有多少。&lt;br&gt;这盛世，如你所愿吧，山河犹在，国泰民安。当年送你的十里长安街，如今已是十里繁荣！&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="科普" scheme="https://removeif.github.io/categories/%E7%A7%91%E6%99%AE/"/>
    
    
      <category term="科普" scheme="https://removeif.github.io/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>中华人民共和国国旗法</title>
    <link href="https://removeif.github.io/2019/10/10/law/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E6%97%97%E6%B3%95.html"/>
    <id>https://removeif.github.io/2019/10/10/law/中华人民共和国国旗法.html</id>
    <published>2019-10-10T12:06:34.000Z</published>
    <updated>2019-10-10T12:12:28.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基本信息</p></blockquote><p>发文字号：主席令第18号</p><p>效力级别：法律</p><p>时效性：现行有效</p><p>发布日期：2009-08-27</p><p>实施日期：2009-08-27</p><p>发布机关：全国人大常委会<br><a id="more"></a></p><blockquote><p>法律修订</p></blockquote><p>1990年6月28日第七届全国人民代表大会常务委员会第十四次会议通过</p><p>1990年6月28日中华人民共和国主席令第28号公布</p><p>自1990年10月1日起施行</p><p>根据2009年8月27日第十一届全国人民代表大会常务委员会第十次会议通过的《全国人民代表大会常务委员会关于修改部分法律的决定》修正</p><p><a href="https://duxiaofa.baidu.com/detail?cid=1139334df8eb851acbcbedcb99f204d1_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国国旗法（1990修正）</a></p><blockquote><p>正文</p></blockquote><p><strong>第一条</strong></p><p>为了维护国旗的尊严，增强公民的国家观念，发扬爱国主义精神，根据宪法，制定本法。</p><p><strong>第二条</strong></p><p>中华人民共和国国旗是五星红旗。 中华人民共和国国旗按照中国人民政治协商会议第一届全体会议主席团公布的国旗制法说明制作。</p><p><strong>第三条</strong></p><p>中华人民共和国国旗是中华人民共和国的象征和标志。 每个公民和组织，都应当尊重和爱护国旗。</p><p><strong>第四条</strong></p><p>地方各级人民政府对本行政区域内国旗的升挂和使用，实施监督管理。 外交部、国务院交通主管部门、中国人民解放军总政治部对各自管辖范围内国旗的升挂和使用，实施监督管理。 国旗由省、自治区、直辖市的人民政府指定的企业制作。</p><p><strong>第五条</strong></p><p>下列场所或者机构所在地，应当每日升挂国旗： </p><ul><li>（一）北京天安门广场、新华门； </li><li>（二）全国人民代表大会常务委员会，国务院，中央军事委员会，最高人民法院，最高人民检察院； 中国人民政治协商会议全国委员会； </li><li>（三）外交部；</li><li>（四）出境入境的机场、港口、火车站和其他边境口岸，边防海防哨所。</li></ul><p><strong>第六条</strong></p><p>国务院各部门，地方各级人民代表大会常务委员会、人民政府、人民法院、人民检察院，中国人民政治协商会议地方各级委员会，应当在工作日升挂国旗。 全日制学校，除寒假、暑假和星期日外，应当每日升挂国旗。</p><p><strong>第七条</strong></p><p>国庆节、国际劳动节、元旦和春节，各级国家机关和各人民团体应当升挂国旗；企业事业组织，村民委员会、居民委员会，城镇居民院（楼）以及广场、公园等公共活动场所，有条件的可以升挂国旗。 不以春节为传统节日的少数民族地区，春节是否升挂国旗，由民族自治地方的自治机关规定。 民族自治地方在民族自治地方成立纪念日和主要传统民族节日，可以升挂国旗。</p><p><strong>第八条</strong></p><p>举行重大庆祝、纪念活动，大型文化、体育活动，大型展览会，可以升挂国旗。</p><p><strong>第九条</strong></p><p>外交活动以及国家驻外使馆领馆和其他外交代表机构升挂、使用国旗的办法，由外交部规定。</p><p><strong>第十条</strong></p><p>军事机关、军队营区、军用舰船，按照中央军事委员会的有关规定升挂国旗。</p><p><strong>第十一条</strong></p><p>民用船舶和进入中国领水的外国船舶升挂国旗的办法，由国务院交通主管部门规定。 公安部门执行边防、治安、消防任务的船舶升挂国旗的办法，由国务院公安部门规定。</p><p><strong>第十二条</strong></p><p>依照本法第五条、第六条、第七条的规定升挂国旗的，应当早晨升起，傍晚降下。 依照本法规定应当升挂国旗的，遇有恶劣天气，可以不升挂。</p><p><strong>第十三条</strong></p><p>升挂国旗时，可以举行升旗仪式。 举行升旗仪式时，在国旗升起的过程中，参加者应当面向国旗肃立致敬，并可以奏国歌或者唱国歌。 全日制中学小学，除假期外，每周举行一次升旗仪式。</p><p><strong>第十四条</strong></p><p>下列人士逝世，下半旗志哀： </p><ul><li>（一）中华人民共和国主席、全国人民代表大会常务委员会委员长、国务院总理、中央军事委员会主席；</li><li>（二）中国人民政治协商会议全国委员会主席； </li><li>（三）对中华人民共和国作出杰出贡献的人； </li><li>（四）对世界和平或者人类进步事业作出杰出贡献的人。 发生特别重大伤亡的不幸事件或者严重自然灾害造成重大伤亡时，可以下半旗志哀。 依照本条第一款（三）、（四）项和第二款的规定下半旗，由国务院决定。 依照本条规定下半旗的日期和场所，由国家成立的治丧机构或者国务院决定。</li></ul><p><strong>第十五条</strong></p><p>升挂国旗，应当将国旗置于显著的位置。 列队举持国旗和其他旗帜行进时，国旗应当在其他旗帜之前。 国旗与其他旗帜同时升挂时，应当将国旗置于中心、较高或者突出的位置。 在外事活动中同时升挂两个以上国家的国旗时，应当按照外交部的规定或者国际惯例升挂。</p><p><strong>第十六条</strong></p><p>在直立的旗杆上升降国旗，应当徐徐升降。升起时，必须将国旗升至杆顶；降下时，不得使国旗落地。 下半旗时，应当先将国旗升至杆顶，然后降至旗顶与杆顶之间的距离为旗杆全长的三分之一处；降下时，应当先将国旗升至杆顶，然后再降下。</p><p><strong>第十七条</strong></p><p>不得升挂破损、污损、褪色或者不合规格的国旗。</p><p><strong>第十八条</strong></p><p>国旗及其图案不得用作商标和广告，不得用于私人丧事活动。</p><p><strong>第十九条</strong></p><p>在公共场合故意以焚烧、毁损、涂划、玷污、践踏等方式侮辱中华人民共和国国旗的，依法追究刑事责任；情节较轻的，由公安机关处以十五日以下拘留。</p><p><strong>第二十条</strong></p><p>本法自1990年10月1日起施行。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基本信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;发文字号：主席令第18号&lt;/p&gt;
&lt;p&gt;效力级别：法律&lt;/p&gt;
&lt;p&gt;时效性：现行有效&lt;/p&gt;
&lt;p&gt;发布日期：2009-08-27&lt;/p&gt;
&lt;p&gt;实施日期：2009-08-27&lt;/p&gt;
&lt;p&gt;发布机关：全国人大常委会&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="法律" scheme="https://removeif.github.io/categories/%E6%B3%95%E5%BE%8B/"/>
    
    
      <category term="法律" scheme="https://removeif.github.io/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>中华人民共和国宪法</title>
    <link href="https://removeif.github.io/2019/10/10/law/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%AE%AA%E6%B3%95.html"/>
    <id>https://removeif.github.io/2019/10/10/law/中华人民共和国宪法.html</id>
    <published>2019-10-10T10:34:50.000Z</published>
    <updated>2019-10-24T10:36:23.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基本信息</p></blockquote><p>发文字号：全国人民代表大会公告第1号</p><p>效力级别：法律</p><p>时效性：现行有效</p><p>发布日期：2018-03-11</p><p>实施日期：2018-03-11</p><p>发布机关：全国人民代表大会<br><a id="more"></a></p><blockquote><p>法律修订</p></blockquote><p>1982年12月4日第五届全国人民代表大会第五次会议通过</p><p>1982年12月4日全国人民代表大会公告公布施行</p><p>根据1988年4月12日第七届全国人民代表大会第一次会议通过的《中华人民共和国宪法修正案》、1993年3月29日第八届全国人民代表大会第一次会议通过的《中华人民共和国宪法修正案》、1999年3月15日第九届全国人民代表大会第二次会议通过的《中华人民共和国宪法修正案》、2004年3月14日第十届全国人民代表大会第二次会议通过的《中华人民共和国宪法修正案》和2018年3月11日第十三届全国人民代表大会第一次会议通过的《中华人民共和国宪法修正案》修正</p><p><a href="https://duxiaofa.baidu.com/detail?cid=4ae984b229f129c11435f0e21b79216f_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国宪法（2004修正）</a></p><p><a href="https://duxiaofa.baidu.com/detail?cid=426729c34e27920ac1a13f0cce96a7a0_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国宪法（1999修正）</a></p><p><a href="https://duxiaofa.baidu.com/detail?cid=73926d1917cb99ffb2212eaf1de0f2eb_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国宪法（1993修正）</a></p><p><a href="https://duxiaofa.baidu.com/detail?cid=c750ece3ea316f67896b820b0263442e_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国宪法（1982修正）</a></p><p><a href="https://duxiaofa.baidu.com/detail?cid=18af662e80b7e2200e6e742f3dce89e9_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国宪法（1978修正）</a></p><p><a href="https://duxiaofa.baidu.com/detail?cid=dc14cc1823e64a4f1d035a854bcce923_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国宪法（1975修正）</a></p><p><a href="https://duxiaofa.baidu.com/detail?cid=58052ed400053cf3c9c99890164f83d3_law&amp;searchType=statute" target="_blank" rel="noopener">中华人民共和国宪法（1954修正）</a></p><blockquote><p>正文</p></blockquote><h3 id="序-言"><a href="#序-言" class="headerlink" title="序　　言"></a>序　　言</h3><p>中国是世界上历史最悠久的国家之一。中国各族人民共同创造了光辉灿烂的文化，具有光荣的革命传统。<br>一八四〇年以后，封建的中国逐渐变成半殖民地、半封建的国家。中国人民为国家独立、民族解放和民主自由进行了前仆后继的英勇奋斗。<br>二十世纪，中国发生了翻天覆地的伟大历史变革。<br>一九一一年孙中山先生领导的辛亥革命，废除了封建帝制，创立了中华民国。但是，中国人民反对帝国主义和封建主义的历史任务还没有完成。<br>一九四九年，以毛泽东主席为领袖的中国共产党领导中国各族人民，在经历了长期的艰难曲折的武装斗争和其他形式的斗争以后，终于推翻了帝国主义、封建主义和官僚资本主义的统治，取得了新民主主义革命的伟大胜利，建立了中华人民共和国。从此，中国人民掌握了国家的权力，成为国家的主人。<br>中华人民共和国成立以后，我国社会逐步实现了由新民主主义到社会主义的过渡。生产资料私有制的社会主义改造已经完成，人剥削人的制度已经消灭，社会主义制度已经确立。工人阶级领导的、以工农联盟为基础的人民民主专政，实质上即无产阶级专政，得到巩固和发展。中国人民和中国人民解放军战胜了帝国主义、霸权主义的侵略、破坏和武装挑衅，维护了国家的独立和安全，增强了国防。经济建设取得了重大的成就，独立的、比较完整的社会主义工业体系已经基本形成，农业生产显著提高。教育、科学、文化等事业有了很大的发展，社会主义思想教育取得了明显的成效。广大人民的生活有了较大的改善。<br>中国新民主主义革命的胜利和社会主义事业的成就，是中国共产党领导中国各族人民，在马克思列宁主义、毛泽东思想的指引下，坚持真理，修正错误，战胜许多艰难险阻而取得的。我国将长期处于社会主义初级阶段。国家的根本任务是，沿着中国特色社会主义道路，集中力量进行社会主义现代化建设。中国各族人民将继续在中国共产党领导下，在马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想指引下，坚持人民民主专政，坚持社会主义道路，坚持改革开放，不断完善社会主义的各项制度，发展社会主义市场经济，发展社会主义民主，健全社会主义法治，贯彻新发展理念，自力更生，艰苦奋斗，逐步实现工业、农业、国防和科学技术的现代化，推动物质文明、政治文明、精神文明、社会文明、生态文明协调发展，把我国建设成为富强民主文明和谐美丽的社会主义现代化强国，实现中华民族伟大复兴。<br>在我国，剥削阶级作为阶级已经消灭，但是阶级斗争还将在一定范围内长期存在。中国人民对敌视和破坏我国社会主义制度的国内外的敌对势力和敌对分子，必须进行斗争。<br>台湾是中华人民共和国的神圣领土的一部分。完成统一祖国的大业是包括台湾同胞在内的全中国人民的神圣职责。<br>社会主义的建设事业必须依靠工人、农民和知识分子，团结一切可以团结的力量。在长期的革命、建设、改革过程中，已经结成由中国共产党领导的，有各民主党派和各人民团体参加的，包括全体社会主义劳动者、社会主义事业的建设者、拥护社会主义的爱国者、拥护祖国统一和致力于中华民族伟大复兴的爱国者的广泛的爱国统一战线，这个统一战线将继续巩固和发展。中国人民政治协商会议是有广泛代表性的统一战线组织，过去发挥了重要的历史作用，今后在国家政治生活、社会生活和对外友好活动中，在进行社会主义现代化建设、维护国家的统一和团结的斗争中，将进一步发挥它的重要作用。中国共产党领导的多党合作和政治协商制度将长期存在和发展。<br>中华人民共和国是全国各族人民共同缔造的统一的多民族国家。平等团结互助和谐的社会主义民族关系已经确立，并将继续加强。在维护民族团结的斗争中，要反对大民族主义，主要是大汉族主义，也要反对地方民族主义。国家尽一切努力，促进全国各民族的共同繁荣。<br>中国革命、建设、改革的成就是同世界人民的支持分不开的。中国的前途是同世界的前途紧密地联系在一起的。中国坚持独立自主的对外政策，坚持互相尊重主权和领土完整、互不侵犯、互不干涉内政、平等互利、和平共处的五项原则，坚持和平发展道路，坚持互利共赢开放战略，发展同各国的外交关系和经济、文化交流，推动构建人类命运共同体；坚持反对帝国主义、霸权主义、殖民主义，加强同世界各国人民的团结，支持被压迫民族和发展中国家争取和维护民族独立、发展民族经济的正义斗争，为维护世界和平和促进人类进步事业而努力。<br>本宪法以法律的形式确认了中国各族人民奋斗的成果，规定了国家的根本制度和根本任务，是国家的根本法，具有最高的法律效力。全国各族人民、一切国家机关和武装力量、各政党和各社会团体、各企业事业组织，都必须以宪法为根本的活动准则，并且负有维护宪法尊严、保证宪法实施的职责。</p><h3 id="第一章-总-纲"><a href="#第一章-总-纲" class="headerlink" title="第一章　总　　纲"></a>第一章　总　　纲</h3><p><strong>第一条</strong></p><p>中华人民共和国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家。 社会主义制度是中华人民共和国的根本制度。中国共产党领导是中国特色社会主义最本质的特征。禁止任何组织或者个人破坏社会主义制度。</p><p><strong>第二条</strong></p><p>中华人民共和国的一切权力属于人民。 人民行使国家权力的机关是全国人民代表大会和地方各级人民代表大会。 人民依照法律规定，通过各种途径和形式，管理国家事务，管理经济和文化事业，管理社会事务。</p><p><strong>第三条</strong></p><p>中华人民共和国的国家机构实行民主集中制的原则。 全国人民代表大会和地方各级人民代表大会都由民主选举产生，对人民负责，受人民监督。 国家行政机关、监察机关、审判机关、检察机关都由人民代表大会产生，对它负责，受它监督。 中央和地方的国家机构职权的划分，遵循在中央的统一领导下，充分发挥地方的主动性、积极性的原则。</p><p><strong>第四条</strong></p><p>中华人民共和国各民族一律平等。国家保障各少数民族的合法的权利和利益，维护和发展各民族的平等团结互助和谐关系。禁止对任何民族的歧视和压迫，禁止破坏民族团结和制造民族分裂的行为。 国家根据各少数民族的特点和需要，帮助各少数民族地区加速经济和文化的发展。 各少数民族聚居的地方实行区域自治，设立自治机关，行使自治权。各民族自治地方都是中华人民共和国不可分离的部分。 各民族都有使用和发展自己的语言文字的自由，都有保持或者改革自己的风俗习惯的自由。</p><p><strong>第五条</strong></p><p>中华人民共和国实行依法治国，建设社会主义法治国家。 国家维护社会主义法制的统一和尊严。 一切法律、行政法规和地方性法规都不得同宪法相抵触。 一切国家机关和武装力量、各政党和各社会团体、各企业事业组织都必须遵守宪法和法律。一切违反宪法和法律的行为，必须予以追究。 任何组织或者个人都不得有超越宪法和法律的特权。</p><p><strong>第六条</strong></p><p>中华人民共和国的社会主义经济制度的基础是生产资料的社会主义公有制，即全民所有制和劳动群众集体所有制。社会主义公有制消灭人剥削人的制度，实行各尽所能、按劳分配的原则。 国家在社会主义初级阶段，坚持公有制为主体、多种所有制经济共同发展的基本经济制度，坚持按劳分配为主体、多种分配方式并存的分配制度。</p><p><strong>第七条</strong></p><p>国有经济，即社会主义全民所有制经济，是国民经济中的主导力量。国家保障国有经济的巩固和发展。</p><p><strong>第八条</strong></p><p>农村集体经济组织实行家庭承包经营为基础、统分结合的双层经营体制。农村中的生产、供销、信用、消费等各种形式的合作经济，是社会主义劳动群众集体所有制经济。参加农村集体经济组织的劳动者，有权在法律规定的范围内经营自留地、自留山、家庭副业和饲养自留畜。 城镇中的手工业、工业、建筑业、运输业、商业、服务业等行业的各种形式的合作经济，都是社会主义劳动群众集体所有制经济。 国家保护城乡集体经济组织的合法的权利和利益，鼓励、指导和帮助集体经济的发展。</p><p><strong>第九条</strong></p><p>矿藏、水流、森林、山岭、草原、荒地、滩涂等自然资源，都属于国家所有，即全民所有；由法律规定属于集体所有的森林和山岭、草原、荒地、滩涂除外。 国家保障自然资源的合理利用，保护珍贵的动物和植物。禁止任何组织或者个人用任何手段侵占或者破坏自然资源。</p><p><strong>第十条</strong></p><p>城市的土地属于国家所有。 农村和城市郊区的土地，除由法律规定属于国家所有的以外，属于集体所有；宅基地和自留地、自留山，也属于集体所有。 国家为了公共利益的需要，可以依照法律规定对土地实行征收或者征用并给予补偿。 任何组织或者个人不得侵占、买卖或者以其他形式非法转让土地。土地的使用权可以依照法律的规定转让。 一切使用土地的组织和个人必须合理地利用土地。</p><p><strong>第十一条</strong></p><p>在法律规定范围内的个体经济、私营经济等非公有制经济，是社会主义市场经济的重要组成部分。 国家保护个体经济、私营经济等非公有制经济的合法的权利和利益。国家鼓励、支持和引导非公有制经济的发展，并对非公有制经济依法实行监督和管理。</p><p><strong>第十二条</strong></p><p>社会主义的公共财产神圣不可侵犯。 国家保护社会主义的公共财产。禁止任何组织或者个人用任何手段侵占或者破坏国家的和集体的财产。</p><p><strong>第十三条</strong></p><p>公民的合法的私有财产不受侵犯。 国家依照法律规定保护公民的私有财产权和继承权。 国家为了公共利益的需要，可以依照法律规定对公民的私有财产实行征收或者征用并给予补偿。</p><p><strong>第十四条</strong></p><p>国家通过提高劳动者的积极性和技术水平，推广先进的科学技术，完善经济管理体制和企业经营管理制度，实行各种形式的社会主义责任制，改进劳动组织，以不断提高劳动生产率和经济效益，发展社会生产力。 国家厉行节约，反对浪费。 国家合理安排积累和消费，兼顾国家、集体和个人的利益，在发展生产的基础上，逐步改善人民的物质生活和文化生活。 国家建立健全同经济发展水平相适应的社会保障制度。</p><p><strong>第十五条</strong></p><p>国家实行社会主义市场经济。 国家加强经济立法，完善宏观调控。 国家依法禁止任何组织或者个人扰乱社会经济秩序。</p><p><strong>第十六条</strong></p><p>国有企业在法律规定的范围内有权自主经营。 国有企业依照法律规定，通过职工代表大会和其他形式，实行民主管理。</p><p><strong>第十七条</strong></p><p>集体经济组织在遵守有关法律的前提下，有独立进行经济活动的自主权。 集体经济组织实行民主管理，依照法律规定选举和罢免管理人员，决定经营管理的重大问题。</p><p><strong>第十八条</strong></p><p>中华人民共和国允许外国的企业和其他经济组织或者个人依照中华人民共和国法律的规定在中国投资，同中国的企业或者其他经济组织进行各种形式的经济合作。 在中国境内的外国企业和其他外国经济组织以及中外合资经营的企业，都必须遵守中华人民共和国的法律。它们的合法的权利和利益受中华人民共和国法律的保护。</p><p><strong>第十九条</strong></p><p>国家发展社会主义的教育事业，提高全国人民的科学文化水平。 国家举办各种学校，普及初等义务教育，发展中等教育、职业教育和高等教育，并且发展学前教育。 国家发展各种教育设施，扫除文盲，对工人、农民、国家工作人员和其他劳动者进行政治、文化、科学、技术、业务的教育，鼓励自学成才。 国家鼓励集体经济组织、国家企业事业组织和其他社会力量依照法律规定举办各种教育事业。 国家推广全国通用的普通话。</p><p><strong>第二十条</strong></p><p>国家发展自然科学和社会科学事业，普及科学和技术知识，奖励科学研究成果和技术发明创造。</p><p><strong>第二十一条</strong></p><p>国家发展医疗卫生事业，发展现代医药和我国传统医药，鼓励和支持农村集体经济组织、国家企业事业组织和街道组织举办各种医疗卫生设施，开展群众性的卫生活动，保护人民健康。 国家发展体育事业，开展群众性的体育活动，增强人民体质。</p><p><strong>第二十二条</strong></p><p>国家发展为人民服务、为社会主义服务的文学艺术事业、新闻广播电视事业、出版发行事业、图书馆博物馆文化馆和其他文化事业，开展群众性的文化活动。 国家保护名胜古迹、珍贵文物和其他重要历史文化遗产。</p><p><strong>第二十三条</strong></p><p>国家培养为社会主义服务的各种专业人才，扩大知识分子的队伍，创造条件，充分发挥他们在社会主义现代化建设中的作用。</p><p><strong>第二十四条</strong></p><p>国家通过普及理想教育、道德教育、文化教育、纪律和法制教育，通过在城乡不同范围的群众中制定和执行各种守则、公约，加强社会主义精神文明的建设。 国家倡导社会主义核心价值观，提倡爱祖国、爱人民、爱劳动、爱科学、爱社会主义的公德，在人民中进行爱国主义、集体主义和国际主义、共产主义的教育，进行辩证唯物主义和历史唯物主义的教育，反对资本主义的、封建主义的和其他的腐朽思想。</p><p><strong>第二十五条</strong></p><p>国家推行计划生育，使人口的增长同经济和社会发展计划相适应。</p><p><strong>第二十六条</strong></p><p>国家保护和改善生活环境和生态环境，防治污染和其他公害。 国家组织和鼓励植树造林，保护林木。</p><p><strong>第二十七条</strong></p><p>一切国家机关实行精简的原则，实行工作责任制，实行工作人员的培训和考核制度，不断提高工作质量和工作效率，反对官僚主义。 一切国家机关和国家工作人员必须依靠人民的支持，经常保持同人民的密切联系，倾听人民的意见和建议，接受人民的监督，努力为人民服务。 国家工作人员就职时应当依照法律规定公开进行宪法宣誓。</p><p><strong>第二十八条</strong></p><p>国家维护社会秩序，镇压叛国和其他危害国家安全的犯罪活动，制裁危害社会治安、破坏社会主义经济和其他犯罪的活动，惩办和改造犯罪分子。</p><p><strong>第二十九条</strong></p><p>中华人民共和国的武装力量属于人民。它的任务是巩固国防，抵抗侵略，保卫祖国，保卫人民的和平劳动，参加国家建设事业，努力为人民服务。 国家加强武装力量的革命化、现代化、正规化的建设，增强国防力量。</p><p><strong>第三十条</strong></p><p>中华人民共和国的行政区域划分如下： </p><ul><li>（一）全国分为省、自治区、直辖市； </li><li>（二）省、自治区分为自治州、县、自治县、市； </li><li>（三）县、自治县分为乡、民族乡、镇。 直辖市和较大的市分为区、县。自治州分为县、自治县、市。 自治区、自治州、自治县都是民族自治地方。</li></ul><p><strong>第三十一条</strong></p><p>国家在必要时得设立特别行政区。在特别行政区内实行的制度按照具体情况由全国人民代表大会以法律规定。</p><p><strong>第三十二条</strong></p><p>中华人民共和国保护在中国境内的外国人的合法权利和利益，在中国境内的外国人必须遵守中华人民共和国的法律。 中华人民共和国对于因为政治原因要求避难的外国人，可以给予受庇护的权利。</p><h3 id="第二章-公民的基本权利和义务"><a href="#第二章-公民的基本权利和义务" class="headerlink" title="第二章　公民的基本权利和义务"></a>第二章　公民的基本权利和义务</h3><p><strong>第三十三条</strong></p><p>凡具有中华人民共和国国籍的人都是中华人民共和国公民。 中华人民共和国公民在法律面前一律平等。 国家尊重和保障人权。 任何公民享有宪法和法律规定的权利，同时必须履行宪法和法律规定的义务。</p><p><strong>第三十四条</strong></p><p>中华人民共和国年满十八周岁的公民，不分民族、种族、性别、职业、家庭出身、宗教信仰、教育程度、财产状况、居住期限，都有选举权和被选举权；但是依照法律被剥夺政治权利的人除外。</p><p><strong>第三十五条</strong></p><p>中华人民共和国公民有言论、出版、集会、结社、游行、示威的自由。</p><p><strong>第三十六条</strong></p><p>中华人民共和国公民有宗教信仰自由。 任何国家机关、社会团体和个人不得强制公民信仰宗教或者不信仰宗教，不得歧视信仰宗教的公民和不信仰宗教的公民。 国家保护正常的宗教活动。任何人不得利用宗教进行破坏社会秩序、损害公民身体健康、妨碍国家教育制度的活动。 宗教团体和宗教事务不受外国势力的支配。</p><p><strong>第三十七条</strong></p><p>中华人民共和国公民的人身自由不受侵犯。 任何公民，非经人民检察院批准或者决定或者人民法院决定，并由公安机关执行，不受逮捕。 禁止非法拘禁和以其他方法非法剥夺或者限制公民的人身自由，禁止非法搜查公民的身体。</p><p><strong>第三十八条</strong></p><p>中华人民共和国公民的人格尊严不受侵犯。禁止用任何方法对公民进行侮辱、诽谤和诬告陷害。</p><p><strong>第三十九条</strong></p><p>中华人民共和国公民的住宅不受侵犯。禁止非法搜查或者非法侵入公民的住宅。</p><p><strong>第四十条</strong></p><p>中华人民共和国公民的通信自由和通信秘密受法律的保护。除因国家安全或者追查刑事犯罪的需要，由公安机关或者检察机关依照法律规定的程序对通信进行检查外，任何组织或者个人不得以任何理由侵犯公民的通信自由和通信秘密。</p><p><strong>第四十一条</strong></p><p>中华人民共和国公民对于任何国家机关和国家工作人员，有提出批评和建议的权利；对于任何国家机关和国家工作人员的违法失职行为，有向有关国家机关提出申诉、控告或者检举的权利，但是不得捏造或者歪曲事实进行诬告陷害。 对于公民的申诉、控告或者检举，有关国家机关必须查清事实，负责处理。任何人不得压制和打击报复。 由于国家机关和国家工作人员侵犯公民权利而受到损失的人，有依照法律规定取得赔偿的权利。</p><p><strong>第四十二条</strong></p><p>中华人民共和国公民有劳动的权利和义务。 国家通过各种途径，创造劳动就业条件，加强劳动保护，改善劳动条件，并在发展生产的基础上，提高劳动报酬和福利待遇。 劳动是一切有劳动能力的公民的光荣职责。国有企业和城乡集体经济组织的劳动者都应当以国家主人翁的态度对待自己的劳动。国家提倡社会主义劳动竞赛，奖励劳动模范和先进工作者。国家提倡公民从事义务劳动。 国家对就业前的公民进行必要的劳动就业训练。</p><p><strong>第四十三条</strong></p><p>中华人民共和国劳动者有休息的权利。 国家发展劳动者休息和休养的设施，规定职工的工作时间和休假制度。</p><p><strong>第四十四条</strong></p><p>国家依照法律规定实行企业事业组织的职工和国家机关工作人员的退休制度。退休人员的生活受到国家和社会的保障。</p><p><strong>第四十五条</strong></p><p>中华人民共和国公民在年老、疾病或者丧失劳动能力的情况下，有从国家和社会获得物质帮助的权利。国家发展为公民享受这些权利所需要的社会保险、社会救济和医疗卫生事业。 国家和社会保障残废军人的生活，抚恤烈士家属，优待军人家属。 国家和社会帮助安排盲、聋、哑和其他有残疾的公民的劳动、生活和教育。</p><p><strong>第四十六条</strong></p><p>中华人民共和国公民有受教育的权利和义务。 国家培养青年、少年、儿童在品德、智力、体质等方面全面发展。</p><p><strong>第四十七条</strong></p><p>中华人民共和国公民有进行科学研究、文学艺术创作和其他文化活动的自由。国家对于从事教育、科学、技术、文学、艺术和其他文化事业的公民的有益于人民的创造性工作，给以鼓励和帮助。</p><p><strong>第四十八条</strong></p><p>中华人民共和国妇女在政治的、经济的、文化的、社会的和家庭的生活等各方面享有同男子平等的权利。 国家保护妇女的权利和利益，实行男女同工同酬，培养和选拔妇女干部。</p><p><strong>第四十九条</strong></p><p>婚姻、家庭、母亲和儿童受国家的保护。 夫妻双方有实行计划生育的义务。 父母有抚养教育未成年子女的义务，成年子女有赡养扶助父母的义务。 禁止破坏婚姻自由，禁止虐待老人、妇女和儿童。</p><p><strong>第五十条</strong></p><p>中华人民共和国保护华侨的正当的权利和利益，保护归侨和侨眷的合法的权利和利益。</p><p><strong>第五十一条</strong></p><p>中华人民共和国公民在行使自由和权利的时候，不得损害国家的、社会的、集体的利益和其他公民的合法的自由和权利。</p><p><strong>第五十二条</strong></p><p>中华人民共和国公民有维护国家统一和全国各民族团结的义务。</p><p><strong>第五十三条</strong></p><p>中华人民共和国公民必须遵守宪法和法律，保守国家秘密，爱护公共财产，遵守劳动纪律，遵守公共秩序，尊重社会公德。</p><p><strong>第五十四条</strong></p><p>中华人民共和国公民有维护祖国的安全、荣誉和利益的义务，不得有危害祖国的安全、荣誉和利益的行为。</p><p><strong>第五十五条</strong></p><p>保卫祖国、抵抗侵略是中华人民共和国每一个公民的神圣职责。 依照法律服兵役和参加民兵组织是中华人民共和国公民的光荣义务。</p><p><strong>第五十六条</strong></p><p>中华人民共和国公民有依照法律纳税的义务。</p><h3 id="第三章-国家机构"><a href="#第三章-国家机构" class="headerlink" title="第三章　国家机构"></a>第三章　国家机构</h3><p><strong>第五十七条</strong></p><p>中华人民共和国全国人民代表大会是最高国家权力机关。它的常设机关是全国人民代表大会常务委员会。</p><p><strong>第五十八条</strong></p><p>全国人民代表大会和全国人民代表大会常务委员会行使国家立法权。</p><p><strong>第五十九条</strong></p><p>全国人民代表大会由省、自治区、直辖市、特别行政区和军队选出的代表组成。各少数民族都应当有适当名额的代表。 全国人民代表大会代表的选举由全国人民代表大会常务委员会主持。 全国人民代表大会代表名额和代表产生办法由法律规定。</p><p><strong>第六十条</strong></p><p>全国人民代表大会每届任期五年。 全国人民代表大会任期届满的两个月以前，全国人民代表大会常务委员会必须完成下届全国人民代表大会代表的选举。如果遇到不能进行选举的非常情况，由全国人民代表大会常务委员会以全体组成人员的三分之二以上的多数通过，可以推迟选举，延长本届全国人民代表大会的任期。在非常情况结束后一年内，必须完成下届全国人民代表大会代表的选举。</p><p><strong>第六十一条</strong></p><p>全国人民代表大会会议每年举行一次，由全国人民代表大会常务委员会召集。如果全国人民代表大会常务委员会认为必要，或者有五分之一以上的全国人民代表大会代表提议，可以临时召集全国人民代表大会会议。 全国人民代表大会举行会议的时候，选举主席团主持会议。</p><p><strong>第六十二条</strong></p><p>全国人民代表大会行使下列职权：  </p><ul><li>（一）修改宪法； </li><li>（二）监督宪法的实施； </li><li>（三）制定和修改刑事、民事、国家机构的和其他的基本法律； </li><li>（四）选举中华人民共和国主席、副主席； </li><li>（五）根据中华人民共和国主席的提名，决定国务院总理的人选；根据国务院总理的提名，决定国务院副总理、国务委员、各部部长、各委员会主任、审计长、秘书长的人选； </li><li>（六）选举中央军事委员会主席；根据中央军事委员会主席的提名，决定中央军事委员会其他组成人员的人选； </li><li>（七）选举国家监察委员会主任； </li><li>（八）选举最高人民法院院长； </li><li>（九）选举最高人民检察院检察长； </li><li>（十）审查和批准国民经济和社会发展计划和计划执行情况的报告； </li><li>（十一）审查和批准国家的预算和预算执行情况的报告； </li><li>（十二）改变或者撤销全国人民代表大会常务委员会不适当的决定； </li><li>（十三）批准省、自治区和直辖市的建置； </li><li>（十四）决定特别行政区的设立及其制度； </li><li>（十五）决定战争和和平的问题； </li><li>（十六）应当由最高国家权力机关行使的其他职权。</li></ul><p><strong>第六十三条</strong></p><p>全国人民代表大会有权罢免下列人员： </p><ul><li>（一）中华人民共和国主席、副主席； </li><li>（二）国务院总理、副总理、国务委员、各部部长、各委员会主任、审计长、秘书长； </li><li>（三）中央军事委员会主席和中央军事委员会其他组成人员； </li><li>（四）国家监察委员会主任； </li><li>（五）最高人民法院院长； </li><li>（六）最高人民检察院检察长。</li></ul><p><strong>第六十四条</strong></p><p>宪法的修改，由全国人民代表大会常务委员会或者五分之一以上的全国人民代表大会代表提议，并由全国人民代表大会以全体代表的三分之二以上的多数通过。 法律和其他议案由全国人民代表大会以全体代表的过半数通过。</p><p><strong>第六十五条</strong></p><p>全国人民代表大会常务委员会由下列人员组成： 委员长， 副委员长若干人， 秘书长， 委员若干人。 全国人民代表大会常务委员会组成人员中，应当有适当名额的少数民族代表。 全国人民代表大会选举并有权罢免全国人民代表大会常务委员会的组成人员。 全国人民代表大会常务委员会的组成人员不得担任国家行政机关、监察机关、审判机关和检察机关的职务。</p><p><strong>第六十六条</strong></p><p>全国人民代表大会常务委员会每届任期同全国人民代表大会每届任期相同，它行使职权到下届全国人民代表大会选出新的常务委员会为止。 委员长、副委员长连续任职不得超过两届。</p><p><strong>第六十七条</strong></p><p>全国人民代表大会常务委员会行使下列职权： </p><ul><li>（一）解释宪法，监督宪法的实施； </li><li>（二）制定和修改除应当由全国人民代表大会制定的法律以外的其他法律； </li><li>（三）在全国人民代表大会闭会期间，对全国人民代表大会制定的法律进行部分补充和修改，但是不得同该法律的基本原则相抵触； </li><li>（四）解释法律； </li><li>（五）在全国人民代表大会闭会期间，审查和批准国民经济和社会发展计划、国家预算在执行过程中所必须作的部分调整方案； </li><li>（六）监督国务院、中央军事委员会、国家监察委员会、最高人民法院和最高人民检察院的工作； </li><li>（七）撤销国务院制定的同宪法、法律相抵触的行政法规、决定和命令； </li><li>（八）撤销省、自治区、直辖市国家权力机关制定的同宪法、法律和行政法规相抵触的地方性法规和决议； </li><li>（九）在全国人民代表大会闭会期间，根据国务院总理的提名，决定部长、委员会主任、审计长、秘书长的人选； </li><li>（十）在全国人民代表大会闭会期间，根据中央军事委员会主席的提名，决定中央军事委员会其他组成人员的人选； </li><li>（十一）根据国家监察委员会主任的提请，任免国家监察委员会副主任、委员； </li><li>（十二）根据最高人民法院院长的提请，任免最高人民法院副院长、审判员、审判委员会委员和军事法院院长； </li><li>（十三）根据最高人民检察院检察长的提请，任免最高人民检察院副检察长、检察员、检察委员会委员和军事检察院检察长，并且批准省、自治区、直辖市的人民检察院检察长的任免； </li><li>（十四）决定驻外全权代表的任免； </li><li>（十五）决定同外国缔结的条约和重要协定的批准和废除； </li><li>（十六）规定军人和外交人员的衔级制度和其他专门衔级制度； </li><li>（十七）规定和决定授予国家的勋章和荣誉称号； </li><li>（十八）决定特赦； </li><li>（十九）在全国人民代表大会闭会期间，如果遇到国家遭受武装侵犯或者必须履行国际间共同防止侵略的条约的情况，决定战争状态的宣布； </li><li>（二十）决定全国总动员或者局部动员； </li><li>（二十一）决定全国或者个别省、自治区、直辖市进入紧急状态； </li><li>（二十二）全国人民代表大会授予的其他职权。</li></ul><p><strong>第六十八条</strong></p><p>全国人民代表大会常务委员会委员长主持全国人民代表大会常务委员会的工作，召集全国人民代表大会常务委员会会议。副委员长、秘书长协助委员长工作。 委员长、副委员长、秘书长组成委员长会议，处理全国人民代表大会常务委员会的重要日常工作。</p><p><strong>第六十九条</strong></p><p>全国人民代表大会常务委员会对全国人民代表大会负责并报告工作。</p><p><strong>第七十条</strong></p><p>全国人民代表大会设立民族委员会、宪法和法律委员会、财政经济委员会、教育科学文化卫生委员会、外事委员会、华侨委员会和其他需要设立的专门委员会。在全国人民代表大会闭会期间，各专门委员会受全国人民代表大会常务委员会的领导。 各专门委员会在全国人民代表大会和全国人民代表大会常务委员会领导下，研究、审议和拟订有关议案。</p><p><strong>第七十一条</strong></p><p>全国人民代表大会和全国人民代表大会常务委员会认为必要的时候，可以组织关于特定问题的调查委员会，并且根据调查委员会的报告，作出相应的决议。 调查委员会进行调查的时候，一切有关的国家机关、社会团体和公民都有义务向它提供必要的材料。</p><p><strong>第七十二条</strong></p><p>全国人民代表大会代表和全国人民代表大会常务委员会组成人员，有权依照法律规定的程序分别提出属于全国人民代表大会和全国人民代表大会常务委员会职权范围内的议案。</p><p><strong>第七十三条</strong></p><p>全国人民代表大会代表在全国人民代表大会开会期间，全国人民代表大会常务委员会组成人员在常务委员会开会期间，有权依照法律规定的程序提出对国务院或者国务院各部、各委员会的质询案。受质询的机关必须负责答复。</p><p><strong>第七十四条</strong></p><p>全国人民代表大会代表，非经全国人民代表大会会议主席团许可，在全国人民代表大会闭会期间非经全国人民代表大会常务委员会许可，不受逮捕或者刑事审判。</p><p><strong>第七十五条</strong></p><p>全国人民代表大会代表在全国人民代表大会各种会议上的发言和表决，不受法律追究。</p><p><strong>第七十六条</strong></p><p>全国人民代表大会代表必须模范地遵守宪法和法律，保守国家秘密，并且在自己参加的生产、工作和社会活动中，协助宪法和法律的实施。 全国人民代表大会代表应当同原选举单位和人民保持密切的联系，听取和反映人民的意见和要求，努力为人民服务。</p><p><strong>第七十七条</strong></p><p>全国人民代表大会代表受原选举单位的监督。原选举单位有权依照法律规定的程序罢免本单位选出的代表。</p><p><strong>第七十八条</strong></p><p>全国人民代表大会和全国人民代表大会常务委员会的组织和工作程序由法律规定。</p><p><strong>第七十九条</strong></p><p>中华人民共和国主席、副主席由全国人民代表大会选举。 有选举权和被选举权的年满四十五周岁的中华人民共和国公民可以被选为中华人民共和国主席、副主席。 中华人民共和国主席、副主席每届任期同全国人民代表大会每届任期相同。</p><p><strong>第八十条</strong></p><p>中华人民共和国主席根据全国人民代表大会的决定和全国人民代表大会常务委员会的决定，公布法律，任免国务院总理、副总理、国务委员、各部部长、各委员会主任、审计长、秘书长，授予国家的勋章和荣誉称号，发布特赦令，宣布进入紧急状态，宣布战争状态，发布动员令。</p><p><strong>第八十一条</strong></p><p>中华人民共和国主席代表中华人民共和国，进行国事活动，接受外国使节；根据全国人民代表大会常务委员会的决定，派遣和召回驻外全权代表，批准和废除同外国缔结的条约和重要协定。</p><p><strong>第八十二条</strong></p><p>中华人民共和国副主席协助主席工作。 中华人民共和国副主席受主席的委托，可以代行主席的部分职权。</p><p><strong>第八十三条</strong></p><p>中华人民共和国主席、副主席行使职权到下届全国人民代表大会选出的主席、副主席就职为止。</p><p><strong>第八十四条</strong></p><p>中华人民共和国主席缺位的时候，由副主席继任主席的职位。 中华人民共和国副主席缺位的时候，由全国人民代表大会补选。 中华人民共和国主席、副主席都缺位的时候，由全国人民代表大会补选；在补选以前，由全国人民代表大会常务委员会委员长暂时代理主席职位。</p><p><strong>第八十五条</strong></p><p>中华人民共和国国务院，即中央人民政府，是最高国家权力机关的执行机关，是最高国家行政机关。</p><p><strong>第八十六条</strong></p><p>国务院由下列人员组成： 总理， 副总理若干人， 国务委员若干人， 各部部长， 各委员会主任， 审计长， 秘书长。 国务院实行总理负责制。各部、各委员会实行部长、主任负责制。 国务院的组织由法律规定。</p><p><strong>第八十七条</strong></p><p>国务院每届任期同全国人民代表大会每届任期相同。 总理、副总理、国务委员连续任职不得超过两届。</p><p><strong>第八十八条</strong></p><p>总理领导国务院的工作。副总理、国务委员协助总理工作。 总理、副总理、国务委员、秘书长组成国务院常务会议。 总理召集和主持国务院常务会议和国务院全体会议。</p><p><strong>第八十九条</strong></p><p>国务院行使下列职权： </p><ul><li>（一）根据宪法和法律，规定行政措施，制定行政法规，发布决定和命令； </li><li>（二）向全国人民代表大会或者全国人民代表大会常务委员会提出议案； </li><li>（三）规定各部和各委员会的任务和职责，统一领导各部和各委员会的工作，并且领导不属于各部和各委员会的全国性的行政工作； </li><li>（四）统一领导全国地方各级国家行政机关的工作，规定中央和省、自治区、直辖市的国家行政机关的职权的具体划分； </li><li>（五）编制和执行国民经济和社会发展计划和国家预算； </li><li>（六）领导和管理经济工作和城乡建设、生态文明建设； </li><li>（七）领导和管理教育、科学、文化、卫生、体育和计划生育工作； </li><li>（八）领导和管理民政、公安、司法行政等工作； </li><li>（九）管理对外事务，同外国缔结条约和协定； </li><li>（十）领导和管理国防建设事业； </li><li>（十一）领导和管理民族事务，保障少数民族的平等权利和民族自治地方的自治权利； </li><li>（十二）保护华侨的正当的权利和利益，保护归侨和侨眷的合法的权利和利益； </li><li>（十三）改变或者撤销各部、各委员会发布的不适当的命令、指示和规章； </li><li>（十四）改变或者撤销地方各级国家行政机关的不适当的决定和命令； </li><li>（十五）批准省、自治区、直辖市的区域划分，批准自治州、县、自治县、市的建置和区域划分； </li><li>（十六）依照法律规定决定省、自治区、直辖市的范围内部分地区进入紧急状态； </li><li>（十七）审定行政机构的编制，依照法律规定任免、培训、考核和奖惩行政人员； </li><li>（十八）全国人民代表大会和全国人民代表大会常务委员会授予的其他职权。</li></ul><p><strong>第九十条</strong></p><p>国务院各部部长、各委员会主任负责本部门的工作；召集和主持部务会议或者委员会会议、委务会议，讨论决定本部门工作的重大问题。 各部、各委员会根据法律和国务院的行政法规、决定、命令，在本部门的权限内，发布命令、指示和规章。</p><p><strong>第九十一条</strong></p><p>国务院设立审计机关，对国务院各部门和地方各级政府的财政收支，对国家的财政金融机构和企业事业组织的财务收支，进行审计监督。 审计机关在国务院总理领导下，依照法律规定独立行使审计监督权，不受其他行政机关、社会团体和个人的干涉。</p><p><strong>第九十二条</strong></p><p>国务院对全国人民代表大会负责并报告工作；在全国人民代表大会闭会期间，对全国人民代表大会常务委员会负责并报告工作。</p><p><strong>第九十三条</strong></p><p>中华人民共和国中央军事委员会领导全国武装力量。 中央军事委员会由下列人员组成： 主席， 副主席若干人， 委员若干人。 中央军事委员会实行主席负责制。 中央军事委员会每届任期同全国人民代表大会每届任期相同。</p><p><strong>第九十四条</strong></p><p>中央军事委员会主席对全国人民代表大会和全国人民代表大会常务委员会负责。</p><p><strong>第九十五条</strong></p><p>省、直辖市、县、市、市辖区、乡、民族乡、镇设立人民代表大会和人民政府。 地方各级人民代表大会和地方各级人民政府的组织由法律规定。 自治区、自治州、自治县设立自治机关。自治机关的组织和工作根据宪法第三章第五节、第六节规定的基本原则由法律规定。</p><p><strong>第九十六条</strong></p><p>地方各级人民代表大会是地方国家权力机关。 县级以上的地方各级人民代表大会设立常务委员会。</p><p><strong>第九十七条</strong></p><p>省、直辖市、设区的市的人民代表大会代表由下一级的人民代表大会选举；县、不设区的市、市辖区、乡、民族乡、镇的人民代表大会代表由选民直接选举。 地方各级人民代表大会代表名额和代表产生办法由法律规定。</p><p><strong>第九十八条</strong></p><p>地方各级人民代表大会每届任期五年。</p><p><strong>第九十九条</strong></p><p>地方各级人民代表大会在本行政区域内，保证宪法、法律、行政法规的遵守和执行；依照法律规定的权限，通过和发布决议，审查和决定地方的经济建设、文化建设和公共事业建设的计划。 县级以上的地方各级人民代表大会审查和批准本行政区域内的国民经济和社会发展计划、预算以及它们的执行情况的报告；有权改变或者撤销本级人民代表大会常务委员会不适当的决定。 民族乡的人民代表大会可以依照法律规定的权限采取适合民族特点的具体措施。</p><p><strong>第一百条</strong></p><p>省、直辖市的人民代表大会和它们的常务委员会，在不同宪法、法律、行政法规相抵触的前提下，可以制定地方性法规，报全国人民代表大会常务委员会备案。 设区的市的人民代表大会和它们的常务委员会，在不同宪法、法律、行政法规和本省、自治区的地方性法规相抵触的前提下，可以依照法律规定制定地方性法规，报本省、自治区人民代表大会常务委员会批准后施行。</p><p><strong>第一百零一条</strong></p><p>地方各级人民代表大会分别选举并且有权罢免本级人民政府的省长和副省长、市长和副市长、县长和副县长、区长和副区长、乡长和副乡长、镇长和副镇长。 县级以上的地方各级人民代表大会选举并且有权罢免本级监察委员会主任、本级人民法院院长和本级人民检察院检察长。选出或者罢免人民检察院检察长，须报上级人民检察院检察长提请该级人民代表大会常务委员会批准。</p><p><strong>第一百零二条</strong></p><p>省、直辖市、设区的市的人民代表大会代表受原选举单位的监督；县、不设区的市、市辖区、乡、民族乡、镇的人民代表大会代表受选民的监督。 地方各级人民代表大会代表的选举单位和选民有权依照法律规定的程序罢免由他们选出的代表。</p><p><strong>第一百零三条</strong></p><p>县级以上的地方各级人民代表大会常务委员会由主任、副主任若干人和委员若干人组成，对本级人民代表大会负责并报告工作。 县级以上的地方各级人民代表大会选举并有权罢免本级人民代表大会常务委员会的组成人员。 县级以上的地方各级人民代表大会常务委员会的组成人员不得担任国家行政机关、监察机关、审判机关和检察机关的职务。</p><p><strong>第一百零四条</strong></p><p>县级以上的地方各级人民代表大会常务委员会讨论、决定本行政区域内各方面工作的重大事项；监督本级人民政府、监察委员会、人民法院和人民检察院的工作；撤销本级人民政府的不适当的决定和命令；撤销下一级人民代表大会的不适当的决议；依照法律规定的权限决定国家机关工作人员的任免；在本级人民代表大会闭会期间，罢免和补选上一级人民代表大会的个别代表。</p><p><strong>第一百零五条</strong></p><p>地方各级人民政府是地方各级国家权力机关的执行机关，是地方各级国家行政机关。 地方各级人民政府实行省长、市长、县长、区长、乡长、镇长负责制。</p><p><strong>第一百零六条</strong></p><p>地方各级人民政府每届任期同本级人民代表大会每届任期相同。</p><p><strong>第一百零七条</strong></p><p>县级以上地方各级人民政府依照法律规定的权限，管理本行政区域内的经济、教育、科学、文化、卫生、体育事业、城乡建设事业和财政、民政、公安、民族事务、司法行政、计划生育等行政工作，发布决定和命令，任免、培训、考核和奖惩行政工作人员。 乡、民族乡、镇的人民政府执行本级人民代表大会的决议和上级国家行政机关的决定和命令，管理本行政区域内的行政工作。 省、直辖市的人民政府决定乡、民族乡、镇的建置和区域划分。</p><p><strong>第一百零八条</strong></p><p>县级以上的地方各级人民政府领导所属各工作部门和下级人民政府的工作，有权改变或者撤销所属各工作部门和下级人民政府的不适当的决定。</p><p><strong>第一百零九条</strong></p><p>县级以上的地方各级人民政府设立审计机关。地方各级审计机关依照法律规定独立行使审计监督权，对本级人民政府和上一级审计机关负责。</p><p><strong>第一百一十条</strong></p><p>地方各级人民政府对本级人民代表大会负责并报告工作。县级以上的地方各级人民政府在本级人民代表大会闭会期间，对本级人民代表大会常务委员会负责并报告工作。 地方各级人民政府对上一级国家行政机关负责并报告工作。全国地方各级人民政府都是国务院统一领导下的国家行政机关，都服从国务院。</p><p><strong>第一百一十一条</strong></p><p>城市和农村按居民居住地区设立的居民委员会或者村民委员会是基层群众性自治组织。居民委员会、村民委员会的主任、副主任和委员由居民选举。居民委员会、村民委员会同基层政权的相互关系由法律规定。 居民委员会、村民委员会设人民调解、治安保卫、公共卫生等委员会，办理本居住地区的公共事务和公益事业，调解民间纠纷，协助维护社会治安，并且向人民政府反映群众的意见、要求和提出建议。</p><p><strong>第一百一十二条</strong></p><p>民族自治地方的自治机关是自治区、自治州、自治县的人民代表大会和人民政府。</p><p><strong>第一百一十三条</strong></p><p>自治区、自治州、自治县的人民代表大会中，除实行区域自治的民族的代表外，其他居住在本行政区域内的民族也应当有适当名额的代表。 自治区、自治州、自治县的人民代表大会常务委员会中应当有实行区域自治的民族的公民担任主任或者副主任。</p><p><strong>第一百一十四条</strong></p><p>自治区主席、自治州州长、自治县县长由实行区域自治的民族的公民担任。</p><p><strong>第一百一十五条</strong></p><p>自治区、自治州、自治县的自治机关行使宪法第三章第五节规定的地方国家机关的职权，同时依照宪法、民族区域自治法和其他法律规定的权限行使自治权，根据本地方实际情况贯彻执行国家的法律、政策。</p><p><strong>第一百一十六条</strong></p><p>民族自治地方的人民代表大会有权依照当地民族的政治、经济和文化的特点，制定自治条例和单行条例。自治区的自治条例和单行条例，报全国人民代表大会常务委员会批准后生效。自治州、自治县的自治条例和单行条例，报省或者自治区的人民代表大会常务委员会批准后生效，并报全国人民代表大会常务委员会备案。</p><p><strong>第一百一十七条</strong></p><p>民族自治地方的自治机关有管理地方财政的自治权。凡是依照国家财政体制属于民族自治地方的财政收入，都应当由民族自治地方的自治机关自主地安排使用。</p><p><strong>第一百一十八条</strong></p><p>民族自治地方的自治机关在国家计划的指导下，自主地安排和管理地方性的经济建设事业。 国家在民族自治地方开发资源、建设企业的时候，应当照顾民族自治地方的利益。</p><p><strong>第一百一十九条</strong></p><p>民族自治地方的自治机关自主地管理本地方的教育、科学、文化、卫生、体育事业，保护和整理民族的文化遗产，发展和繁荣民族文化。</p><p><strong>第一百二十条</strong></p><p>民族自治地方的自治机关依照国家的军事制度和当地的实际需要，经国务院批准，可以组织本地方维护社会治安的公安部队。</p><p><strong>第一百二十一条</strong></p><p>民族自治地方的自治机关在执行职务的时候，依照本民族自治地方自治条例的规定，使用当地通用的一种或者几种语言文字。</p><p><strong>第一百二十二条</strong></p><p>国家从财政、物资、技术等方面帮助各少数民族加速发展经济建设和文化建设事业。 国家帮助民族自治地方从当地民族中大量培养各级干部、各种专业人才和技术工人。</p><p><strong>第一百二十三条</strong></p><p>中华人民共和国各级监察委员会是国家的监察机关。</p><p><strong>第一百二十四条</strong></p><p>中华人民共和国设立国家监察委员会和地方各级监察委员会。 监察委员会由下列人员组成： 主任， 副主任若干人， 委员若干人。 监察委员会主任每届任期同本级人民代表大会每届任期相同。国家监察委员会主任连续任职不得超过两届。 监察委员会的组织和职权由法律规定。</p><p><strong>第一百二十五条</strong></p><p>中华人民共和国国家监察委员会是最高监察机关。 国家监察委员会领导地方各级监察委员会的工作，上级监察委员会领导下级监察委员会的工作。</p><p><strong>第一百二十六条</strong></p><p>国家监察委员会对全国人民代表大会和全国人民代表大会常务委员会负责。地方各级监察委员会对产生它的国家权力机关和上一级监察委员会负责。</p><p><strong>第一百二十七条</strong></p><p>监察委员会依照法律规定独立行使监察权，不受行政机关、社会团体和个人的干涉。 监察机关办理职务违法和职务犯罪案件，应当与审判机关、检察机关、执法部门互相配合，互相制约。</p><p><strong>第一百二十八条</strong></p><p>中华人民共和国人民法院是国家的审判机关。</p><p><strong>第一百二十九条</strong></p><p>中华人民共和国设立最高人民法院、地方各级人民法院和军事法院等专门人民法院。 最高人民法院院长每届任期同全国人民代表大会每届任期相同，连续任职不得超过两届。 人民法院的组织由法律规定。</p><p><strong>第一百三十条</strong></p><p>人民法院审理案件，除法律规定的特别情况外，一律公开进行。被告人有权获得辩护。</p><p><strong>第一百三十一条</strong></p><p>人民法院依照法律规定独立行使审判权，不受行政机关、社会团体和个人的干涉。</p><p><strong>第一百三十二条</strong></p><p>最高人民法院是最高审判机关。 最高人民法院监督地方各级人民法院和专门人民法院的审判工作，上级人民法院监督下级人民法院的审判工作。</p><p><strong>第一百三十三条</strong></p><p>最高人民法院对全国人民代表大会和全国人民代表大会常务委员会负责。地方各级人民法院对产生它的国家权力机关负责。</p><p><strong>第一百三十四条</strong></p><p>中华人民共和国人民检察院是国家的法律监督机关。</p><p><strong>第一百三十五条</strong></p><p>中华人民共和国设立最高人民检察院、地方各级人民检察院和军事检察院等专门人民检察院。 最高人民检察院检察长每届任期同全国人民代表大会每届任期相同，连续任职不得超过两届。 人民检察院的组织由法律规定。</p><p><strong>第一百三十六条</strong></p><p>人民检察院依照法律规定独立行使检察权，不受行政机关、社会团体和个人的干涉。</p><p><strong>第一百三十七条</strong></p><p>最高人民检察院是最高检察机关。 最高人民检察院领导地方各级人民检察院和专门人民检察院的工作，上级人民检察院领导下级人民检察院的工作。</p><p><strong>第一百三十八条</strong></p><p>最高人民检察院对全国人民代表大会和全国人民代表大会常务委员会负责。地方各级人民检察院对产生它的国家权力机关和上级人民检察院负责。</p><p><strong>第一百三十九条</strong></p><p>各民族公民都有用本民族语言文字进行诉讼的权利。人民法院和人民检察院对于不通晓当地通用的语言文字的诉讼参与人，应当为他们翻译。 在少数民族聚居或者多民族共同居住的地区，应当用当地通用的语言进行审理；起诉书、判决书、布告和其他文书应当根据实际需要使用当地通用的一种或者几种文字。</p><p><strong>第一百四十条</strong></p><p>人民法院、人民检察院和公安机关办理刑事案件，应当分工负责，互相配合，互相制约，以保证准确有效地执行法律。</p><h3 id="第四章-国旗、国歌、国徽、首都"><a href="#第四章-国旗、国歌、国徽、首都" class="headerlink" title="第四章　国旗、国歌、国徽、首都"></a>第四章　国旗、国歌、国徽、首都</h3><p><strong>第一百四十一条</strong></p><p>中华人民共和国国旗是五星红旗。 中华人民共和国国歌是《义勇军进行曲》。</p><p><strong>第一百四十二条</strong></p><p>中华人民共和国国徽，中间是五星照耀下的天安门，周围是谷穗和齿轮。</p><p><strong>第一百四十三条</strong></p><p>中华人民共和国首都是北京。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基本信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;发文字号：全国人民代表大会公告第1号&lt;/p&gt;
&lt;p&gt;效力级别：法律&lt;/p&gt;
&lt;p&gt;时效性：现行有效&lt;/p&gt;
&lt;p&gt;发布日期：2018-03-11&lt;/p&gt;
&lt;p&gt;实施日期：2018-03-11&lt;/p&gt;
&lt;p&gt;发布机关：全国人民代表大会&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="法律" scheme="https://removeif.github.io/categories/%E6%B3%95%E5%BE%8B/"/>
    
    
      <category term="法律" scheme="https://removeif.github.io/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spring 如何解决循环依赖</title>
    <link href="https://removeif.github.io/2019/09/30/java/frame/Spring-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.html"/>
    <id>https://removeif.github.io/2019/09/30/java/frame/Spring-如何解决循环依赖.html</id>
    <published>2019-09-30T10:04:09.000Z</published>
    <updated>2019-09-30T10:08:24.068Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过程演练"><a href="#过程演练" class="headerlink" title="过程演练"></a>过程演练</h3><p>关于Spring bean的创建，其本质上还是一个对象的创建，既然是对象，读者朋友一定要明白一点就是，一个完整的对象包含两部分：当前<code>对象实例化</code>和<code>对象属性的实例化</code>。在Spring中，对象的实例化是通过反射实现的，而对象的属性则是在对象实例化之后通过一定的方式设置的。这个过程可以按照如下方式进行理解：<br><a id="more"></a></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20190930170006.png" alt=""></p><p>理解这一个点之后，对于循环依赖的理解就已经帮助一大步了，我们这里以两个类A和B为例进行讲解，如下是A和B的声明：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">private</span> B b;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(B b)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">private</span> A a;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setA</span><span class="hljs-params">(A a)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里A和B中各自都以对方为自己的全局属性。这里首先需要说明的一点，Spring实例化bean是通过ApplicationContext.getBean()方法来进行的。</p><p>如果要获取的对象依赖了另一个对象，那么其首先会创建当前对象，然后通过递归的调用ApplicationContext.getBean()方法来获取所依赖的对象，最后将获取到的对象注入到当前对象中。</p><p>这里我们以上面的首先初始化A对象实例为例进行讲解。</p><p>首先Spring尝试通过ApplicationContext.getBean()方法获取A对象的实例，由于Spring容器中还没有A对象实例，因而其会创建一个A对象</p><p>然后发现其依赖了B对象，因而会尝试递归的通过ApplicationContext.getBean()方法获取B对象的实例</p><p>但是Spring容器中此时也没有B对象的实例，因而其还是会先创建一个B对象的实例。</p><p>读者需要注意这个时间点，此时A对象和B对象都已经创建了，并且保存在Spring容器中了，只不过A对象的属性b和B对象的属性a都还没有设置进去。</p><p>在前面Spring创建B对象之后，Spring发现B对象依赖了属性A，因而还是会尝试递归的调用ApplicationContext.getBean()方法获取A对象的实例</p><p>因为Spring中已经有一个A对象的实例，虽然只是半成品（其属性b还未初始化），但其也还是目标bean，因而会将该A对象的实例返回。</p><p>此时，B对象的属性a就设置进去了，然后还是ApplicationContext.getBean()方法递归的返回，也就是将B对象的实例返回，此时就会将该实例设置到A对象的属性b中。</p><p>这个时候，注意A对象的属性b和B对象的属性a都已经设置了目标对象的实例了</p><p>读者朋友可能会比较疑惑的是，前面在为对象B设置属性a的时候，这个A类型属性还是个半成品。但是需要注意的是，这个A是一个引用，其本质上还是最开始就实例化的A对象。</p><p>而在上面这个递归过程的最后，Spring将获取到的B对象实例设置到了A对象的属性b中了</p><p>这里的A对象其实和前面设置到实例B中的半成品A对象是同一个对象，其引用地址是同一个，这里为A对象的b属性设置了值，其实也就是为那个半成品的a属性设置了值。</p><p>下面我们通过一个流程图来对这个过程进行讲解：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20190930170624.png" alt=""></p><p>图中getBean()表示调用Spring的ApplicationContext.getBean()方法，而该方法中的参数，则表示我们要尝试获取的目标对象。</p><p>图中的黑色箭头表示一开始的方法调用走向，走到最后，返回了Spring中缓存的A对象之后，表示递归调用返回了，此时使用绿色的箭头表示。</p><p>从图中我们可以很清楚的看到，B对象的a属性是在第三步中注入的半成品A对象，而A对象的b属性是在第二步中注入的成品B对象，此时半成品的A对象也就变成了成品的A对象，因为其属性已经设置完成了。</p><h3 id="源码讲解"><a href="#源码讲解" class="headerlink" title="源码讲解"></a>源码讲解</h3><p>对于Spring处理循环依赖问题的方式，我们这里通过上面的流程图其实很容易就可以理解</p><p>需要注意的一个点，Spring是如何标记开始生成的A对象是一个半成品，并且是如何保存A对象的。</p><p>这里的标记工作Spring是使用ApplicationContext的属性SetsingletonsCurrentlyInCreation来保存的，而半成品的A对象则是通过MapsingletonFactories来保存的</p><p>这里的ObjectFactory是一个工厂对象，可通过调用其getObject()方法来获取目标对象。在AbstractBeanFactory.doGetBean()方法中获取对象的方法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span>  T <span class="hljs-title">doGetBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name, @Nullable <span class="hljs-keyword">final</span> Class requiredType,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    @Nullable <span class="hljs-keyword">final</span> Object[] args, <span class="hljs-keyword">boolean</span> typeCheckOnly)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 尝试通过bean名称获取目标bean对象，比如这里的A对象</span></span><br><span class="line">  Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  <span class="hljs-comment">// 我们这里的目标对象都是单例的</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 这里就尝试创建目标对象，第二个参数传的就是一个ObjectFactory类型的对象，这里是使用Java8的lamada</span></span><br><span class="line">    <span class="hljs-comment">// 表达式书写的，只要上面的getSingleton()方法返回值为空，则会调用这里的getSingleton()方法来创建</span></span><br><span class="line">    <span class="hljs-comment">// 目标对象</span></span><br><span class="line">    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">      <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// 尝试创建目标对象</span></span><br><span class="line">        <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">      &#125; <span class="hljs-keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的doGetBean()方法是非常关键的一个方法（中间省略了其他代码），上面也主要有两个步骤</p><p>第一个步骤的getSingleton()方法的作用是尝试从缓存中获取目标对象，如果没有获取到，则尝试获取半成品的目标对象；如果第一个步骤没有获取到目标对象的实例，那么就进入第二个步骤</p><p>第二个步骤的getSingleton()方法的作用是尝试创建目标对象，并且为该对象注入其所依赖的属性。</p><p>这里其实就是主干逻辑，我们前面图中已经标明，在整个过程中会调用三次doGetBean()方法</p><p>第一次调用的时候会尝试获取A对象实例，此时走的是第一个getSingleton()方法，由于没有已经创建的A对象的成品或半成品，因而这里得到的是null</p><p>然后就会调用第二个getSingleton()方法，创建A对象的实例，然后递归的调用doGetBean()方法，尝试获取B对象的实例以注入到A对象中</p><p>此时由于Spring容器中也没有B对象的成品或半成品，因而还是会走到第二个getSingleton()方法，在该方法中创建B对象的实例</p><p>创建完成之后，尝试获取其所依赖的A的实例作为其属性，因而还是会递归的调用doGetBean()方法</p><p>此时需要注意的是，在前面由于已经有了一个半成品的A对象的实例，因而这个时候，再尝试获取A对象的实例的时候，会走第一个getSingleton()方法</p><p>在该方法中会得到一个半成品的A对象的实例，然后将该实例返回，并且将其注入到B对象的属性a中，此时B对象实例化完成。</p><p>然后，将实例化完成的B对象递归的返回，此时就会将该实例注入到A对象中，这样就得到了一个成品的A对象。</p><p>我们这里可以阅读上面的第一个getSingleton()方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">// 尝试从缓存中获取成品的目标对象，如果存在，则直接返回</span></span><br><span class="line">  Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">// 如果缓存中不存在目标对象，则判断当前对象是否已经处于创建过程中，在前面的讲解中，第一次尝试获取A对象</span></span><br><span class="line">  <span class="hljs-comment">// 的实例之后，就会将A对象标记为正在创建中，因而最后再尝试获取A对象的时候，这里的if判断就会为true</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">      singletonObject = <span class="hljs-keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">      <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 这里的singletonFactories是一个Map，其key是bean的名称，而值是一个ObjectFactory类型的</span></span><br><span class="line">        <span class="hljs-comment">// 对象，这里对于A和B而言，调用图其getObject()方法返回的就是A和B对象的实例，无论是否是半成品</span></span><br><span class="line">        ObjectFactory singletonFactory = <span class="hljs-keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">        <span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="hljs-comment">// 获取目标对象的实例</span></span><br><span class="line">          singletonObject = singletonFactory.getObject();</span><br><span class="line">          <span class="hljs-keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">          <span class="hljs-keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们会存在一个问题就是A的半成品实例是如何实例化的，然后是如何将其封装为一个ObjectFactory类型的对象，并且将其放到上面的singletonFactories属性中的。</p><p>这主要是在前面的第二个getSingleton()方法中，其最终会通过其传入的第二个参数，从而调用createBean()方法，该方法的最终调用是委托给了另一个doCreateBean()方法进行的</p><p>这里面有如下一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd, <span class="hljs-keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="hljs-function">  <span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 实例化当前尝试获取的bean对象，比如A对象和B对象都是在这里实例化的</span></span><br><span class="line">  BeanWrapper instanceWrapper = <span class="hljs-keyword">null</span>;</span><br><span class="line">  <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    instanceWrapper = <span class="hljs-keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 判断Spring是否配置了支持提前暴露目标bean，也就是是否支持提前暴露半成品的bean</span></span><br><span class="line">  <span class="hljs-keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="hljs-keyword">this</span>.allowCircularReferences </span><br><span class="line">    &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">  <span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 如果支持，这里就会将当前生成的半成品的bean放到singletonFactories中，这个singletonFactories</span></span><br><span class="line">    <span class="hljs-comment">// 就是前面第一个getSingleton()方法中所使用到的singletonFactories属性，也就是说，这里就是</span></span><br><span class="line">    <span class="hljs-comment">// 封装半成品的bean的地方。而这里的getEarlyBeanReference()本质上是直接将放入的第三个参数，也就是</span></span><br><span class="line">    <span class="hljs-comment">// 目标bean直接返回</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 在初始化实例之后，这里就是判断当前bean是否依赖了其他的bean，如果依赖了，</span></span><br><span class="line">    <span class="hljs-comment">// 就会递归的调用getBean()方法尝试获取目标bean</span></span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">  &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="hljs-comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，Spring整个解决循环依赖问题的实现思路已经比较清楚了。对于整体过程，读者朋友只要理解两点：</p><ul><li>Spring是通过递归的方式获取目标bean及其所依赖的bean的；</li><li>Spring实例化一个bean的时候，是分两步进行的，首先实例化目标bean，然后为其注入属性。</li></ul><p>结合这两点，也就是说，Spring在实例化一个bean的时候，是首先递归的实例化其所依赖的所有bean，直到某个bean没有依赖其他bean，此时就会将该实例返回，然后反递归的将获取到的bean设置为各个上层bean的属性的。</p><p>参考文章:<br><a href="https://my.oschina.net/zhangxufeng/blog/3096394" target="_blank" rel="noopener">参考链接1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;过程演练&quot;&gt;&lt;a href=&quot;#过程演练&quot; class=&quot;headerlink&quot; title=&quot;过程演练&quot;&gt;&lt;/a&gt;过程演练&lt;/h3&gt;&lt;p&gt;关于Spring bean的创建，其本质上还是一个对象的创建，既然是对象，读者朋友一定要明白一点就是，一个完整的对象包含两部分：当前&lt;code&gt;对象实例化&lt;/code&gt;和&lt;code&gt;对象属性的实例化&lt;/code&gt;。在Spring中，对象的实例化是通过反射实现的，而对象的属性则是在对象实例化之后通过一定的方式设置的。这个过程可以按照如下方式进行理解：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://removeif.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://removeif.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="spring" scheme="https://removeif.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring cloud feign重试问题排查</title>
    <link href="https://removeif.github.io/2019/09/27/java/frame/Spring-cloud-feign%E9%87%8D%E8%AF%95%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.html"/>
    <id>https://removeif.github.io/2019/09/27/java/frame/Spring-cloud-feign重试问题排查.html</id>
    <published>2019-09-27T10:28:26.000Z</published>
    <updated>2019-10-21T03:23:49.087Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Feign设置超时时间"><a href="#Feign设置超时时间" class="headerlink" title="Feign设置超时时间"></a>Feign设置超时时间</h3><p>使用<code>Feign调用</code>接口分两层，<code>ribbon的调用</code>和<code>hystrix的调用</code>，所以ribbon的超时时间和Hystrix的超时时间的结合就是Feign的超时时间。</p><p>Spring Cloud应用在启动时，Feign会扫描标有@FeignClient注解的接口，生成代理，并注册到Spring容器中。生成代理时Feign会为每个接口方法创建一个RequetTemplate对象，该对象封装了HTTP请求需要的全部信息，请求参数名、请求方法等信息都是在这个过程中确定的，Feign的模板化就体现在这里。<br><a id="more"></a></p><p>配置超时时间：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#hystrix的超时时间</span></span><br><span class="line"><span class="hljs-attr">hystrix:</span></span><br><span class="line"><span class="hljs-attr">    command:</span></span><br><span class="line"><span class="hljs-attr">        default:</span></span><br><span class="line"><span class="hljs-attr">            execution:</span></span><br><span class="line"><span class="hljs-attr">              timeout:</span></span><br><span class="line"><span class="hljs-attr">                enabled:</span> <span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-attr">              isolation:</span></span><br><span class="line"><span class="hljs-attr">                    thread:</span></span><br><span class="line"><span class="hljs-attr">                        timeoutInMilliseconds:</span> <span class="hljs-number">9000</span></span><br><span class="line"><span class="hljs-comment">#ribbon的超时时间</span></span><br><span class="line"><span class="hljs-attr">ribbon:</span></span><br><span class="line"><span class="hljs-attr">  ReadTimeout:</span> <span class="hljs-number">3000</span></span><br><span class="line"><span class="hljs-attr">  ConnectTimeout:</span> <span class="hljs-number">3000</span></span><br></pre></td></tr></table></figure><p>要开启Feign的重试机制如下：（Feign默认重试五次 源码中有）</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">Retryer <span class="hljs-title">feignRetryer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> Retryer.Default();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ribbon的重试机制"><a href="#ribbon的重试机制" class="headerlink" title="ribbon的重试机制"></a>ribbon的重试机制</h3><p>设置重试次数：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">ribbon:</span></span><br><span class="line"><span class="hljs-attr">  ReadTimeout:</span> <span class="hljs-number">3000</span></span><br><span class="line"><span class="hljs-attr">  ConnectTimeout:</span> <span class="hljs-number">3000</span></span><br><span class="line"><span class="hljs-attr">  MaxAutoRetries:</span> <span class="hljs-number">1</span> <span class="hljs-comment">#同一台实例最大重试次数,不包括首次调用</span></span><br><span class="line"><span class="hljs-attr">  MaxAutoRetriesNextServer:</span> <span class="hljs-number">1</span> <span class="hljs-comment">#重试负载均衡其他的实例最大重试次数,不包括首次调用</span></span><br><span class="line"><span class="hljs-attr">  OkToRetryOnAllOperations:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#是否所有操作都重试</span></span><br></pre></td></tr></table></figure><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><ul><li><p>根据上面的参数计算重试的次数：<code>MaxAutoRetries+MaxAutoRetriesNextServer+(MaxAutoRetries *MaxAutoRetriesNextServer)</code> 即重试3次 则一共产生4次调用。<br>如果在重试期间，时间超过了hystrix的超时时间，便会立即执行熔断，调用fallback。所以要根据上面配置的参数计算hystrix的超时时间，使得在重试期间不能达到hystrix的超时时间，不然重试机制就会没有意义。<br>hystrix超时时间的计算： <code>(1 + MaxAutoRetries + MaxAutoRetriesNextServer) * ReadTimeout</code> 即按照以上的配置 hystrix的超时时间应该配置为 （1+1+1）*3=9秒。</p></li><li><p>当ribbon超时后且hystrix没有超时，便会采取重试机制。当<code>OkToRetryOnAllOperations</code>设置为false时，只会对get请求进行重试。如果设置为true，便会对所有的请求进行重试，如果是put或post等写操作，如果服务器接口没做幂等性，会产生不好的结果，所以OkToRetryOnAllOperations慎用。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> RequestSpecificRetryHandler <span class="hljs-title">getRequestSpecificRetryHandler</span><span class="hljs-params">(FeignLoadBalancer.RibbonRequest request, IClientConfig requestConfig)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> ((Boolean)<span class="hljs-keyword">this</span>.clientConfig.get(CommonClientConfigKey.OkToRetryOnAllOperations, <span class="hljs-keyword">false</span>)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RequestSpecificRetryHandler(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">this</span>.getRetryHandler(), requestConfig);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> !request.toRequest().method().equals(<span class="hljs-string">"GET"</span>) ? <span class="hljs-keyword">new</span> RequestSpecificRetryHandler(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">this</span>.getRetryHandler(), requestConfig) : <span class="hljs-keyword">new</span> RequestSpecificRetryHandler(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">this</span>.getRetryHandler(), requestConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果不配置ribbon的重试次数，默认会重试一次。<br>默认情况下,GET方式请求无论是连接异常还是读取异常,都会进行重试<br>非GET方式请求,只有连接异常时,才会进行重试</p></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>在使用重试机制的时候，对于接口尽量保证做到<code>幂等性</code>，对于多次的请求达同样的效果。</li><li>对于接口耗时比较久的，做好重复提交的验证，如redis锁住第一次提交，没处理完时，让后面的提交失败。避免重复提交。</li><li>计算好Hystrix的超时时间，以及Feign的超时以及重试时间，避免产生fallback。</li><li>当线上出现比较奇怪的问题时，排查半天都找不问题时，去查下框架的相关设置，如超时、重试的等机制。</li></ul><p>参考文章:<br><a href="https://blog.csdn.net/east123321/article/details/82385816" target="_blank" rel="noopener">参考链接1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Feign设置超时时间&quot;&gt;&lt;a href=&quot;#Feign设置超时时间&quot; class=&quot;headerlink&quot; title=&quot;Feign设置超时时间&quot;&gt;&lt;/a&gt;Feign设置超时时间&lt;/h3&gt;&lt;p&gt;使用&lt;code&gt;Feign调用&lt;/code&gt;接口分两层，&lt;code&gt;ribbon的调用&lt;/code&gt;和&lt;code&gt;hystrix的调用&lt;/code&gt;，所以ribbon的超时时间和Hystrix的超时时间的结合就是Feign的超时时间。&lt;/p&gt;
&lt;p&gt;Spring Cloud应用在启动时，Feign会扫描标有@FeignClient注解的接口，生成代理，并注册到Spring容器中。生成代理时Feign会为每个接口方法创建一个RequetTemplate对象，该对象封装了HTTP请求需要的全部信息，请求参数名、请求方法等信息都是在这个过程中确定的，Feign的模板化就体现在这里。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://removeif.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://removeif.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="feign" scheme="https://removeif.github.io/tags/feign/"/>
    
      <category term="spring cloud" scheme="https://removeif.github.io/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>github page网站cdn优化加速</title>
    <link href="https://removeif.github.io/2019/09/25/tools/github-page%E7%BD%91%E7%AB%99cdn%E4%BC%98%E5%8C%96%E5%8A%A0%E9%80%9F.html"/>
    <id>https://removeif.github.io/2019/09/25/tools/github-page网站cdn优化加速.html</id>
    <published>2019-09-25T08:41:46.000Z</published>
    <updated>2019-09-25T08:58:06.949Z</updated>
    
    <content type="html"><![CDATA[<p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</p><p>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。<br><a id="more"></a></p><h3 id="图片加速"><a href="#图片加速" class="headerlink" title="图片加速"></a>图片加速</h3><p>关于图传以及GitHub作为图库的使用方法请参考文章：<a href="https://removeif.github.io/2019/06/20/博客图片上传picgo工具github图传使用.html">博客图片上传picgo工具github图传使用</a>。</p><p>在上面参考文章的基础之上只需要修改以下配置：<strong>（指定相关cdn域名）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20190925161709.png" alt=""></p><p>原来项目中使用了原来的方式，进行全局替换，<strong>Mac idea</strong>直接快捷键<code>command+shift+R</code>全局替换</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20190925162235.png" alt=""></p><p><strong>【ps：题外话】</strong>原来是统一用的GitHub的仓库中的图片，通过这样替换，可以看到图片统一管理是多么的重要，多么的方便管理操作。</p><p>至此，博客中的相关图片都加上了cdn。</p><h3 id="其余资源文件"><a href="#其余资源文件" class="headerlink" title="其余资源文件"></a>其余资源文件</h3><p>用法：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.png</span><br><span class="line">https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.css</span><br><span class="line">https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4</span><br></pre></td></tr></table></figure><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 加载任何Github发布、提交或分支</span><br><span class="line">https://cdn.jsdelivr.net/gh/user/repo@version/file</span><br><span class="line"></span><br><span class="line">// 加载 jQuery v3.2.1</span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js</span><br><span class="line"></span><br><span class="line">// 使用版本范围而不是特定版本</span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js</span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js</span><br><span class="line"></span><br><span class="line">// 完全省略该版本以获取最新版本</span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</span><br><span class="line"></span><br><span class="line">// 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成</span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js</span><br><span class="line"></span><br><span class="line">// 在末尾添加 / 以获取资源目录列表</span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery/</span><br></pre></td></tr></table></figure><p>至此，github page 博客基本需要加速的完成。</p><p>参考文章:<br><a href="https://blog.csdn.net/qq_36759224/article/details/86936453" target="_blank" rel="noopener">参考链接1</a><br><a href="https://blog.csdn.net/qq_36759224/article/details/98058240" target="_blank" rel="noopener">参考链接2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科&lt;/p&gt;
&lt;p&gt;放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具教程" scheme="https://removeif.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
      <category term="主题工具" scheme="https://removeif.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具教程" scheme="https://removeif.github.io/tags/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
