<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>辣椒の酱</title>
  
  <subtitle>尚未执佩剑，转眼即江湖</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://removeif.github.io/"/>
  <updated>2019-12-31T13:14:49.391Z</updated>
  <id>https://removeif.github.io/</id>
  
  <author>
    <name>辣椒の酱</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019年终总结</title>
    <link href="https://removeif.github.io/think/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html"/>
    <id>https://removeif.github.io/think/2019年终总结.html</id>
    <published>2019-12-31T13:05:49.000Z</published>
    <updated>2019-12-31T13:14:49.391Z</updated>
    
    <content type="html"><![CDATA[<p>时间过得太快了，感觉每天时间都不够用，一眨眼一年又过去了！<br><a id="more"></a></p><p>也没啥特总结的，就几句话：<br>革命尚未成功，还得加倍努力。<br>珍惜时间，珍惜生命，珍惜眼前人。<br>充满正能量的度过往后余生。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间过得太快了，感觉每天时间都不够用，一眨眼一年又过去了！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="think" scheme="https://removeif.github.io/categories/think/"/>
    
    
      <category term="think" scheme="https://removeif.github.io/tags/think/"/>
    
  </entry>
  
  <entry>
    <title>西安旅游攻略3日游</title>
    <link href="https://removeif.github.io/travel/%E8%A5%BF%E5%AE%89%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A53%E6%97%A5%E6%B8%B8.html"/>
    <id>https://removeif.github.io/travel/西安旅游攻略3日游.html</id>
    <published>2019-12-31T10:50:31.000Z</published>
    <updated>2019-12-31T13:20:41.730Z</updated>
    
    <content type="html"><![CDATA[<p>西安，长安！</p><a id="more"></a><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="陕西历史博物馆"><a href="#陕西历史博物馆" class="headerlink" title="陕西历史博物馆"></a>陕西历史博物馆</h3><p>之前很少坐火车，特别是长途的火车，想体验一下长时间的坐火车感受，选择了比较慢的K字头的绿皮火车，一路颠簸的去了西安，一整晚没睡着，简直太困了。预算够的话尽量选择高铁、动车、飞机，少花些时间在交通工具上，因为费时又费神。没特殊情况以后是再也不做慢车了😂。早上八点多到达<code>西安南站</code>，</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231164703.png" alt="西安南"></p><p>下车之后打开高德地图，因为提前预定了<code>陕西历史博物馆</code>的门票（有免费票-基本陈列物，对于普通人差不多就够了，比较专业人士可以预约购买另外两种票，好像分别30和270，在陕西历史博物馆公众号上预约购买），9.0-10.30入场的票。然后就导航去博物馆，发现有个公交车可以直接到，然后去站台没看到那公交，也不知道什么情况。来了一个去历史地铁站的大巴，然后就上了，比公交贵两块，感觉还行，挺方便。</p><p>下了大巴直接做地铁去了西安历史博物馆。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231164810.png" alt="西安历史博物馆"></p><p>到了历史博物馆后，预约票取票在西南口。和普通买票的地方分开的，不要排错了地方！人比较多，注意合理安排错峰时间。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231165004.png" alt="丝绸之路"></p><p>整个游览过程<strong>大概一个多小时</strong>。</p><p><strong>推荐指数：4星</strong></p><h3 id="小雁塔"><a href="#小雁塔" class="headerlink" title="小雁塔"></a>小雁塔</h3><p>之前马蜂窝上看到推荐的，现场刷身份证入场。免费。有小雁塔和一个博物馆，文物也是一些历史文物，还是值得一看，冬季去，里面腊梅正开着，很香。</p><div class="img-y"><br><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231165126.png" alt="小雁塔"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231165238.png" alt="腊梅"><br></div><p>整个游览过程<strong>大概一小时之内</strong>。</p><p><strong>推荐指数：3.5星</strong></p><h3 id="赛格购物中心"><a href="#赛格购物中心" class="headerlink" title="赛格购物中心"></a>赛格购物中心</h3><p>网红购物中心，6楼全是美食，又很多网红餐厅，没去吃，只点了一杯酸奶牛。没想象中那么震惊，说是最长的扶梯。结果是一层一层的，加起来最长。进门能够看到一个最大的室内瀑布，还挺美的。</p><div class="img-y"><br><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231165339.png" alt="室内瀑布"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231191239.png" alt="扶梯"><br></div> <p>整个游览过程<strong>因人而异，花不了多长时间</strong>。</p><p><strong>推荐指数：3.5星</strong></p><p>上面几个地方想个不远，游完就去了酒店。酒店在钟楼附近，办理好入住，大概1点左右，点了些外卖，吃了就睡了一会儿，前一天晚上基本没睡，太累了。大概4点多睡醒了，收拾收拾出门了。</p><h3 id="西安城墙"><a href="#西安城墙" class="headerlink" title="西安城墙"></a>西安城墙</h3><p>大概5点多，溜到了西安城墙的永宁门，也就是南门，东南西北都有门可以进入，每个门最晚<strong>入门时间不一样</strong>，提前查好。<code>门票54</code>，城墙上有<code>租自行车的45一人</code>，任何一个还车点都能还。城墙全长<strong>14KM</strong>左右，我走完用了<strong>2h.20min</strong>，还是比较快的，根据自己情况预算时间。建议一定晚上去，晚上城墙上有很多灯笼🏮，夜景很好，建议去走一圈，感觉很好，那种感觉就像是自己是皇帝一样，走在上面看着自己的江山。城墙上能够看到日落和月亮，选择好的天气去，真的很重要。</p><div class="img-x"><br>    <img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231165523.png" alt="城墙"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231191359.png" alt="灯笼"><br></div> <p>整个游览过程<strong>因人而异，2-4小时</strong>。</p><p><strong>推荐指数：4.5星</strong></p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>第二天报了团，强烈建议报中超旅行的团，<code>价格260（兵马俑+华清池+临潼博物馆+午饭）</code>，导游<code>张丽美</code>，感觉讲的超级好。报团可以很方便的接送去景区，以及推荐一些好的东西，讲解一些当地城市的真正旅游文化。</p><h3 id="兵马俑"><a href="#兵马俑" class="headerlink" title="兵马俑"></a>兵马俑</h3><p>为了错峰，上午去看了兵马俑。西安兵马俑必去 之地就不必多介绍了，自己去感受。看完兵马俑就去吃饭了。</p><div class="img-x"><br><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231165628.png" alt="兵马俑"><br></div><p>整个游览过程<strong>因人而异，2-4小时</strong>。</p><p><strong>推荐指数：4.5星</strong></p><h3 id="蓝田玉商场"><a href="#蓝田玉商场" class="headerlink" title="蓝田玉商场"></a>蓝田玉商场</h3><p>中午吃饭的时候，去逛了逛，蓝田玉产地，有手镯（妈妈），芙蓉玉（老婆、女朋友），给自己的妈妈，老婆买一个真的不能太好了。可以去逛下，离华清池不远，说是全是12315认证过得，比其他地方的便宜。<strong>通过历往经验来看导游的话多数情况都信不得，景区的商品10有8、9是坑，自己多辨别，提前上网多查查，不要被坑了，被导游的片面之词蒙蔽了！！！</strong></p><p><strong>推荐指数：4.6星</strong></p><h3 id="临潼博物馆"><a href="#临潼博物馆" class="headerlink" title="临潼博物馆"></a>临潼博物馆</h3><p>吃完饭就去了临潼博物馆，博物馆里的全是珍宝，CCTV9有专门报道，可以搜到，提前可以先看下纪录片。推荐细看金棺银椁，以及佛祖的舍利（异常珍贵）。提前准备一些<code>佛教相关</code>的物件（配饰等），可以免费得到<code>舍利的加持</code>！</p><p>整个游览过程<strong>1小时</strong>。</p><p><strong>推荐指数：4.6星</strong></p><h3 id="华清池"><a href="#华清池" class="headerlink" title="华清池"></a>华清池</h3><p>看了临潼博物馆后就去了华清池，因为冬季去的，景色并不太好。可以看看当时西安事变相关的一些遗址，以及蒋介石的藏身地（可以坐电瓶车上半山看，票价20，也可以爬上去，不远）。有个<code>长恨歌</code>，因为是冬季去的，没演出，推荐度很高，建议要去的时候查好季节，去看一下。骊山上有个烽火台，没上去，可以坐缆车，导游没推荐，性价比不高。</p><div class="img-x"><br>   <img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231165820.png" alt="长恨歌"><br></div><p>整个游览过程<strong>1-2小时</strong>。</p><p><strong>推荐指数：3.5星</strong></p><h3 id="驼铃传奇"><a href="#驼铃传奇" class="headerlink" title="驼铃传奇"></a>驼铃传奇</h3><p>可以说西安最值的一段体验了，每个季节演出场次不同，一天几场，一场60分钟。讲述了整个丝绸之路。票价200到400，虽然贵些，但是真的值得看。总共有12个屏幕，我见过的最大的屏幕了，切换场景时，观众席会旋转，体验很好，有真实的狼，骆驼，瀑布，暴雨，模拟雪友情出演。</p><div class="img-x"><br>  <img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231170013.png" alt="开场"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231170157.png" alt="狼道"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231170335.png" alt="瀑布"><br></div><p>整个游览过程<strong>1小时</strong>。</p><p><strong>推荐指数：5星+1星</strong></p><h3 id="钟楼、鼓楼"><a href="#钟楼、鼓楼" class="headerlink" title="钟楼、鼓楼"></a>钟楼、鼓楼</h3><p>看完上面的，已经八九点了，晚上去看了下钟楼和鼓楼夜景，没上去，以及关门了。</p><div class="img-x"><br>    <img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231190757.png" alt="鼓楼旁边"><br></div><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="西安事变博物馆"><a href="#西安事变博物馆" class="headerlink" title="西安事变博物馆"></a>西安事变博物馆</h3><p>展现了整个西安事变的过程，以及张学友的一生，值得去看看，以史明鉴，铭记历史！</p><div class="img-x"><br><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231193609.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231193700.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231193734.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231193809.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231193904.png" alt=""><br></div><p>整个游览过程<strong>1小时</strong>。</p><p><strong>推荐指数：4.5星</strong></p><h3 id="牛羊肉泡沫"><a href="#牛羊肉泡沫" class="headerlink" title="牛羊肉泡沫"></a>牛羊肉泡沫</h3><p>老孙家（关东总店），挨着永兴坊不远，很值得去尝试一下。自己去体验下掰的过程。</p><p>吃法：服务员上了泡馍，自己掰成黄豆大小，给服务员加工。然后开吃，一口甜蒜，一口泡馍，简直不要太爽！</p><div class="img-x"><br>  <img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231184711.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231184820.png" alt=""><br></div><p>整个过程<strong>0.5-1小时</strong>。</p><p><strong>推荐指数：4.6星</strong></p><p>吃完泡馍就去北站坐车回去了，整个旅游结束！</p><h2 id="干货："><a href="#干货：" class="headerlink" title="干货："></a>干货：</h2><p><strong>提前准备</strong></p><ul><li>查好天气</li><li>提前预约票</li><li>选好季节</li><li>提前做好攻略</li><li>部分景点最好报团，自己计算性价比</li></ul><p><strong>导游车上问到长安三绝，居然没人知道，唉，提前没做好攻略。</strong></p><ul><li>兵马俑等四个博物馆</li><li>驼铃传奇</li><li>牛羊肉泡馍</li></ul><p><strong>导游讲解笔记小本本</strong></p><div class="img-y"><br>  <img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231183812.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231183842.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231183908.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231190410.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191231190444.png" alt=""><br></div><p><strong>敲黑板</strong><br><strong>导游的话不可全信，特别是推销当地特色商品时，不管说的多么天花乱坠都不要被蒙蔽了，保持清醒的头脑！</strong><br><strong>导游的话不可全信，特别是推销当地特色商品时，不管说的多么天花乱坠都不要被蒙蔽了，保持清醒的头脑！</strong><br><strong>导游的话不可全信，特别是推销当地特色商品时，不管说的多么天花乱坠都不要被蒙蔽了，保持清醒的头脑！</strong></p><p><strong>声明：</strong>以上评论全是自己的主观臆断，所有文字靠着记忆记录，如有错误欢迎指正。</p><p><em>写于2019.12.31，D1933高铁上。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;西安，长安！&lt;/p&gt;
    
    </summary>
    
    
      <category term="travel" scheme="https://removeif.github.io/categories/travel/"/>
    
    
      <category term="西安" scheme="https://removeif.github.io/tags/%E8%A5%BF%E5%AE%89/"/>
    
      <category term="长安" scheme="https://removeif.github.io/tags/%E9%95%BF%E5%AE%89/"/>
    
      <category term="旅行" scheme="https://removeif.github.io/tags/%E6%97%85%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>一张图学会python3</title>
    <link href="https://removeif.github.io/python/%E4%B8%80%E5%BC%A0%E5%9B%BE%E5%AD%A6%E4%BC%9Apython3.html"/>
    <id>https://removeif.github.io/python/一张图学会python3.html</id>
    <published>2019-12-26T15:20:21.000Z</published>
    <updated>2019-12-26T15:30:13.020Z</updated>
    
    <content type="html"><![CDATA[<p>这张图包含了Python 3 几乎所有的知识点，包括输出、输入、变量、赋值、计算、模块、函数、参数、返回值、缩进、注释、for循环、条件判断、逻辑运算、字符串及格式化、转义字符、类型转换、列表，甚至也包含了点面向对象的应用（调用对象的方法）。</p><p>跟着这张图片一步一步学习，学会 Python指日可待！<br><a id="more"></a><br>正确查看方法，<code>右键图片-新便签页中打开链接-放大查看</code>  </p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226224343.png" alt="python3语法"><br><a href="https://github.com/coodict/python3-in-one-pic" target="_blank" rel="noopener">图片来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这张图包含了Python 3 几乎所有的知识点，包括输出、输入、变量、赋值、计算、模块、函数、参数、返回值、缩进、注释、for循环、条件判断、逻辑运算、字符串及格式化、转义字符、类型转换、列表，甚至也包含了点面向对象的应用（调用对象的方法）。&lt;/p&gt;
&lt;p&gt;跟着这张图片一步一步学习，学会 Python指日可待！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python3" scheme="https://removeif.github.io/categories/python3/"/>
    
    
      <category term="python3基础" scheme="https://removeif.github.io/tags/python3%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>hash冲突开放地址法rehash</title>
    <link href="https://removeif.github.io/java/basic/hash%E5%86%B2%E7%AA%81%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95rehash.html"/>
    <id>https://removeif.github.io/java/basic/hash冲突开放地址法rehash.html</id>
    <published>2019-12-26T15:16:04.000Z</published>
    <updated>2019-12-26T15:19:26.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hash碰撞"><a href="#Hash碰撞" class="headerlink" title="Hash碰撞"></a>Hash碰撞</h3><p>Hash函数就是将任意长度的输入转化成固定长度的输出的一类函数。</p><p>比如说我的输入是任意一个自然数（0,1,2,3…），而我要求经过一个函数后我的输出的数的范围要在0-9这样一个范围之间。<br><a id="more"></a><br><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226223745.png" alt=""></p><p>很容易想到，我们可以使用Hash函数：</p><p><code>Hash(key) = key % 10</code></p><p>其中key就是输入</p><p>在哈希表（散列表）里，Hash函数的作用就是将关键字Key转化为一个固定长度数组的下标，以便存取键值对&lt;Key,Value&gt;</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226223842.png" alt=""></p><p>当多个键（key）经过Hash函数处理后落在了同一个位置时怎么办呢？</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226224019.png" alt=""></p><p>此时使用链地址法可看：<a href="http://mp.weixin.qq.com/s?__biz=MzU1MDE4MzUxNA==&amp;mid=2247483679&amp;idx=1&amp;sn=4a51847fb40fafe418bca0b906a03e0a&amp;chksm=fba5362accd2bf3cba68324072863e93a354e65ecb1bdfb9f7dbd857af41f553b72d46b2cb36&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">神速Hash</a></p><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>用链表，来一个元素加一个，让这个位置存储一个指针，指向一个链表，让所有相同位置的元素都放在这个链表中</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226224507.png" alt=""></p><p>在存储的时候，如果多个元素被Hash到同一位置，那么就加入到该位置所指向的链表中，如果该位置没有元素，则为null(指向空)。</p><p>此图中6先放进去了，因为这个插入链表的时候要采用‘头插’的方式，也就是插入链表的最前面（图中里数组最近的元素）。</p><p>因为经常发生这样的事情：新加入的元素很可能被再次访问到，所以放到头的话，如果查找就不用再遍历链表了。</p><p><strong>rehash</strong></p><p>Hash函数设计的非常好，能够将元素均匀Hash（散列）开来，但是当我们实际存入的值越来越多的时候，这个链表也势必越来越长，那当我们进行查找的时候，势必就会遍历链表，是否效率也就越来越慢？</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226224731.png" alt=""></p><p>这样的话，随着链表的不断增长，查询某一个元素的时间也就增加了，如果链表长度远远大于数组长度，不就和用链表存储一样了吗？</p><p>对，现在只能扩大数组的长度大约为原来的两倍</p><p>然后选取一个相关的新的Hash函数（比如之前使用 key % m，现在只改变一下m的值）</p><p>将旧Hash表中所有的元素通过新的Hash函数计算出新的Hash值，并将其插入到新表中（仍然使用链表），这就叫rehash</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226224913.png" alt=""></p><p>这里的数组就扩大了近两倍，由于要大小要选素数，那就选原数组大小两倍后的第一个素数7，旧Hash表和新Hash表采用了不同的Hash函数，但相关，只是m的取值变了。</p><p><strong>什么时候开始rehash？</strong></p><p><strong>装载因子 α</strong> </p><p>我们可以定义这样一个变量 α = 所有元素个数/数组的大小，我们叫它装载因子吧，它代表着我们的Hash表（也就是数组）的装满程度，在这里也代表链表的平均长度。</p><p>比如说，我们的数组大小为 5 ，我们给里面存入 3个元素，那么 α = 3/5 =0.6， 这个Hash表装满程度为60%，平均每条链有0.6个元素，当然 α 也可以等于和大于 1。</p><p>这个装载因子代表了Hash表的装满程度，这里也可以代表链表的平均长度，那么也就可以代表查询时的时间长短了</p><p>基于此，我们为了不让查询时间长，也就是查询性能低，我们可以设置一个临界 α 值，当随着存入元素导致 α 大于这个临界 α 值的时候</p><p>我们可以通过rehash来调整当前的 α 值，使之低于我们设定的 临界 α 值，从而使我们的查询性能保持在较好的范围之内</p><p>比如说，我们设定 临界 α = 0.7，对于一个Hash表大小为<strong>5</strong>的Hash表而言</p><p>当存入存入第四个元素的时候，α 就超出了临界 α 值，我们可以将数组长度变为11进行rehash（因为11是原表两倍后的第一个素数），使得装载因子 α 小于 0.7</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226225339.png" alt=""></p><p>通过rehash我们可以使得装载因子在一定范围内，那我们的查询性能也就得到了保证了</p><p><strong>那这个 临界的 α 值应该选择多大呢？</strong></p><p>这个 临界 α 如果选的小了，那数组的空间利用率就会太低，就比如说数组大小为100，α = 0.01，那装满程度为1%，99%还没有被利用</p><p>如果 α 太大了，那冲突就会很多，比如说 数组大小为 5，α = 10, 那平均每条链有10个元素，装满程度为1000%</p><p>即使Hash函数设计的合理，基本上每次存放元素的时候就会冲突，所以鉴于两者之间我觉得 0.6 - 0.9 之间是一个不错的选择，不妨选0.75。</p><h3 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h3><p>所谓开放地址法就是发生冲突时在散列表（也就是数组里）里去寻找合适的位置存取对应的元素。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226225818.png" alt=""></p><p>合适的位置该怎么找呢？</p><h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><p>最容易想到的就是当前位置冲突了，那我就去找相邻的下一个位置。</p><p>就拿放入元素举例吧，当你放入&lt;a,101&gt;到下标为2的位置后，另一个&lt;c,103&gt;键值对也落入了这个位置，那么它就向后依次加一寻找合适的位置，然后把&lt;c,103&gt;放入进去。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226225952.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226230006.png" alt=""></p><p>我们把这种方法称作线性探测法,我们可以将Hash以及寻找位置的过程抽象成一个函数：</p><p><code>hash(key) = (hash1(key) + i) % 7,i=0,1,2,...6</code></p><p>所以关键字要进行查找或者插入，首先看(hash1(key)+0)%7 位置是自己最终的位置吗？如果有冲突，就探测（查看）下一个位置:(hash1(key)+1)%7。依次进行</p><blockquote><p>所谓探测，就是在插入的时候检查哪个位置可以插入，或者查找时查找哪个位置是要查找的键值对，本质就是探寻这个键值对最终的位置。    </p></blockquote><p>但是这样会有一个问题，就是随着键值对的增多，会在哈希表里形成连续的键值对</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226230227.png" alt=""></p><p>这样的话，当插入元素时，任意一个落入这个区间的元素都要一直探测到区间末尾，并且最终将自己加入到这个区间内。这样就会导致落在区间内的关键字Key要进行多次探测才能找到合适的位置，并且还会继续增大这个连续区间，使探测时间变得更长，这样的现象被称为“一次聚集（primary clustering）”</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226230319.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226230333.png" alt=""></p><h4 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h4><p>我们可以在探测时不一个挨着一个地向后探测，我们可以跳跃着探测，这样就避免了一次聚集。</p><p>其实我们可以让它按照 i^2 的规律来跳跃探测</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226230416.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226230440.png" alt=""></p><p>这样的话，元素就不会聚集在某一块区域了，我们把这种方法称为平方探测法</p><p>同样我们可以抽象成下面的函数：</p><p><code>hash(key) = (hash1(key) + i^2) % 7,i=0,1,2,...6</code></p><p>其实可以扩展到更一般的形式：</p><p><code>hash(key) = (hash1(key) +c1i+c2 i^2) % 7,i=0,1,2,...6</code></p><p>虽然平方探测法解决了线性探测法的一次聚集，但是它也有一个小问题，就是关键字key散列到同一位置后探测时的路径是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226230630.png" alt=""></p><p>这样对于许多落在同一位置的关键字而言，越是后面插入的元素，探测的时间就越长。</p><p>这种现象被称作“二次聚集(secondary clustering)”,其实这个在线性探测法里也有。</p><p>这种现象出现的原因是由于对于落在同一个位置的关键字我们采取了一个依赖 i 的函数（i或者i^2）来进行探测，它不会因为关键字的不同或其他因素而改变探测的路径。那么我们是不是可以让探测的方法依赖于关键字呢？</p><h4 id="双散列"><a href="#双散列" class="headerlink" title="双散列"></a>双散列</h4><p>答案是可以的，我们可以再弄另外一个Hash函数，对落在同一个位置的关键字进行再次的Hash,探测的时候就用依赖这个Hash值去探测，比如我们可以使用下面的函数：</p><p><code>hash(key) = (hash1(key) +hash2(key)*i) % 7,i=0,1,2,...6</code></p><p>经过hash1的散列后，会定位到某一个地址，如果这个地址冲突，那么就按照1<em>hash2(key)、2</em>hash2(key)… 的偏移去探测合适的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191226230925.png" alt=""></p><p>由于Hash2函数不同于Hash1,所以两个不同的关键字Hash1值和Hash2值同时相同的概率就会变得非常低。</p><p>这样就避免了二次聚集，但同时也付出了计算另一个散列函数Hash2的代价。</p><p>如果hash2(key)=0,那探测不就一直在原地不动，失效了吗？</p><p>所以hash2函数在选择的时候要避免这种情况。</p><p>参考文章:<br><a href="https://mp.weixin.qq.com/s/yTEs1rlRFCnCNrVlX_ul4Q" target="_blank" rel="noopener">参考链接1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hash碰撞&quot;&gt;&lt;a href=&quot;#Hash碰撞&quot; class=&quot;headerlink&quot; title=&quot;Hash碰撞&quot;&gt;&lt;/a&gt;Hash碰撞&lt;/h3&gt;&lt;p&gt;Hash函数就是将任意长度的输入转化成固定长度的输出的一类函数。&lt;/p&gt;
&lt;p&gt;比如说我的输入是任意一个自然数（0,1,2,3…），而我要求经过一个函数后我的输出的数的范围要在0-9这样一个范围之间。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://removeif.github.io/categories/java/"/>
    
      <category term="java基础" scheme="https://removeif.github.io/categories/java/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="hash冲突" scheme="https://removeif.github.io/tags/hash%E5%86%B2%E7%AA%81/"/>
    
      <category term="rehash" scheme="https://removeif.github.io/tags/rehash/"/>
    
  </entry>
  
  <entry>
    <title>算法成长之路leetcode13-14</title>
    <link href="https://removeif.github.io/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode13-14.html"/>
    <id>https://removeif.github.io/algorithm/算法成长之路leetcode13-14.html</id>
    <published>2019-12-24T14:47:34.000Z</published>
    <updated>2019-12-24T15:20:48.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. Roman to Integer</a></h3><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br><a id="more"></a></p><table><thead><tr><th style="text-align:left">Symbol</th><th style="text-align:left">Value</th></tr></thead><tbody><tr><td style="text-align:left">I</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">V</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">X</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">L</td><td style="text-align:left">50</td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">D</td><td style="text-align:left">500</td></tr><tr><td style="text-align:left">M</td><td style="text-align:left">1000</td></tr></tbody></table><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L = 50, V= 5, III = 3.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure><h4 id="JAVA题解"><a href="#JAVA题解" class="headerlink" title="JAVA题解"></a>JAVA题解</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 字符          数值</span></span><br><span class="line"><span class="hljs-comment"> * I             1</span></span><br><span class="line"><span class="hljs-comment"> * V             5</span></span><br><span class="line"><span class="hljs-comment"> * X             10</span></span><br><span class="line"><span class="hljs-comment"> * L             50</span></span><br><span class="line"><span class="hljs-comment"> * C             100</span></span><br><span class="line"><span class="hljs-comment"> * D             500</span></span><br><span class="line"><span class="hljs-comment"> * M             1000</span></span><br><span class="line"><span class="hljs-comment"> * 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，</span></span><br><span class="line"><span class="hljs-comment"> * 例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，</span></span><br><span class="line"><span class="hljs-comment"> * 所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。</span></span><br><span class="line"><span class="hljs-comment"> * 这个特殊的规则只适用于以下六种情况：</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span></span><br><span class="line"><span class="hljs-comment"> * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span></span><br><span class="line"><span class="hljs-comment"> * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span></span><br><span class="line"><span class="hljs-comment"> * 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 示例 1:</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 输入: "III"</span></span><br><span class="line"><span class="hljs-comment"> * 输出: 3</span></span><br><span class="line"><span class="hljs-comment"> * 示例 2:</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 输入: "IV"</span></span><br><span class="line"><span class="hljs-comment"> * 输出: 4</span></span><br><span class="line"><span class="hljs-comment"> * 示例 3:</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 输入: "IX"</span></span><br><span class="line"><span class="hljs-comment"> * 输出: 9</span></span><br><span class="line"><span class="hljs-comment"> * 示例 4:</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 输入: "LVIII"</span></span><br><span class="line"><span class="hljs-comment"> * 输出: 58</span></span><br><span class="line"><span class="hljs-comment"> * 解释: L = 50, V= 5, III = 3.</span></span><br><span class="line"><span class="hljs-comment"> * 示例 5:</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 输入: "MCMXCIV"</span></span><br><span class="line"><span class="hljs-comment"> * 输出: 1994</span></span><br><span class="line"><span class="hljs-comment"> * 解释: M = 1000, CM = 900, XC = 90, IV = 4.</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment"> * 链接：https://leetcode-cn.com/problems/roman-to-integer</span></span><br><span class="line"><span class="hljs-comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leetcode13</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span>[] moneys = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;;</span><br><span class="line">        String[] moneyToStr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"M"</span>, <span class="hljs-string">"CM"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"CD"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"XC"</span>, <span class="hljs-string">"L"</span>, <span class="hljs-string">"XL"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"IX"</span>, <span class="hljs-string">"V"</span>, <span class="hljs-string">"IV"</span>, <span class="hljs-string">"I"</span>&#125;;</span><br><span class="line">        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> tempJ = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; ) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = tempJ; j &lt; moneyToStr.length; ) &#123;</span><br><span class="line">                <span class="hljs-comment">// 从左往右开始一个字符一个字符匹配，匹配到一个字符后开始下一个</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> String(<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[]&#123;chars[i]&#125;).equals(moneyToStr[j])) &#123;</span><br><span class="line">                    result += moneys[j];</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="hljs-comment">// 此时下一次可能还会出现一样的字符如VV=20</span></span><br><span class="line">                    tempJ = j;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                    <span class="hljs-comment">// 匹配到两个字符是开始下两个字符</span></span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; chars.length &amp;&amp; <span class="hljs-keyword">new</span> String(<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[]&#123;chars[i], chars[i + <span class="hljs-number">1</span>]&#125;).equals(moneyToStr[j])) &#123;</span><br><span class="line">                    result += moneys[j];</span><br><span class="line">                    i += <span class="hljs-number">2</span>;</span><br><span class="line">                    <span class="hljs-comment">// 下次出现的一定是一个字符的,如IV下次不会再出现IV 只能出现I</span></span><br><span class="line">                    tempJ = j + <span class="hljs-number">1</span>;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt1</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="hljs-string">"I"</span>, <span class="hljs-number">1</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"IV"</span>, <span class="hljs-number">4</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"V"</span>, <span class="hljs-number">5</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"IX"</span>, <span class="hljs-number">9</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"X"</span>, <span class="hljs-number">10</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"XL"</span>, <span class="hljs-number">40</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"L"</span>, <span class="hljs-number">50</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"XC"</span>, <span class="hljs-number">90</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"C"</span>, <span class="hljs-number">100</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"CD"</span>, <span class="hljs-number">400</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"D"</span>, <span class="hljs-number">500</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"CM"</span>, <span class="hljs-number">900</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"M"</span>, <span class="hljs-number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-comment">// 所有的字符，要么匹配两个要么匹配一个，没有其余的情况</span></span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length();) &#123;</span><br><span class="line">            <span class="hljs-comment">// 两个匹配的</span></span><br><span class="line">            <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &lt; s.length() &amp;&amp; map.containsKey(s.substring(i, i+<span class="hljs-number">2</span>))) &#123;</span><br><span class="line">                ans += map.get(s.substring(i, i+<span class="hljs-number">2</span>));</span><br><span class="line">                <span class="hljs-comment">// 匹配上后往后移两个</span></span><br><span class="line">                i += <span class="hljs-number">2</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// 一个匹配上的</span></span><br><span class="line">                ans += map.get(s.substring(i, i+<span class="hljs-number">1</span>));</span><br><span class="line">                <span class="hljs-comment">// 匹配后往后移一个</span></span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(romanToInt(<span class="hljs-string">"XIX"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. Longest Common Prefix</a></h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">All given inputs are in lowercase letters a-z.</span><br></pre></td></tr></table></figure><h4 id="JAVA题解-1"><a href="#JAVA题解-1" class="headerlink" title="JAVA题解"></a>JAVA题解</h4><h5 id="水平扫描"><a href="#水平扫描" class="headerlink" title="水平扫描"></a>水平扫描</h5><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191224225712.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191224225319.png" alt=""><br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> algorithm;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 编写一个函数来查找字符串数组中的最长公共前缀。</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 如果不存在公共前缀，返回空字符串 ""。</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 示例 1:</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 输入: ["flower","flow","flight"]</span></span><br><span class="line"><span class="hljs-comment"> * 输出: "fl"</span></span><br><span class="line"><span class="hljs-comment"> * 示例 2:</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 输入: ["dog","racecar","car"]</span></span><br><span class="line"><span class="hljs-comment"> * 输出: ""</span></span><br><span class="line"><span class="hljs-comment"> * 解释: 输入不存在公共前缀。</span></span><br><span class="line"><span class="hljs-comment"> * 说明:</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 所有输入只包含小写字母 a-z 。</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment"> * 链接：https://leetcode-cn.com/problems/longest-common-prefix</span></span><br><span class="line"><span class="hljs-comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leetcode14</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">1</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">        String pre = <span class="hljs-string">""</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (; i &lt; strs[<span class="hljs-number">0</span>].length(); i++) &#123;</span><br><span class="line">            pre = strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>);</span><br><span class="line">            <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">boolean</span> end = <span class="hljs-keyword">false</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (; j &lt; strs.length; j++) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (!strs[j].startsWith(pre)) &#123;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">if</span> (pre.length() == strs[j].length()) &#123;</span><br><span class="line">                    end = <span class="hljs-keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (j == strs.length &amp;&amp; !end) &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != strs.length) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">if</span> (pre.length() &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> pre.substring(<span class="hljs-number">0</span>, pre.length() - <span class="hljs-number">1</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> pre;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 水平扫描法</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">longestCommonPrefix1</span><span class="hljs-params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;</span><br><span class="line">        String prefix = strs[<span class="hljs-number">0</span>];</span><br><span class="line">        <span class="hljs-comment">// 1,2-&gt;s1,3-&gt;s2,4;前两个中找到前缀公共最长的s1,然后和第3个一起找出s2，以此类推</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; strs.length; i++)</span><br><span class="line">            <span class="hljs-comment">// 不相等时为-1</span></span><br><span class="line">            <span class="hljs-keyword">while</span> (strs[i].indexOf(prefix) != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                <span class="hljs-comment">// 从后往前缩短，直到找到最长的</span></span><br><span class="line">                prefix = prefix.substring(<span class="hljs-number">0</span>, prefix.length() - <span class="hljs-number">1</span>);</span><br><span class="line">                <span class="hljs-comment">// 找完都没找到的话返回空</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (prefix.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(longestCommonPrefix1(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"flower"</span>,<span class="hljs-string">"fl"</span>,<span class="hljs-string">"flight"</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 水平扫描，单个字符逐一进行比较</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">longestCommonPrefix2</span><span class="hljs-params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (strs == <span class="hljs-keyword">null</span> || strs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs[<span class="hljs-number">0</span>].length() ; i++)&#123;</span><br><span class="line">            <span class="hljs-keyword">char</span> c = strs[<span class="hljs-number">0</span>].charAt(i);</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; strs.length; j ++) &#123;</span><br><span class="line">                <span class="hljs-comment">// 如果i == strs[j].length() 代表找出最短的，直接返回，或者不相等时直接返回</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c)</span><br><span class="line">                    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 到此处已经找完</span></span><br><span class="line">        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h5><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191224225516.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191224225530.png" alt=""></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (strs == <span class="hljs-keyword">null</span> || strs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    </span><br><span class="line">        <span class="hljs-keyword">return</span> longestCommonPrefix(strs, <span class="hljs-number">0</span> , strs.length - <span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 只有一个字符串的时候，返回此字符串</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> strs[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> mid = (l + r)/<span class="hljs-number">2</span>;</span><br><span class="line">      <span class="hljs-comment">// 找出左边最长前缀</span></span><br><span class="line">        String lcpLeft =   longestCommonPrefix(strs, l , mid);</span><br><span class="line">        <span class="hljs-comment">// 找出右边最长前缀</span></span><br><span class="line">        String lcpRight =  longestCommonPrefix(strs, mid + <span class="hljs-number">1</span>,r);</span><br><span class="line">      <span class="hljs-comment">// 左边右边中找出最长前缀</span></span><br><span class="line">        <span class="hljs-keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">commonPrefix</span><span class="hljs-params">(String left,String right)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> min = Math.min(left.length(), right.length());       </span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">      <span class="hljs-comment">// 循环最小的一边字符逐一比较,不相等时跳出</span></span><br><span class="line">        <span class="hljs-keyword">if</span> ( left.charAt(i) != right.charAt(i) )</span><br><span class="line">            <span class="hljs-keyword">return</span> left.substring(<span class="hljs-number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> left.substring(<span class="hljs-number">0</span>, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h5><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191224230413.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191224230426.png" alt=""></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (strs == <span class="hljs-keyword">null</span> || strs.length == <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">    <span class="hljs-keyword">for</span> (String str : strs)</span><br><span class="line">        minLen = Math.min(minLen, str.length());</span><br><span class="line">    <span class="hljs-keyword">int</span> low = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> high = minLen;</span><br><span class="line">    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> middle = (low + high) / <span class="hljs-number">2</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (isCommonPrefix(strs, middle))</span><br><span class="line">            low = middle + <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            high = middle - <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>, (low + high) / <span class="hljs-number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCommonPrefix</span><span class="hljs-params">(String[] strs, <span class="hljs-keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    String str1 = strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>,len);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; strs.length; i++)</span><br><span class="line">        <span class="hljs-keyword">if</span> (!strs[i].startsWith(str1))</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h5><p>给定一些键值字符串 S = [S 1 ,S 2 …S n ]，我们要找到字符串 q 与 S 的最长公共前缀。 这样的查询操作可能会非常频繁。</p><p>我们可以通过将所有的键值 S 存储到一颗字典树中来优化最长公共前缀查询操作。 如果你想学习更多关于字典树的内容，可以从 <a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/" target="_blank" rel="noopener">208. 实现 Trie (前缀树)</a>开始。在字典树中，从根向下的每一个节点都代表一些键值的公共前缀。 但是我们需要找到字符串q 和所有键值字符串的最长公共前缀。 这意味着我们需要从根找到一条最深的路径，满足以下条件：</p><p>这是所查询的字符串 q 的一个前缀</p><p>路径上的每一个节点都有且仅有一个孩子。 否则，找到的路径就不是所有字符串的公共前缀</p><p>路径不包含被标记成某一个键值字符串结尾的节点。 因为最长公共前缀不可能比某个字符串本身长</p><p><strong>算法</strong></p><p>最后的问题就是如何找到字典树中满足上述所有要求的最深节点。 最有效的方法就是建立一颗包含字符串[S 1 …S n ] 的字典树。 然后在这颗树中匹配 q 的前缀。 我们从根节点遍历这颗字典树，直到因为不能满足某个条件而不能再遍历为止。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191224231052.png" alt=""></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String q, String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (strs == <span class="hljs-keyword">null</span> || strs.length == <span class="hljs-number">0</span>)</span><br><span class="line">         <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;  </span><br><span class="line">    <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">1</span>)</span><br><span class="line">         <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];</span><br><span class="line">    Trie trie = <span class="hljs-keyword">new</span> Trie();      </span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; strs.length ; i++) &#123;</span><br><span class="line">        trie.insert(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> trie.searchLongestPrefix(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 子节点的链接数组</span></span><br><span class="line">    <span class="hljs-keyword">private</span> TrieNode[] links;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> R = <span class="hljs-number">26</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 非空子节点的数量</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, TrieNode node)</span> </span>&#123;</span><br><span class="line">        links[ch -<span class="hljs-string">'a'</span>] = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLinks</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 假设方法 containsKey、isEnd、get、put 都已经实现了</span></span><br><span class="line">    <span class="hljs-comment">// 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="hljs-keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 假设方法 insert、search、searchPrefix 都已经实现了</span></span><br><span class="line"><span class="hljs-comment">// 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">searchLongestPrefix</span><span class="hljs-params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        StringBuilder prefix = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">char</span> curLetter = word.charAt(i);</span><br><span class="line">            <span class="hljs-keyword">if</span> (node.containsKey(curLetter) &amp;&amp; (node.getLinks() == <span class="hljs-number">1</span>) &amp;&amp; (!node.isEnd())) &#123;</span><br><span class="line">                prefix.append(curLetter);</span><br><span class="line">                node = node.get(curLetter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">                <span class="hljs-keyword">return</span> prefix.toString();</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="hljs-keyword">return</span> prefix.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;13-Roman-to-Integer&quot;&gt;&lt;a href=&quot;#13-Roman-to-Integer&quot; class=&quot;headerlink&quot; title=&quot;13. Roman to Integer&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/roman-to-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;13. Roman to Integer&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://removeif.github.io/categories/algorithm/"/>
    
    
      <category term="二分查找" scheme="https://removeif.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="分治" scheme="https://removeif.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法解析示例</title>
    <link href="https://removeif.github.io/algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E7%A4%BA%E4%BE%8B.html"/>
    <id>https://removeif.github.io/algorithm/贪心算法解析示例.html</id>
    <published>2019-12-22T15:26:15.000Z</published>
    <updated>2019-12-22T03:41:10.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>贪心算法（又称贪婪算法）是指，在对<a href="https://baike.baidu.com/item/问题求解" target="_blank" rel="noopener">问题求解</a>时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部<a href="https://baike.baidu.com/item/最优解" target="_blank" rel="noopener">最优解</a>。</p><p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。<br><a id="more"></a></p><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>建立数学模型来描述问题；</li><li>把求解的问题分成若干个子问题；</li><li>对每一子问题求解，得到子问题的局部最优解；</li><li>把子问题的解局部最优解合成原来解问题的一个解。              </li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设山洞中有 n 种宝物，每种宝物有一定重量 w 和相应的价值 v，毛驴运载能力有限，<br>只能运走 m 重量的宝物，一种宝物只能拿一样，宝物可以分割。那么怎么才能使毛驴运走宝<br>物的价值最大呢？<br><strong>尝试贪心策略：</strong><br>（1）每次挑选价值最大的宝物装入背包，得到的结果是否最优？<br>（2）每次挑选重量最小的宝物装入，能否得到最优解？<br>（3）每次选取单位重量价值最大的宝物，能否使价值最高？<br>思考一下，如果选价值最大的宝物，但重量非常大，也是不行的，因为运载能力是有限<br>的，所以第 1 种策略舍弃；如果选重量最小的物品装入，那么其价值不一定高，所以不能在<br>总重限制的情况下保证价值最大，第 2 种策略舍弃；而第 3 种是每次选取单位重量价值最大<br>的宝物，也就是说每次选择性价比（价值/重量）最高的宝物，如果可以达到运载重量 m，</p><p>那么一定能得到价值最大。<br>因此采用第 3 种贪心策略，每次从剩下的宝物中选择性价比最高的宝物。</p><p><strong>算法设计：</strong><br>（1）数据结构及初始化。将 n 种宝物的重量和价值存储在结构体 three（包含重量、价<br>值、性价比 3 个成员）中，同时求出每种宝物的性价比也存储在对应的结构体 three 中，将<br>其按照性价比从高到低排序。采用 sum 来存储毛驴能够运走的最大价值，初始化为 0。<br>（2）根据贪心策略，按照性价比从大到小选取宝物，直到达到毛驴的运载能力。每次选<br>择性价比高的物品，判断是否小于 m（毛驴运载能力），如果小于 m，则放入，sum（已放入<br>物品的价值）加上当前宝物的价值，m 减去放入宝物的重量；如果不小于 m，则取该宝物的<br>一部分 <code>m * p[i]，m=0</code>，程序结束。m 减少到 0，则 sum 得到最大值。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221230800.png" alt=""></p><p><strong>完美图解</strong><br>假设现在有一批宝物，价值和重量如表 2-3 所示，毛驴运载能力 m=30，那么怎么装入<br>最大价值的物品？<br><strong>宝物清单：</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">宝物 i  1  2  3  4  5  6  7  8  9  10</span><br><span class="line">重量 w[i]  4  2  9  5  5  8  5  4  5  5</span><br><span class="line">价值 v[i]  3  8  18  6  8  20  5  6  7  15</span><br></pre></td></tr></table></figure></p><p><strong>（1）因为贪心策略是每次选择性价比（价值/重量）高的宝物，按照性价比降序排序：</strong><br><strong>排序后宝物清单：</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">宝物 i  2  10  6  3  5  8  9  4  7  1</span><br><span class="line">重量 w[i]  2  5  8  9  5  4  5  5  5  4</span><br><span class="line">价值 v[i]  8  15  20  18  8  6  7  6  5  3</span><br><span class="line">性价比 p[i]  4  3  2.5  2  1.6  1.5  1.4  1.2  1  0.75</span><br></pre></td></tr></table></figure></p><p><strong>（2）按照贪心策略，每次选择性价比高的宝物放入：</strong><br>第 1 次选择宝物 2，剩余容量 30−2=28，目前装入最大价值为 8。<br>第 2 次选择宝物 10，剩余容量 28−5=23，目前装入最大价值为 8+15=23。<br>第 3 次选择宝物 6，剩余容量 23−8=15，目前装入最大价值为 23+20=43。<br>第 4 次选择宝物 3，剩余容量 15−9=6，目前装入最大价值为 43+18=61。</p><p>第 5 次选择宝物 5，剩余容量 6−5=1，目前装入最大价值为 61+8=69。<br>第 6 次选择宝物 8，发现上次处理完时剩余容量为 1，而 8 号宝物重量为 4，无法全部<br>放入，那么可以采用部分装入的形式，装入 1 个重量单位，因为 8 号宝物的单位重量价值为<br>1.5，因此放入价值 1×1.5=1.5，你也可以认为装入了 8 号宝物的 1/4，目前装入最大价值为<br>69+1.5=70.5，剩余容量为 0。<br><strong>（3）构造最优解</strong><br>把这些放入的宝物序号组合在一起，就得到了最优解（2，10，6，3，5，8），其中最后<br>一个宝物为部分装入（装了 8 号财宝的 1/4），能够装入宝物的最大价值为 70.5。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221230512.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221230643.png" alt=""></p><h4 id="伪代码详解"><a href="#伪代码详解" class="headerlink" title="伪代码详解"></a>伪代码详解</h4><p><strong>（1）数据结构定义</strong><br>根据算法设计中的数据结构，我们首先定义一个结构体 three：<br>struct three{<br>double w; //每种宝物的重量<br>double v; //每种宝物的价值<br>double p; //每种宝物的性价比（价值/重量）<br>｝<br><strong>（2）性价比排序</strong><br>我们可以利用 C++中的排序函数 sort（见附录 B），对宝物的性价比从大到小（非递增）<br>排序。要使用此函数需引入头文件：<br>#include <algorithm><br>语法描述为：<br>sort(begin, end)// 参数 begin 和 end 表示一个范围，分别为待排序数组的首地址和尾地址<br>在本例中我们采用结构体形式存储，按结构体中的一个字段，即按性价比排序。如果不<br>使用自定义比较函数，那么 sort 函数排序时不知道按哪一项的值排序，因此采用自定义比较<br>函数的办法实现宝物性价比的降序排序：<br>bool cmp(three a,three b)//比较函数按照宝物性价比降序排列<br>{<br>return a.p &gt; b.p; //指明按照宝物性价比降序排列<br>}<br>sort(s, s+n, cmp); //前两个参数分别为待排序数组的首地址和尾地址<br>//最后一个参数 compare 表示比较的类型<br><strong>（3）贪心算法求解</strong><br>在性价比排序的基础上，进行贪心算法运算。如果剩余容量比当前宝物的重量大，则可以放入，剩余容量减去当前宝物的重量，已放入物品的价值加上当前宝物的价值。如果剩余<br>容量比当前宝物的重量小，表示不可以全部放入，可以切割下来一部分（正好是剩余容量），<br>然后令剩余容量乘以当前物品的单位重量价值，已放入物品的价值加上该价值，即为能放入<br>宝物的最大价值。</algorithm></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)<span class="hljs-comment">//按照排好的顺序，执行贪心策略</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>( m &gt; s[i].w )<span class="hljs-comment">//如果宝物的重量小于毛驴剩下的运载能力，即剩余容量</span></span><br><span class="line">&#123;</span><br><span class="line">m -= s[i].w;</span><br><span class="line">sum += s[i].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-comment">//如果宝物的重量大于毛驴剩下的承载能力</span></span><br><span class="line">&#123;</span><br><span class="line">sum += m 乘以 s[i].p; <span class="hljs-comment">//进行宝物切割，切割一部分(m 重量)，正好达到驴子承重</span></span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h4><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M=<span class="hljs-number">1000005</span>;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">three</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">double</span> w;<span class="hljs-comment">//每个宝物的重量</span></span><br><span class="line">    <span class="hljs-keyword">double</span> v;<span class="hljs-comment">//每个宝物的价值</span></span><br><span class="line">    <span class="hljs-keyword">double</span> p;<span class="hljs-comment">//性价比</span></span><br><span class="line">&#125;s[M];</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(three a,three b)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a.p&gt;b.p;<span class="hljs-comment">//根据宝物的单位价值从大到小排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n;<span class="hljs-comment">//n 表示有 n 个宝物</span></span><br><span class="line">    <span class="hljs-keyword">double</span> m ;<span class="hljs-comment">//m 表示毛驴的承载能力</span></span><br><span class="line">    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"请输入宝物数量 n 及毛驴的承载能力 m ："</span>&lt;&lt;<span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"请输入每个宝物的重量和价值，用空格分开： "</span>&lt;&lt;<span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;s[i].w&gt;&gt;s[i].v;</span><br><span class="line">        s[i].p=s[i].v/s[i].w;<span class="hljs-comment">//每个宝物单位价值</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(s,s+n,cmp);</span><br><span class="line">    <span class="hljs-keyword">double</span> sum=<span class="hljs-number">0.0</span>;<span class="hljs-comment">// sum 表示贪心记录运走宝物的价值之和</span></span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//按照排好的顺序贪心</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>( m&gt;s[i].w )<span class="hljs-comment">//如果宝物的重量小于毛驴剩下的承载能力</span></span><br><span class="line">    &#123;</span><br><span class="line">        m-=s[i].w;</span><br><span class="line">        sum+=s[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span><span class="hljs-comment">//如果宝物的重量大于毛驴剩下的承载能力</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum+=m * s[i].p;<span class="hljs-comment">//部分装入</span></span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"装入宝物的最大价值 Maximum value="</span>&lt;&lt;sum&lt;&lt;<span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果物品不能被分割，就不能采用贪心算法。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221231432.png" alt=""></p><h3 id="leetcode12-整数转罗马数字"><a href="#leetcode12-整数转罗马数字" class="headerlink" title="leetcode12. 整数转罗马数字"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">leetcode12. 整数转罗马数字</a></h3><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221231719.png" alt=""></p><p>生活中的经验：</p><p><strong>在以前还使用现金购物的时候，如果我们不想让对方找钱，付款的时候我们会尽量选择面值大的纸币给对方，这样才会使得我们给对方的纸币张数最少，对方点钱的时候也最方便。</strong></p><p>本题“整数转罗马数字”也有类似的思想：在表示一个较大整数的时候，“罗马数字”的设计者不会让你都用 11 加起来，我们总是希望写出来的“罗马数字”的个数越少越好，以方便表示，并且这种表示方式还应该是唯一的。</p><p><strong>“罗马数字”与阿拉伯数字的对应关系表中，并且按照从大到小的顺序排列</strong>。</p><table><thead><tr><th style="text-align:left">罗马数字</th><th style="text-align:left">阿拉伯数字</th></tr></thead><tbody><tr><td style="text-align:left">M</td><td style="text-align:left">1000</td></tr><tr><td style="text-align:left">CM</td><td style="text-align:left">900</td></tr><tr><td style="text-align:left">D</td><td style="text-align:left">500</td></tr><tr><td style="text-align:left">CD</td><td style="text-align:left">400</td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">XC</td><td style="text-align:left">90</td></tr><tr><td style="text-align:left">L</td><td style="text-align:left">50</td></tr><tr><td style="text-align:left">XL</td><td style="text-align:left">40</td></tr><tr><td style="text-align:left">X</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">IX</td><td style="text-align:left">9</td></tr><tr><td style="text-align:left">V</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">IV</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">1</td></tr></tbody></table><p>于是，“将整数转换为罗马数字”的过程，就是用上面这张表中右边的数字作为“加法因子”去分解一个整数，目的是“分解的整数个数”尽可能少，因此，对于这道问题，类似于用最少的纸币凑成一个整数，贪心算法的规则如下：</p><p><strong>每一步都使用当前较大的罗马数字作为加法因子，最后得到罗马数字表示就是长度最少的。</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中</span></span><br><span class="line">        <span class="hljs-comment">// 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想</span></span><br><span class="line">        <span class="hljs-keyword">int</span>[] nums = &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;;</span><br><span class="line">        String[] romans = &#123;<span class="hljs-string">"M"</span>, <span class="hljs-string">"CM"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"CD"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"XC"</span>, <span class="hljs-string">"L"</span>, <span class="hljs-string">"XL"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"IX"</span>, <span class="hljs-string">"V"</span>, <span class="hljs-string">"IV"</span>, <span class="hljs-string">"I"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span> (index &lt; <span class="hljs-number">13</span>) &#123;</span><br><span class="line">            <span class="hljs-comment">// 特别注意：这里是等号</span></span><br><span class="line">            <span class="hljs-keyword">while</span> (num &gt;= nums[index]) &#123;</span><br><span class="line">                <span class="hljs-comment">// 注意：这里是等于号，表示尽量使用大的"面值"</span></span><br><span class="line">                stringBuilder.append(romans[index]);</span><br><span class="line">                num -= nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：liweiwei1419</span><br><span class="line">链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-liweiwei1419/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>参考文章:<br><a href="https://blog.csdn.net/yanyanwenmeng/article/details/83008780" target="_blank" rel="noopener">参考链接1</a><br><a href="https://www.cnblogs.com/aerer/p/9931068.html" target="_blank" rel="noopener">参考链接2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;贪心算法（又称贪婪算法）是指，在对&lt;a href=&quot;https://baike.baidu.com/item/问题求解&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;问题求解&lt;/a&gt;时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部&lt;a href=&quot;https://baike.baidu.com/item/最优解&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最优解&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://removeif.github.io/categories/algorithm/"/>
    
    
      <category term="贪心算法" scheme="https://removeif.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="最优解" scheme="https://removeif.github.io/tags/%E6%9C%80%E4%BC%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>不蒜子统计常见问题</title>
    <link href="https://removeif.github.io/theme/%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
    <id>https://removeif.github.io/theme/不蒜子统计常见问题.html</id>
    <published>2019-12-21T00:46:08.000Z</published>
    <updated>2019-12-21T01:11:34.850Z</updated>
    
    <content type="html"><![CDATA[<p>不蒜子统计官网：<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">http://busuanzi.ibruce.info/</a></p><p>详细使用教程：<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">http://ibruce.info/2015/04/04/busuanzi/</a></p><p>目前支持的功能：（两行代码，搞定计数；方便、简洁、实用）</p><p>a、显示站点总访问量</p><p>b、显示单页面访问量<br><a id="more"></a></p><p>c、显示站点总访问量和单页面访问量</p><p>d、只计数不显示</p><p>关于怎么实现当天、昨天、本月、上月（即具体时间段）的访问量目前没有支持，请配合目前不蒜子支持的功能自行实现。</p><h3 id="1-常见问题400错误，统计不生效"><a href="#1-常见问题400错误，统计不生效" class="headerlink" title="1.常见问题400错误，统计不生效"></a>1.常见问题400错误，统计不生效</h3><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085006.png" alt="">            </p><p>如图<strong>（1）</strong>的地方没有加载出统计数据</p><p>此时F12打开浏览器控制台，找到<strong>（2）</strong>network地方，刷新一下页面找到<strong>（3）</strong>，请求统计的网址如图所示，查看<strong>（4）</strong>referrer-policy是否如图所示，如图的话是不能访问的，需要更改。</p><p><strong>导致此问题原因</strong>，检查网页源码中，一般header有如下标签</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085114.png" alt="">    </p><p><strong>解决方法</strong>，去掉此标签，之后访问如下<strong>（1）</strong>已有统计值，<strong>（2）</strong>已改变。可详细对比正常使用不蒜子统计网址<a href="https://removeif.github.io/">https://removeif.github.io/</a> 中请求<strong>busuanzi?jsonpCallback=BusuanziCallback_236107382952地址</strong>的请求和返回参数的差异！</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085231.png" alt=""></p><p><strong>这样设置带来的影响</strong>，可能有些图床的图片不能显示，会图裂，如新浪图床。解决方法，可以用其他不冲突的图床。</p><h3 id="2-统计访问数巨大（清零问题）"><a href="#2-统计访问数巨大（清零问题）" class="headerlink" title="2.统计访问数巨大（清零问题）"></a>2.统计访问数巨大（清零问题）</h3><p><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 或<a href="http://127.0.0.1:4000/" target="_blank" rel="noopener">http://127.0.0.1:4000/</a> 访问时，统计数巨大，这是正常的，不用清零。部署到线上，用线上域名网址访问数据就正常了。</p><h3 id="3-统计无法访问如图所示"><a href="#3-统计无法访问如图所示" class="headerlink" title="3.统计无法访问如图所示"></a>3.统计无法访问如图所示</h3><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085258.png" alt=""></p><p>查看红色url部分如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085320.png" alt=""></p><p>此问题是Request URL填写错误，请确保Request URL前部分为<a href="http://busuanzi.ibruce.info/busuanzi?" target="_blank" rel="noopener"><strong>http://busuanzi.ibruce.info/busuanzi?</strong></a><strong>，，，，如下</strong></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085345.png" alt=""></p><p>同时查看Response，出现如下数据，就是成功访问了不蒜子统计，如果网站中还没出统计数据，就是自己的代码写错了，检查代码</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085405.png" alt=""></p><h3 id="4-其余问题"><a href="#4-其余问题" class="headerlink" title="4.其余问题"></a>4.其余问题</h3><p><strong>(1)</strong>.同一个页面，同名的id标签确保只能放一个如下</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_container_site_uv"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"display: inline;"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_value_site_uv"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同一个页面id名为busuanzi_value_site_uv只能放一个!</p><p><strong>(2)</strong>.safari（包括移动端的safari）浏览器页面pv统计问题，如下，因为Safari浏览器referer在文章页面时也上送的域名（而单个页面的pv统计是根据页面路径，即上送的referer），所以此时页面的pv返回的站点的pv值。暂时没解决方法，可自行搜索解决方案构造正确的referer值。对于此问题可以换个浏览器看哇，比如Chrome，哈哈。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085514.png" alt=""></p><p><strong>(3)</strong>.部分live2d可能与不蒜子统计有冲突，出现此问题时，请查看网页源码引用统计id处是否被隐藏，一般网页上会自动加上display: none;自行选择性的使用。网友的解决方法，修改源码为以下，并引用修改后的js文件</p><p>不蒜子源码文件：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221085823.png" alt=""></p><p> 修改为如下：</p><figure class="highlight diff hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">var bszCaller, bszTag;</span><br><span class="line"><span class="hljs-addition">!function() &#123;</span></span><br><span class="line">    var c, d, e, a = !1, b = [];</span><br><span class="line">    ready = function(c) &#123;</span><br><span class="line">        return a || "interactive" <span class="hljs-comment">=== document.readyState || "complete" === document.readyState ? c.call(document) : b.push(function() &#123;</span></span><br><span class="line">            return c.call(this)</span><br><span class="line">        &#125;),</span><br><span class="line">        this</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    d = function() &#123;</span><br><span class="line">        for (var a = 0, c = b.length; c &gt; a; a++)</span><br><span class="line">            b[a].apply(document);</span><br><span class="line">        b = []</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    e = function() &#123;</span><br><span class="line">        a || (a = !0,</span><br><span class="line">        d.call(window),</span><br><span class="line">        document.removeEventListener ? document.removeEventListener("DOMContentLoaded", e, !1) : document.attachEvent &amp;&amp; (document.detachEvent("onreadystatechange", e),</span><br><span class="line">        window == window.top &amp;&amp; (clearInterval(c),</span><br><span class="line">        c = null)))</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    document.addEventListener ? document.addEventListener("DOMContentLoaded", e, !1) : document.attachEvent &amp;&amp; (document.attachEvent("onreadystatechange", function() &#123;</span><br><span class="line">        /loaded|complete/.test(document.readyState) &amp;&amp; e()</span><br><span class="line">    &#125;),</span><br><span class="line">    window == window.top &amp;&amp; (c = setInterval(function() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            a || document.documentElement.doScroll("left")</span><br><span class="line">        &#125; catch (b) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        e()</span><br><span class="line">    &#125;, 5)))</span><br><span class="line">&#125;(),</span><br><span class="line">bszCaller = &#123;</span><br><span class="line">    fetch: function(a, b) &#123;</span><br><span class="line">        var c = "BusuanziCallback_" + Math.floor(1099511627776 * Math.random());</span><br><span class="line">        window[c] = this.evalCall(b),</span><br><span class="line">        a = a.replace("=BusuanziCallback", "=" + c),</span><br><span class="line">        scriptTag = document.createElement("SCRIPT"),</span><br><span class="line">        scriptTag.type = "text/javascript",</span><br><span class="line">        scriptTag.defer = !0,</span><br><span class="line">        scriptTag.src = a,</span><br><span class="line">        document.getElementsByTagName("HEAD")[0].appendChild(scriptTag)</span><br><span class="line">    &#125;,</span><br><span class="line">    evalCall: function(a) &#123;</span><br><span class="line">        return function(b) &#123;</span><br><span class="line">            ready(function() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    a(b), </span><br><span class="line"><span class="hljs-deletion">-                      // 此处为修改的逻辑</span></span><br><span class="line"><span class="hljs-deletion">-                      scriptTag.parentElement.removeChild(scriptTag)</span></span><br><span class="line"><span class="hljs-addition">+                      if(scriptTag != null &amp;&amp; scriptTag.parentElement != null)&#123;</span></span><br><span class="line"><span class="hljs-addition">+                       scriptTag.parentElement.removeChild(scriptTag)</span></span><br><span class="line"><span class="hljs-addition">+                      &#125;</span></span><br><span class="line">                &#125; catch (c) &#123;</span><br><span class="line">                    bszTag.hides()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">bszCaller.fetch("//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", function(a) &#123;</span><br><span class="line">    bszTag.texts(a),</span><br><span class="line">    bszTag.shows()</span><br><span class="line">&#125;),</span><br><span class="line">bszTag = &#123;</span><br><span class="line">    bszs: ["site_pv", "page_pv", "site_uv"],</span><br><span class="line">    texts: function(a) &#123;</span><br><span class="line">        this.bszs.map(function(b) &#123;</span><br><span class="line">            var c = document.getElementById("busuanzi_value_" + b);</span><br><span class="line">            c &amp;&amp; (c.innerHTML = a[b])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    hides: function() &#123;</span><br><span class="line">        this.bszs.map(function(a) &#123;</span><br><span class="line">            var b = document.getElementById("busuanzi_container_" + a);</span><br><span class="line">            b &amp;&amp; (b.style.display = "none")</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    shows: function() &#123;</span><br><span class="line">        this.bszs.map(function(a) &#123;</span><br><span class="line">            var b = document.getElementById("busuanzi_container_" + a);</span><br><span class="line">            b &amp;&amp; (b.style.display = "inline")</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-官方群！！！"><a href="#5-官方群！！！" class="headerlink" title="5.官方群！！！"></a>5.官方群！！！</h3><p>群号：419260983，有其余问题进群讨论，**提问时遇到其他的问题请同时发出问题的在线网址！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不蒜子统计官网：&lt;a href=&quot;http://busuanzi.ibruce.info/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://busuanzi.ibruce.info/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详细使用教程：&lt;a href=&quot;http://ibruce.info/2015/04/04/busuanzi/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ibruce.info/2015/04/04/busuanzi/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前支持的功能：（两行代码，搞定计数；方便、简洁、实用）&lt;/p&gt;
&lt;p&gt;a、显示站点总访问量&lt;/p&gt;
&lt;p&gt;b、显示单页面访问量&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具教程" scheme="https://removeif.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
      <category term="博客统计插件" scheme="https://removeif.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="博客统计插件" scheme="https://removeif.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>算法成长之路leetcode11-12</title>
    <link href="https://removeif.github.io/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode11-12.html"/>
    <id>https://removeif.github.io/algorithm/算法成长之路leetcode11-12.html</id>
    <published>2019-12-17T10:25:03.000Z</published>
    <updated>2019-12-17T10:36:11.202Z</updated>
    
    <content type="html"><![CDATA[<h3 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. Container With Most Water</a></h3><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<br><a id="more"></a><br>Note: You may not slant the container and n is at least 2.</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217182702.png" alt=""></p><p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure><h4 id="JAVA题解"><a href="#JAVA题解" class="headerlink" title="JAVA题解"></a>JAVA题解</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。</span></span><br><span class="line"><span class="hljs-comment"> * 在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。</span></span><br><span class="line"><span class="hljs-comment"> * 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 说明：你不能倾斜容器，且 n 的值至少为 2。</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 示例:</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 输入: [1,8,6,2,5,4,8,3,7]</span></span><br><span class="line"><span class="hljs-comment"> * 输出: 49</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment"> * 链接：https://leetcode-cn.com/problems/container-with-most-water</span></span><br><span class="line"><span class="hljs-comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leetcode11</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 暴力解法</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; height.length - <span class="hljs-number">1</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">                max = Math.max(max, Math.min(height[i], height[j]) * (j-i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 官方 双指针法</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 算法</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。</span></span><br><span class="line"><span class="hljs-comment">     * 此外，我们会使用变量 maxareamaxarea 来持续存储到目前为止所获得的最大面积。</span></span><br><span class="line"><span class="hljs-comment">     * 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxareamaxarea，并将指向较短线段的指针向较长线段那端移动一步。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 作者：LeetCode</span></span><br><span class="line"><span class="hljs-comment">     * 链接：https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode/</span></span><br><span class="line"><span class="hljs-comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment">     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 算法流程： 设置双指针 ii,jj 分别位于容器壁两端，根据规则移动指针（后续说明），并且更新面积最大值 res，直到 i == j 时返回 res。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 指针移动规则与证明： 每次选定围成水槽两板高度 h[i]h[i],h[j]h[j] 中的短板，向中间收窄 11 格。以下证明：</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 设每一状态下水槽面积为 S(i, j)S(i,j),(0 &lt;= i &lt; j &lt; n)(0&lt;=i&lt;j&lt;n)，由于水槽的实际高度由两板中的短板决定，</span></span><br><span class="line"><span class="hljs-comment">     * 则可得面积公式 S(i, j) = min(h[i], h[j]) × (j - i)S(i,j)=min(h[i],h[j])×(j−i)。</span></span><br><span class="line"><span class="hljs-comment">     * 在每一个状态下，无论长板或短板收窄 11 格，都会导致水槽 底边宽度 -1−1：</span></span><br><span class="line"><span class="hljs-comment">     * 若向内移动短板，水槽的短板 min(h[i], h[j])min(h[i],h[j]) 可能变大，因此水槽面积 S(i, j)S(i,j) 可能增大。</span></span><br><span class="line"><span class="hljs-comment">     * 若向内移动长板，水槽的短板 min(h[i], h[j])min(h[i],h[j]) 不变或变小，下个水槽的面积一定小于当前水槽面积。</span></span><br><span class="line"><span class="hljs-comment">     * 因此，向内收窄短板可以获取面积最大值。换个角度理解：</span></span><br><span class="line"><span class="hljs-comment">     * 若不指定移动规则，所有移动出现的 S(i, j)S(i,j) 的状态数为 C(n, 2)C(n,2)，即暴力枚举出所有状态。</span></span><br><span class="line"><span class="hljs-comment">     * 在状态 S(i, j)S(i,j) 下向内移动短板至 S(i + 1, j)S(i+1,j)（假设 h[i] &lt; h[j]h[i]&lt;h[j] ），</span></span><br><span class="line"><span class="hljs-comment">     * 则相当于消去了 &#123;S(i, j - 1), S(i, j - 2), ... , S(i, i + 1)&#125;S(i,j−1),S(i,j−2),...,S(i,i+1) 状态集合。</span></span><br><span class="line"><span class="hljs-comment">     * 而所有消去状态的面积一定 &lt;= S(i, j)&lt;=S(i,j)：</span></span><br><span class="line"><span class="hljs-comment">     * 短板高度：相比 S(i, j)S(i,j) 相同或更短（&lt;= h[i]&lt;=h[i]）；</span></span><br><span class="line"><span class="hljs-comment">     * 底边宽度：相比 S(i, j)S(i,j) 更短。</span></span><br><span class="line"><span class="hljs-comment">     * 因此所有消去的状态的面积都 &lt; S(i, j)&lt;S(i,j)。通俗的讲，我们每次向内移动短板，所有的消去状态都不会导致丢失面积最大值 。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 作者：jyd</span></span><br><span class="line"><span class="hljs-comment">     * 链接：https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/</span></span><br><span class="line"><span class="hljs-comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment">     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> height</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> maxarea = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, r = height.length - <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="hljs-comment">// 计算面积，取最大值</span></span><br><span class="line">            maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l));</span><br><span class="line">            <span class="hljs-comment">// 小的向大的一方移动，如果左边小于右边，左边向右边移动一位，即左++,l++，否则右移</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (height[l] &lt; height[r])</span><br><span class="line">                l++;</span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> maxarea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = height.length - <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            res = height[i] &lt; height[j] ?</span><br><span class="line">                    Math.max(res, (j - i) * height[i++]):</span><br><span class="line">                    Math.max(res, (j - i) * height[j--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// best one</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> lastIndex = height.length - <span class="hljs-number">1</span>, max = <span class="hljs-number">0</span>, temp = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lastIndex;) &#123;</span><br><span class="line">            <span class="hljs-comment">// 取左右边上的最小的数</span></span><br><span class="line">            temp = Math.min(height[i], height[lastIndex]);</span><br><span class="line">            <span class="hljs-comment">// 计算 距离最大面积</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (temp * (lastIndex - i) &gt; max) &#123;</span><br><span class="line">                max = temp * (lastIndex - i);</span><br><span class="line">                System.out.println(<span class="hljs-string">""</span> + i + <span class="hljs-string">","</span> + lastIndex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">// 最小值在右边的话 右边往左边移动</span></span><br><span class="line">            <span class="hljs-keyword">while</span> (temp &gt;= height[lastIndex] &amp;&amp; i &lt; lastIndex)</span><br><span class="line">                lastIndex--;</span><br><span class="line">            <span class="hljs-comment">// 最小值在左边的话 左边往右移动 直到重合</span></span><br><span class="line">            <span class="hljs-keyword">while</span> (temp &gt;= height[i] &amp;&amp; i &lt; lastIndex)</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(maxArea3(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">10</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">12. Integer to Roman</a></h3><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><p>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output: &quot;III&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: &quot;IV&quot;</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 9</span><br><span class="line">Output: &quot;IX&quot;</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: 58</span><br><span class="line">Output: &quot;LVIII&quot;</span><br><span class="line">Explanation: L = 50, V = 5, III = 3.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: 1994</span><br><span class="line">Output: &quot;MCMXCIV&quot;</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure><h4 id="JAVA题解-1"><a href="#JAVA题解-1" class="headerlink" title="JAVA题解"></a>JAVA题解</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 字符          数值</span></span><br><span class="line"><span class="hljs-comment"> * I             1</span></span><br><span class="line"><span class="hljs-comment"> * V             5</span></span><br><span class="line"><span class="hljs-comment"> * X             10</span></span><br><span class="line"><span class="hljs-comment"> * L             50</span></span><br><span class="line"><span class="hljs-comment"> * C             100</span></span><br><span class="line"><span class="hljs-comment"> * D             500</span></span><br><span class="line"><span class="hljs-comment"> * M             1000</span></span><br><span class="line"><span class="hljs-comment"> * 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，</span></span><br><span class="line"><span class="hljs-comment"> * 即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 通常情况下，罗马数字中小的数字在大的数字的右边。</span></span><br><span class="line"><span class="hljs-comment"> * 但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，</span></span><br><span class="line"><span class="hljs-comment"> * 所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，</span></span><br><span class="line"><span class="hljs-comment"> * 数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span></span><br><span class="line"><span class="hljs-comment"> * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span></span><br><span class="line"><span class="hljs-comment"> * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span></span><br><span class="line"><span class="hljs-comment"> * 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 示例 1:</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 输入: 3</span></span><br><span class="line"><span class="hljs-comment"> * 输出: "III"</span></span><br><span class="line"><span class="hljs-comment"> * 示例 2:</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 输入: 4</span></span><br><span class="line"><span class="hljs-comment"> * 输出: "IV"</span></span><br><span class="line"><span class="hljs-comment"> * 示例 3:</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 输入: 9</span></span><br><span class="line"><span class="hljs-comment"> * 输出: "IX"</span></span><br><span class="line"><span class="hljs-comment"> * 示例 4:</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 输入: 58</span></span><br><span class="line"><span class="hljs-comment"> * 输出: "LVIII"</span></span><br><span class="line"><span class="hljs-comment"> * 解释: L = 50, V = 5, III = 3.</span></span><br><span class="line"><span class="hljs-comment"> * 示例 5:</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 输入: 1994</span></span><br><span class="line"><span class="hljs-comment"> * 输出: "MCMXCIV"</span></span><br><span class="line"><span class="hljs-comment"> * 解释: M = 1000, CM = 900, XC = 90, IV = 4.</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment"> * 链接：https://leetcode-cn.com/problems/integer-to-roman</span></span><br><span class="line"><span class="hljs-comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leetcode12</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 执行用时 :6 ms, 在所有 java 提交中击败了的用户</span></span><br><span class="line"><span class="hljs-comment">     * 内存消耗 :36.1 MB, 在所有 java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> num</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 个位数</span></span><br><span class="line">        String[] map = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">""</span>, <span class="hljs-string">"I"</span>, <span class="hljs-string">"II"</span>, <span class="hljs-string">"III"</span>, <span class="hljs-string">"IV"</span>, <span class="hljs-string">"V"</span>, <span class="hljs-string">"VI"</span>, <span class="hljs-string">"VII"</span>, <span class="hljs-string">"VIII"</span>, <span class="hljs-string">"IX"</span>&#125;;</span><br><span class="line">        <span class="hljs-comment">// 十位数</span></span><br><span class="line">        String[] map1 = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">""</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"XX"</span>, <span class="hljs-string">"XXX"</span>, <span class="hljs-string">"XL"</span>, <span class="hljs-string">"L"</span>, <span class="hljs-string">"LX"</span>, <span class="hljs-string">"LXX"</span>, <span class="hljs-string">"LXXX"</span>, <span class="hljs-string">"XC"</span>&#125;;</span><br><span class="line">        <span class="hljs-comment">// 百位</span></span><br><span class="line">        String[] map2 = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">""</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"CC"</span>, <span class="hljs-string">"CCC"</span>, <span class="hljs-string">"CD"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"DC"</span>, <span class="hljs-string">"DCC"</span>, <span class="hljs-string">"DCCC"</span>, <span class="hljs-string">"CM"</span>&#125;;</span><br><span class="line">        <span class="hljs-comment">// 千位</span></span><br><span class="line">        String[] map3 = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">""</span>, <span class="hljs-string">"M"</span>, <span class="hljs-string">"MM"</span>, <span class="hljs-string">"MMM"</span>&#125;;</span><br><span class="line">        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">        String[] res = <span class="hljs-keyword">new</span> String[<span class="hljs-number">4</span>];</span><br><span class="line">        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> temp = num % i;</span><br><span class="line">            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">10</span>) &#123;</span><br><span class="line">                temp = temp / (i / <span class="hljs-number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">switch</span> (j) &#123;</span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:</span><br><span class="line">                    res[j++] = map[temp];</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:</span><br><span class="line">                    res[j++] = map1[temp];</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:</span><br><span class="line">                    res[j++] = map2[temp];</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:</span><br><span class="line">                    res[j++] = map3[temp];</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = <span class="hljs-number">10</span>*i;</span><br><span class="line">            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">3</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = res.length - <span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) &#123;</span><br><span class="line">            sb.append(res[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 贪心算法</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 解题思路</span></span><br><span class="line"><span class="hljs-comment">     * 参考大佬们的思路 吃透之后 写出来</span></span><br><span class="line"><span class="hljs-comment">     * 贪心算法 我永远用最接近的去做比较</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 如果我去小卖部买55元的东西</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 你可以选择一张面值50的 和一张5块的</span></span><br><span class="line"><span class="hljs-comment">     * 也可以给一张100的让老板找零</span></span><br><span class="line"><span class="hljs-comment">     * 贪心算法就是前者</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 假定我买3块的东西 我先用5块去比较 太多了 老板问 你还有小点的纸币没 我找不开</span></span><br><span class="line"><span class="hljs-comment">     * 这时候 你给个两块 还差一块 又给了一块</span></span><br><span class="line"><span class="hljs-comment">     * 看着很蠢 但是这确实有效</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 作者：guo-tang-feng</span></span><br><span class="line"><span class="hljs-comment">     * 链接：https://leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-guo-tang-feng/</span></span><br><span class="line"><span class="hljs-comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment">     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> num</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">intToRoman1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="hljs-keyword">int</span>[] moneys = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;;</span><br><span class="line">        String[] moneyToStr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"M"</span>, <span class="hljs-string">"CM"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"CD"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"XC"</span>, <span class="hljs-string">"L"</span>, <span class="hljs-string">"XL"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"IX"</span>, <span class="hljs-string">"V"</span>, <span class="hljs-string">"IV"</span>, <span class="hljs-string">"I"</span>&#125;;</span><br><span class="line">        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-comment">// 如果大于最大的数</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (num &gt;= moneys[index]) &#123;</span><br><span class="line">                <span class="hljs-comment">// 加进去</span></span><br><span class="line">                stringBuilder.append(moneyToStr[index]);</span><br><span class="line">                <span class="hljs-comment">// 把加进去的减掉</span></span><br><span class="line">                num -= moneys[index];</span><br><span class="line">                <span class="hljs-comment">// 索引前移，num -= moneys[index] 还可能满足 num &gt;= moneys[index]</span></span><br><span class="line">                <span class="hljs-comment">// ，此时如果只index++，那么就漏掉一部分了，所以要index--，如2000减掉1000还有1000 还是应该和moneys[0]比较</span></span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// 索引后移</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 第一次超过100%用户的内存，有点小小激动 😂</span></span><br><span class="line">        System.out.println(intToRoman(<span class="hljs-number">400</span>));</span><br><span class="line">        System.out.println(intToRoman1(<span class="hljs-number">1994</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;11-Container-With-Most-Water&quot;&gt;&lt;a href=&quot;#11-Container-With-Most-Water&quot; class=&quot;headerlink&quot; title=&quot;11. Container With Most Water&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;11. Container With Most Water&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://removeif.github.io/categories/algorithm/"/>
    
    
      <category term="贪心算法" scheme="https://removeif.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>intellj idea 详细调试代码debug</title>
    <link href="https://removeif.github.io/develop/intellj-idea-%E8%AF%A6%E7%BB%86%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81debug.html"/>
    <id>https://removeif.github.io/develop/intellj-idea-详细调试代码debug.html</id>
    <published>2019-12-16T10:52:11.000Z</published>
    <updated>2019-12-17T01:56:54.493Z</updated>
    
    <content type="html"><![CDATA[<p>Debug用来追踪代码的运行流程，通常在程序运行过程中出现异常，启用Debug模式可以分析定位异常发生的位置，以及在运行过程中参数的变化。通常我们也可以启用Debug模式来跟踪代码的运行流程去学习三方框架的源码。<br><a id="more"></a><br>在Intellij IDEA中使用好Debug，主要包括如下内容：</p><ul><li>Debug开篇</li><li>基本用法&amp;快捷键</li><li>变量查看</li><li>计算表达式</li><li>智能步入</li><li>断点条件设置</li><li>多线程调试</li><li>回退断点</li><li>中断Debug</li></ul><h3 id="一、Debug开篇"><a href="#一、Debug开篇" class="headerlink" title="一、Debug开篇"></a><strong>一、Debug开篇</strong></h3><p>首先看下IDEA中Debug模式下的界面。如下是在IDEA中启动Debug模式，进入断点后的界面，我这里是Windows，可能和Mac的图标等会有些不一样。就简单说下图中标注的8个地方：</p><ol><li>以Debug模式启动服务，左边的一个按钮则是以Run模式启动。在开发中，我一般会直接启动Debug模式，方便随时调试代码。</li><li>断点：在左边行号栏单击左键，或者快捷键Ctrl+F8 打上/取消断点，断点行的颜色可自己去设置。</li><li>Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。如果没有自动激活，可以去设置里设置，如图1.2。</li><li>调试按钮：一共有8个按钮，调试的主要功能就对应着这几个按钮，鼠标悬停在按钮上可以查看对应的快捷键。在菜单栏Run里可以找到同样的对应的功能，如图1.4。</li><li>服务按钮：可以在这里关闭/启动服务，设置断点等。</li><li>方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的[Show All Frames]按钮，就不会显示其它类库的方法了，否则这里会有一大堆的方法。</li><li>Variables：在变量区可以查看当前断点之前的当前方法内的变量。</li><li>Watches：查看变量，可以将Variables区中的变量拖到Watches中查看</li></ol><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217092707.png" alt=""></p><p>在设置里勾选Show debug window on breakpoint，则请求进入到断点后自动激活Debug窗口。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217092728.png" alt=""></p><p>如果你的IDEA底部没有显示工具栏或状态栏，可以在View里打开，显示出工具栏会方便我们使用。可以自己去尝试下这四个选项。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217092807.png" alt=""></p><p>在菜单栏Run里有调试对应的功能，同时可以查看<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247484579&amp;idx=2&amp;sn=5f252603cb05f7fba91b5302a22a0c4b&amp;chksm=ebd63b8fdca1b2996dd05aa4de42485756713f7f586e840fd5a02cecf10004a633bd49ce3738&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">对应的快捷键</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217092834.png" alt=""></p><h3 id="二、基本用法-amp-快捷键"><a href="#二、基本用法-amp-快捷键" class="headerlink" title="二、基本用法&amp;快捷键"></a><strong>二、基本用法&amp;快捷键</strong></h3><p>Debug调试的功能主要对应着图一中4和5两组按钮：</p><p><strong>1、首先说第一组按钮，共8个按钮，从左到右依次如下：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217092855.png" alt=""></p><ul><li>Show Execution Point (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。</li><li>Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</li><li>Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法，如第25行的put方法。</li><li>Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</li><li>Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</li><li>Drop Frame (默认无)：回退断点，后面章节详细说明。</li><li>Run to Cursor (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</li><li>Evaluate Expression (Alt + F8)：计算表达式，后面章节详细说明。</li></ul><p><strong>2、第二组按钮，共7个按钮，从上到下依次如下：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217092925.png" alt=""></p><ul><li>Rerun ‘xxxx’：重新运行程序，会关闭服务后重新启动程序。</li><li>Update ‘tech’ application (Ctrl + F5)：更新程序，一般在你的代码有改动后可执行这个功能。而这个功能对应的操作则是在服务配置里，如图2.3。</li><li>Resume Program (F9)：恢复程序，比如，你在第20行和25行有两个断点，当前运行至第20行，按F9，则运行到下一个断点(即第25行)，再按F9，则运行完整个流程，因为后面已经没有断点了。</li><li>Pause Program：暂停程序，启用Debug。目前没发现具体用法。</li><li>Stop ‘xxx’ (Ctrl + F2)：连续按两下，关闭程序。有时候你会发现关闭服务再启动时，报端口被占用，这是因为没完全关闭服务的原因，你就需要查杀所有JVM进程了。</li><li>View Breakpoints (Ctrl + Shift + F8)：查看所有断点，后面章节会涉及到。</li><li>Mute Breakpoints：哑的断点，选择这个后，所有断点变为灰色，断点失效，按F9则可以直接运行完程序。再次点击，断点变为红色，有效。如果只想使某一个断点失效，可以在断点上右键取消Enabled，如图2.4，则该行断点失效。</li></ul><p>更新程序，On ‘Update’ actions，执行更新操作时所做的事情，一般选择’Update classes and resources’，即更新类和资源文件。</p><p>一般配合热部署插件会更好用，如JRebel，这样就不用每次更改代码后还要去重新启动服务。如何激活JRebel，在最后章节附上。</p><p>下面的On frame deactivation，在IDEA窗口失去焦点时触发，即一般你从idea切换到浏览器的时候，idea会自动帮你做的事情，一般可以设置Do nothing，频繁切换会比较消耗资源的。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217092950.png" alt="图2.3"></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093016.png" alt="图2.4"></p><h3 id="三、变量查看"><a href="#三、变量查看" class="headerlink" title="三、变量查看"></a><strong>三、变量查看</strong></h3><p>在Debug过程中，跟踪查看变量的变化是非常必要的，这里就简单说下<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247488006&amp;idx=1&amp;sn=d5c66d84724b1deebac6604749d04bf5&amp;chksm=ebd62d2adca1a43cb136b5740621e25854537054b9b3cac7451fd21ea55c0fc247e07a49d8cd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">IDEA</a>中可以查看变量的几个地方，相信大部分人都了解。</p><p><strong>1、如下，在IDEA中，参数所在行后面会显示当前变量的值。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093236.png" alt=""></p><p><strong>2、光标悬停到参数上，显示当前变量信息。点击+号查看详情</strong></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093312.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093357.png" alt=""></p><p><strong>3、在Variables里查看，这里显示当前方法里的所有变量。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093439.png" alt=""></p><p><strong>4、在Watches里，点击New Watch，输入需要查看的变量。</strong>或者可以从Variables里拖到Watche里查看。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093454.png" alt=""></p><p>如果你发现你没有Watches，可能在下图所在的地方。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093511.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093526.png" alt=""></p><h3 id="四、计算表达式"><a href="#四、计算表达式" class="headerlink" title="四、计算表达式"></a><strong>四、计算表达式</strong></h3><p>在前面提到的计算表达式如图4.1的按钮，Evaluate Expression (Alt + F8) 。可以使用这个操作在调试过程中计算某个表达式的值，而不用再去打印信息。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093542.png" alt=""></p><p><strong>1、按Alt + F8或按钮，或者，你可以选中某个表达式再Alt + F8，弹出计算表达式的窗口</strong>，如下，回车或点击Evaluate计算表达式的值。</p><p>这个表达式不仅可以是一般变量或参数，也可以是方法，当你的一行代码中调用了几个方法时，就可以通过这种方式查看查看某个方法的返回值。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093557.png" alt=""></p><p><strong>2、设置变量，在计算表达式的框里，可以改变变量的值</strong>，这样有时候就能很方便我们去调试各种值的情况了不是。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093622.png" alt=""></p><h3 id="五、智能步入"><a href="#五、智能步入" class="headerlink" title="五、智能步入"></a><strong>五、智能步入</strong></h3><p>想想，一行代码里有好几个方法，怎么只选择某一个方法进入。之前提到过使用Step Into (Alt + F7) 或者 Force Step Into (Alt + Shift + F7)进入到方法内部，但这两个操作会根据方法调用顺序依次进入，这比较麻烦。</p><p>那么智能步入就很方便了，智能步入，这个功能在Run里可以看到，Smart Step Into (Shift + F7)，如图5.1</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093705.png" alt=""></p><p>按Shift + F7，会自动定位到当前断点行，并列出需要进入的方法，</p><p>点击方法进入方法内部。</p><p>如果只有一个方法，则直接进入，类似Force Step Into。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093824.png" alt=""></p><h3 id="六、断点条件设置"><a href="#六、断点条件设置" class="headerlink" title="六、断点条件设置"></a><strong>六、断点条件设置</strong></h3><p>通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。</p><p>通常，当我们在遍历一个比较大的集合或数组时，在循环内设置了一个断点，难道我们要一个一个去看变量的值？那肯定很累，说不定你还错过这个值得重新来一次。</p><p><strong>1、在断点上右键直接设置当前断点的条件</strong>，我设置exist为true时断点才生效。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093913.png" alt=""></p><p><strong>2、点击View Breakpoints (Ctrl + Shift + F8)，查看所有断点。</strong></p><p>Java Line Breakpoints 显示了所有的断点，在右边勾选Condition，设置断点的条件。</p><p>勾选Log message to console，则会将当前断点行输出到控制台。</p><p>勾选Evaluate and log，可以在执行这行代码是计算表达式的值，并将结果输出到控制台。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093937.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217093948.png" alt=""></p><p><strong>3、再说说右边的Filters过滤</strong>，这些一般情况下不常用，简单说下意思。</p><p>Instance filters：实例过滤，输入实例ID(如下图中的实例ID)，但是我这里没有成功，不知道什么原因，知道的朋友留个言。</p><p>Class filters：类过滤，根据类名过滤，同样没有成功….</p><p>Pass count：用于循环中，如果断点在循环中，可以设置该值，循环多少次后停在断点处，之后的循环都会停在断点处。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217094205.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217094220.png" alt=""></p><p><strong>4、异常断点，通过设置异常断点</strong>，在程序中出现需要拦截的异常时，会自动定位到异常行。</p><p>如图，点击+号添加Java Exception Breakpoints，添加异常断点。然后输入需要断点的异常类，如图6.7，之后可以在Java Exception Breakpoints里看到添加的异常断点。</p><p>我这里添加了一个NullPointerException异常断点，如图，出现空指针异常后，自动定位在空指针异常行。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217094307.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217094323.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217094357.png" alt=""></p><h3 id="七、多线程调试"><a href="#七、多线程调试" class="headerlink" title="七、多线程调试"></a><strong>七、多线程调试</strong></h3><p>一般情况下我们调试的时候是在一个线程中的，一步一步往下走。但有时候你会发现在Debug的时候，想发起另外一个请求都无法进行了？</p><p>那是因为IDEA在Debug时默认阻塞级别是ALL，会阻塞其它线程，只有在当前调试线程走完时才会走其它线程。可以在View Breakpoints里选择Thread，如图，然后点击Make Default设置为默认选项。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217094437.png" alt=""></p><p>切换线程，在图中Frames的下拉列表里，可以切换当前的线程，如下我这里有两个Debug的线程，切换另外一个则进入另一个Debug的线程。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217094520.png" alt=""></p><h3 id="八、回退断点"><a href="#八、回退断点" class="headerlink" title="八、回退断点"></a><strong>八、回退断点</strong></h3><p>在调试的时候，想要重新走一下流程而不用再次发起一个请求？</p><p><strong>1、首先认识下这个方法调用栈</strong>，如图，首先请求进入DemoController的insertDemo方法，然后调用insert方法，其它的invoke我们且先不管，最上面的方法是当前断点所在的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217094604.png" alt=""></p><p><strong>2、断点回退</strong></p><p>所谓的断点回退，其实就是回退到上一个方法调用的开始处，在<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247488006&amp;idx=1&amp;sn=d5c66d84724b1deebac6604749d04bf5&amp;chksm=ebd62d2adca1a43cb136b5740621e25854537054b9b3cac7451fd21ea55c0fc247e07a49d8cd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">IDEA</a>里测试无法一行一行地回退或回到到上一个断点处，而是回到上一个方法。</p><p>回退的方式有两种，一种是Drop Frame按钮，按调用的方法逐步回退，包括三方类库的其它方法(取消Show All Frames按钮会显示三方类库的方法，下图2)。</p><p>第二种方式，在调用栈方法上选择要回退的方法，右键选择Drop Frame，回退到该方法的上一个方法调用处，此时再按F9(Resume Program)，可以看到程序进入到该方法的断点处了。</p><p><strong>但有一点需要注意，断点回退只能重新走一下流程，之前的某些参数/数据的状态已经改变了的是无法回退到之前的状态的，如对象、集合、更新了数据库数据等等。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217094628.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217094639.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217094650.png" alt=""></p><h3 id="九、中断Debug"><a href="#九、中断Debug" class="headerlink" title="九、中断Debug"></a><strong>九、中断Debug</strong></h3><p>想要在Debug的时候，中断请求，不要再走剩余的流程了？</p><p>有些时候，我们看到传入的参数有误后，不想走后面的流程了，怎么中断这次请求呢(后面的流程要删除数据库数据呢….)，难道要关闭服务重新启动程序？嗯，我以前也是这么干的。</p><p>确切的说，我也没发现可以直接中断请求的方式(除了关闭服务)，但可以通过Force Return，即强制返回来避免后续的流程。</p><p>点击Force Return，弹出Return Value的窗口，我这个方法的返回类型为Map，所以，我这里直接返回 results，来强制返回，从而不再进行后续的流程。或者你可以new HashMap&lt;&gt;()。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217094758.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191217094823.png" alt=""></p><p>参考文章:<br><a href="https://mp.weixin.qq.com/s/6Hz2Tc1OGBwa6Z7wuUXCnw" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Debug用来追踪代码的运行流程，通常在程序运行过程中出现异常，启用Debug模式可以分析定位异常发生的位置，以及在运行过程中参数的变化。通常我们也可以启用Debug模式来跟踪代码的运行流程去学习三方框架的源码。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="develop" scheme="https://removeif.github.io/categories/develop/"/>
    
    
      <category term="debug" scheme="https://removeif.github.io/tags/debug/"/>
    
      <category term="调试代码" scheme="https://removeif.github.io/tags/%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>动态规划DP算法详解</title>
    <link href="https://removeif.github.io/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://removeif.github.io/algorithm/动态规划DP算法详解.html</id>
    <published>2019-12-14T10:39:01.000Z</published>
    <updated>2019-12-14T10:42:12.423Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>动态规划</strong>（dynamic programing）和分治法类似，都是通过组合子问题的解来求解原问题的解。（在经典排序算法中的二路归并排序和快速排序都用到了分而治之的思想-分治法）。</p><p><strong>分治法</strong>是将原问题划分为没有交集，相互独立的子问题，并分别求解后再进行合并，求出原问题的解。</p><p>动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。分治法会做许多不必要的工作，它会反复地求解那些公共子问题。动态规划算法对每个子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都需要重新计算。<br><a id="more"></a></p><p>动态规划上用来求解最优化问题（optimization problem）。</p><p>可以按照下面四个步骤来<strong>设计</strong>一个<strong>动态规划算法</strong>：</p><p>1、刻画一个最优解的结构特征。</p><p>2、递归地定义最优解的值。</p><p>3、计算最优解的值，通常采用自底向上的方法。</p><p>4、利用计算出的信息构造一个最优解。</p><p>对于确定状态转移方程就在第一步和第二步中，首先要确定问题的决策对象，接着对决策对象划分阶段并确定各个阶段的状态变量，最后建立各阶段的状态变量的转移方程。</p><p>例如用dp[i]表示以序列中第i个数字结尾的最长递增子序列长度和最长公共子序列中用dp[i][j]表示的两个字符串中前 i、 j 个字符的最长公共子序列，我们就是通过对这两个数字量的不断求解最终得到答案的。这个数字量就被我们称为状态。状态是描述问题当前状况的一个数字量。首先，它是数字的，是可以被抽象出来保存在内存中的。其次，它可以完全的表示一个状态的特征，而不需要其他任何的辅助信息。最后，也是状态最重要的特点，状态间的转移完全依赖于各个状态本身，如最长递增子序列中，dp[x]的值由 dp<a href="i &lt; x">i</a>的值确定。若我们在分析动态规划问题的时候能够找到这样一个符合以上所有条件的状态，那么多半这个问题是可以被正确解出的。所以说，解动态规划问题的关键，就是寻找一个好的状态。</p><h4 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h4><p>用动态规划求解最优化问题的第一步就是刻画一个最优解的结构特征。如果一个问题的最优解包含其子问题的最优解，我们称此问题具有最优子结构性质。因此，某个问题是否适合用动态规划，它是否具有最优子结构性质是一个好的标准。使用动态规划方法时，我们用子问题的最优解来构造原问题的最优解。</p><h4 id="如何发掘最优子结构的性质？"><a href="#如何发掘最优子结构的性质？" class="headerlink" title="如何发掘最优子结构的性质？"></a>如何发掘最优子结构的性质？</h4><p>1、证明问题最优解的第一个组成部分是做出一个选择，而做出这个选择将会产生一个或多个待解的子问题。</p><p>2、对一个给定问题，在其可能的第一步选择中，假定已经知道哪种选择才会得到最优解。而我们并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择。</p><p>3、给定获取的最优解选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间。</p><p>4、利用“剪切-粘贴(cut and paste)”技术证明作为构成原问题最优解组成部分，每个子问题的解就是它本身的最优解。</p><p>反证法：假定子问题的解不是自身的最优解，那么我们就可以从原问题中剪切掉这些非最优解，将最优解粘贴进去，从而得到原问题一个更优的解，这个解与最初的解的前提假设矛盾。</p><h4 id="刻画子问题空间的经验"><a href="#刻画子问题空间的经验" class="headerlink" title="刻画子问题空间的经验"></a>刻画子问题空间的经验</h4><p>保持子问题空间尽量简单，只在必要时才扩展它。例如下一节的例子，求钢条切割的最大收益问题中，子问题空间包含的问题为：对每个i值，长度为i的钢条最优切割问题。</p><h4 id="对于不同问题领域，最优子结构的不同体现在两个方面："><a href="#对于不同问题领域，最优子结构的不同体现在两个方面：" class="headerlink" title="对于不同问题领域，最优子结构的不同体现在两个方面："></a>对于不同问题领域，最优子结构的不同体现在两个方面：</h4><ol><li>原问题的最优解中涉及到多个子问题。</li><li>在确定最优解使用哪些子问题时，需要考察多少种选择。</li></ol><h4 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h4><p>适合用动态规划方法求解最优化问题的第二个性质是子问题的空间必须足够小，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。动态规划算法会对<strong>重叠的子问题只求解一次</strong>，并<strong>保存在一张表里</strong>，需要用的时候直接查表即可，每次查表的时间代价为常量O(1)。</p><h4 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h4><p><strong>动态规划的核心是状态和状态转移方程。</strong></p><p>在记忆化搜索中，可以为正在处理的表项声明一个引用，简化对它的读写操作；</p><p>动态规划解决的是多阶段决策问题；</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</span><br></pre></td></tr></table></figure><p>和分治法最大的区别在于：适合于用动态规划的问题，经过分解以后得到的子问题往往不是相互独立的（即下一个子阶段的求解是建立在上一个子阶段的基础之上，进行进一步的求解，而不是相互独立的问题）</p><p>动态规划问题一般由难到易分为一维动态规划，二维动态规划，多维动态规划，以及多变量动态规划问题。其中多维动态规划问题又可以进行降维。动态规划问题求解的最重要的一步就是求解出 <code>状态转移方程</code></p><p><strong>特性</strong></p><ul><li>最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理.</li><li>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关</li><li>有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势，动态规划可以避免多次计算）</li></ul><p><strong>动态规划的解题核心主要分为两步：</strong></p><ol><li>第一步：状态的定义</li><li>第二步：状态转移方程的定义</li></ol><p>在这里，我们为了避免混淆用“状态”这个词来替代“问题”这个词。“问题”表示的含义类似：题目、要求解的内容、题干中的疑问句这样的概念。状态表示我们在求解问题之中对问题的分析转化。</p><p><strong>第一步：状态的定义</strong></p><p>有的问题过于抽象，或者过于啰嗦干扰我们解题的思路，我们要做的就是将题干中的问题进行转化（换一种说法，含义不变）。转化成一系列同类问题的某个解的情况，比如说：</p><blockquote><p>题目：求一个数列中最大连续子序列的和。</p></blockquote><p>我们要将这个原问题转化为：</p><blockquote><p>状态定义：Fk是第k项前的最大序列和，求F1～FN中最大值。</p></blockquote><p>通过换一种表述方式，我们清晰的发现了解决问题的思路，如何求出F1～FN中的最大值是解决原问题的关键部分。上述将原问题转化成另一种表述方式的过程叫做：状态的定义。这样的状态定义给出了一种类似通解的思路，把一个原来毫无头绪的问题转换成了可以求解的问题。</p><p><strong>第二步：状态转移方程的定义</strong></p><p>在进行了状态的定义后，自然而然的想到去求解F1～FN中最大值。这也是状态定义的作用，让我们把一个总体的问题转化成一系列问题，而第二步：状态转移方程的定义则告诉我们如何去求解一个问题，对于上述已经转换成一系列问题我们要关注的点就在于：如何能够用前一项或者前几项的信息得到下一项，这种从最优子状态转换为下一个最优状态的思路就是动态规划的核心。<br>对于上面的例子题目来说，状态转移方程的定义应该是：</p><blockquote><p>Fk=max{Fk-1+Ak,Ak}<br>Fk是前k项的和，Ak是第k项的值</p></blockquote><p>仔细思考一番，我们能够得到这样的结论，对于前k个项的最大子序列和是前k-1项的最大子序列和Fk与第k项的和、或者第k项两者中较大的。如果大家还是不能理解这个原理建议用演算纸自己计算一番，这里就不过多赘述了。这种状态转移的思路就是DP的核心。</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>动态规划中当前的状态往往依赖于前一阶段的状态和前一阶段的决策结果。例如我们知道了第i个阶段的状态Si以及决策Ui，那么第i+1阶段的状态Si+1也就确定了。所以解决动态规划问题的关键就是确定状态转移方程，一旦状态转移方程确定了，那么我们就可以根据方程式进行编码。</p><h4 id="各种模型的状态转移方程汇总如下："><a href="#各种模型的状态转移方程汇总如下：" class="headerlink" title="各种模型的状态转移方程汇总如下："></a>各种模型的状态转移方程汇总如下：</h4><h5 id="1、最长公共子串"><a href="#1、最长公共子串" class="headerlink" title="1、最长公共子串"></a>1、最长公共子串</h5><p>假设两个字符串为str1和str2，它们的长度分别为n和m。d[i][j]表示str1中前i个字符与str2中前j个字符分别组成的两个前缀字符串的最长公共长度。这样就把长度为n的str1和长度为m的str2划分成长度为i和长度为j的子问题进行求解。状态转移方程如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[0][j] = 0; (0&lt;=j&lt;=m)</span><br><span class="line">dp[i][0] = 0; (0&lt;=i&lt;=n)</span><br><span class="line">dp[i][j] = dp[i-1][j-1] +1; (str1[i] == str2[j])</span><br><span class="line">dp[i][j] = 0; (str1[i] != str2[j])</span><br></pre></td></tr></table></figure><p>因为最长公共子串要求必须在原串中是连续的，所以一但某处出现不匹配的情况，此处的值就重置为0。</p><p>详细代码请看<a href="http://www.cnblogs.com/tgycoder/p/5037583.html" target="_blank" rel="noopener">最长公共子串</a>。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="hljs-keyword">char</span> str1[MAXSIZE];</span><br><span class="line"><span class="hljs-keyword">char</span> str2[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> dp[MAXSIZE][MAXSIZE];</span><br><span class="line"><span class="hljs-comment">//'y'代表str1[i] = str2[j];'n'反之</span></span><br><span class="line"><span class="hljs-keyword">char</span> path[MAXSIZE][MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printComStr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (path[i][j] == <span class="hljs-string">'n'</span> || i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (path[i][j] == <span class="hljs-string">'y'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printComStr(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; str1[i - <span class="hljs-number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n, m;</span><br><span class="line">    <span class="hljs-keyword">int</span> indexi, indexj;</span><br><span class="line">    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-built_in">cin</span> &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">    n = <span class="hljs-built_in">strlen</span>(str1);</span><br><span class="line">    m = <span class="hljs-built_in">strlen</span>(str2);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n;i++)</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][j] = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (str1[i - <span class="hljs-number">1</span>] == str2[j - <span class="hljs-number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;</span><br><span class="line">            path[i][j] = <span class="hljs-string">'y'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = <span class="hljs-number">0</span>;</span><br><span class="line">            path[i][j] = <span class="hljs-string">'n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (ans &lt; dp[i][j])</span><br><span class="line">        &#123;</span><br><span class="line">            ans = dp[i][j];</span><br><span class="line">            indexi = i;</span><br><span class="line">            indexj = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>; </span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; indexi &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; indexj &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    printComStr(indexi, indexj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、最长公共子序列"><a href="#2、最长公共子序列" class="headerlink" title="2、最长公共子序列"></a>2、最长公共子序列</h5><p>区分一下，最长公共子序列不同于最长公共子串，序列是保持子序列字符串的下标在str1和str2中的下标顺序是递增的，该字符串在原串中并不一定是连续的。同样的我们可以假设dp[i][j]表示为字符串str1的前i个字符和字符串str2的前j个字符的最长公共子序列的长度。状态转移方程如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[0][j] = 0; (0&lt;=j&lt;=m)</span><br><span class="line">dp[i][0] = 0; (0&lt;=i&lt;=n)</span><br><span class="line">dp[i][j] = dp[i-1][j-1] +1; (str1[i-1] == str2[j-1])</span><br><span class="line">dp[i][j] = max&#123;dp[i][j-1],dp[i-1][j]&#125;; (str1[i-1] != str2[j-1])</span><br></pre></td></tr></table></figure><p> 详细代码请看<a href="http://www.cnblogs.com/tgycoder/p/5034457.html" target="_blank" rel="noopener">最长公共子序列</a>。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 101</span></span><br><span class="line"><span class="hljs-keyword">char</span> str1[MAXSIZE];</span><br><span class="line"><span class="hljs-keyword">char</span> str2[MAXSIZE];</span><br><span class="line"><span class="hljs-comment">//'l'表示dp[i][j] = dp[i][j] = dp[i - 1][j];</span></span><br><span class="line"><span class="hljs-comment">//‘q’表示dp[i][j] = dp[i][j] = dp[i - 1][j];</span></span><br><span class="line"><span class="hljs-comment">//'u'表示dp[i][j] = dp[i][j - 1];</span></span><br><span class="line"><span class="hljs-keyword">char</span> path[MAXSIZE][MAXSIZE];</span><br><span class="line"><span class="hljs-keyword">int</span> dp[MAXSIZE][MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printLCS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (path[i][j] == <span class="hljs-string">'q'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printLCS(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; str1[i<span class="hljs-number">-1</span>] &lt;&lt; <span class="hljs-string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (path[i][j] == <span class="hljs-string">'u'</span>)</span><br><span class="line">        printLCS(i - <span class="hljs-number">1</span>, j);</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        printLCS(i, j - <span class="hljs-number">1</span>);</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n, m;</span><br><span class="line">    <span class="hljs-built_in">cin</span> &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">    n = <span class="hljs-built_in">strlen</span>(str1);</span><br><span class="line">    m = <span class="hljs-built_in">strlen</span>(str2);</span><br><span class="line">    <span class="hljs-comment">//初始化</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)</span><br><span class="line">        dp[i][j] = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (str1[i - <span class="hljs-number">1</span>] == str2[j - <span class="hljs-number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;</span><br><span class="line">            path[i][j] = <span class="hljs-string">'q'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>][j] &gt;= dp[i][j - <span class="hljs-number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];</span><br><span class="line">                path[i][j] = <span class="hljs-string">'u'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];</span><br><span class="line">                path[i][j] = <span class="hljs-string">'l'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    printLCS(n, m);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、最长递增子序列（最长递减子序列）"><a href="#3、最长递增子序列（最长递减子序列）" class="headerlink" title="3、最长递增子序列（最长递减子序列）"></a>3、最长递增子序列（最长递减子序列）</h5><p>因为两者的思路都是一样的，所以只给出最长递增子序列的状态转移方程。假设有序列{a1,a2,…,an}，我们求其最长递增子序列长度。按照递推求解的思想，我们用F[i]代表若递增子序列以ai结束时它的最长长度。当 i 较小，我们容易直接得出其值，如 F[1] = 1。那么，如何由已经求得的 F[i]值推得后面的值呢？假设，F[1]到F[x-1]的值都已经确定，注意到，以ax 结尾的递增子序列，除了长度为1的情况，其它情况中，ax都是紧跟在一个由 ai(i &lt; x)组成递增子序列之后。要求以ax结尾的最长递增子序列长度，我们依次比较 ax 与其之前所有的 ai(i &lt; x)， 若ai小于 ax，则说明ax可以跟在以ai结尾的递增子序列之后，形成一个新的递 增子序列。又因为以ai结尾的递增子序列最长长度已经求得，那么在这种情况下，由以 ai 结尾的最长递增子序列再加上 ax 得到的新的序列，其长度也可以确定，取所有这些长度的最大值，我们即能得到 F[x]的值。特殊的，当没有ai(i &lt; x)小 于ax， 那么以 ax 结尾的递增子序列最长长度为1。 即F[x] = max{1,F[i]+1|ai&lt;ax &amp;&amp; i&lt;x}。</p><p>详细代码请看<a href="http://www.cnblogs.com/tgycoder/p/5034131.html" target="_blank" rel="noopener">最长递增子序列</a>。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXSIZE = <span class="hljs-number">10</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MIN = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span> &#125;;</span><br><span class="line"><span class="hljs-keyword">int</span> F[MAXSIZE];</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> maxLen = MIN;</span><br><span class="line">    <span class="hljs-built_in">memset</span>(F, <span class="hljs-number">0</span>, MAXSIZE);</span><br><span class="line">    F[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (arr[i] &gt; arr[j] &amp;&amp; maxLen &lt; F[j])</span><br><span class="line">            &#123;</span><br><span class="line">                maxLen = F[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        F[i] = maxLen + <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">6</span>; k++)</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; F[k] &lt;&lt; <span class="hljs-string">' '</span>;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、最大子序列和的问题"><a href="#4、最大子序列和的问题" class="headerlink" title="4、最大子序列和的问题"></a>4、最大子序列和的问题</h5><p>假设有序列{a1,a2,…,an}，求子序列的和最大问题，我们用dp[i]表示以ai结尾的子序列的最大和。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[1] = a1; (a1&gt;=0 &amp;&amp; i == 1)</span><br><span class="line"></span><br><span class="line">dp[i] = dp[i-1]+ai; (ai&gt;=0 &amp;&amp; i&gt;=2)</span><br><span class="line"></span><br><span class="line">dp[i] = 0; (dp[i-1] + ai &lt;=0 &amp;&amp; i&gt;=2)</span><br></pre></td></tr></table></figure><p>详细代码请看<a href="http://www.cnblogs.com/tgycoder/p/5038268.html" target="_blank" rel="noopener">最大子序列的和</a>。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> a[MAXSIZE];</span><br><span class="line"><span class="hljs-keyword">int</span> dp[MAXSIZE];</span><br><span class="line"><span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n;</span><br><span class="line">    <span class="hljs-built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, MAXSIZE);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="hljs-built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (dp[i<span class="hljs-number">-1</span>] + a[i] &gt; <span class="hljs-number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="hljs-number">1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (max &lt; dp[i])</span><br><span class="line">            max = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5、数塔问题（动态搜索）"><a href="#5、数塔问题（动态搜索）" class="headerlink" title="5、数塔问题（动态搜索）"></a>5、数塔问题（动态搜索）</h5><p>给定一个数组data[n][m]构成一个数塔求从最上面走到最低端经过的路径和最大。可以假设dp[i][j]表示走到第i行第j列位置处的最大值，那么可以推出状态转移方程：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max&#123;dp[i-1][j-1],dp[i-1][j]&#125; + data[i][j];</span><br></pre></td></tr></table></figure><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span>(i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;</span><br><span class="line">     <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">         dp[i][j]=max&#123;dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j]&#125;+s[i][j]</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6、（01）背包问题"><a href="#6、（01）背包问题" class="headerlink" title="6、（01）背包问题"></a>6、（01）背包问题</h5><p>这是一个经典的动态规划问题，另外在贪心算法里也有背包问题，至于二者的区别在此就不做介绍了。</p><p>假设有N件物品和一个容量为V的背包。第i件物品的体积是v[i]，价值是c[i]，将哪些物品装入背包可使价值总和最大？</p><p>每一种物品都有两种可能即放入背包或者不放入背包。可以用dp[i][j]表示第i件物品放入容量为j的背包所得的最大价值，则状态转移方程可以推出如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=max&#123;dp[i-1][j-v[i]]+c[i],dp[i-1][j]&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= N;i++) <span class="hljs-comment">//枚举物品  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;= V;j++) <span class="hljs-comment">//枚举背包容量  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            f[i][j] = f[i - <span class="hljs-number">1</span>][j];  </span><br><span class="line">            <span class="hljs-keyword">if</span> (j &gt;= v[i])  </span><br><span class="line">            &#123;  </span><br><span class="line">                f[i][j] = Max(f[i - <span class="hljs-number">1</span>][j],f[i - <span class="hljs-number">1</span>][j - v[i]] + c[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">01背包问题与背包问题的区别在于，01背包，物品的选择只有两种一种是拿，另一种是不拿，而背包问题在于，物品可以只取一部分。所以01背包问题不能用贪心算法解决。</span><br><span class="line"></span><br><span class="line">以dp[i][j]表示用i种物品，重量为j表示所取得的价值。</span><br><span class="line"></span><br><span class="line">对于第i种物品，如果第i种物品重量大于j，就证明第i种物品肯定不能取，这时的dp[i][j]=dp[i-1][j]</span><br><span class="line"></span><br><span class="line">如果第i种物品重量小于j，那就会出现两种情况，采用i的话，物品价值dp[i][j]=采用前面的i-1种物品，所占用的重量为j-i.getweight,所产生的价值+第i 种物品的价值，。如果不采用i，价值为dp[i-1][j]。换成数学表达式就是dp[i][j]=Math.max(dp[i-1][j-weight]+value,dp[i-1][j]);</span><br><span class="line"></span><br><span class="line">比如当i=5,j=10时，dp[5][10]就代表了所取得的最大价值。到这里我们就完成了任务的一半，接下为我们要寻找到底哪些物品放入了背包，从前面的表达式我们可以发现，当dp[i][j]=dp[i-1][j-weight]时，这时为i的物品就会放入背包，所以我们从结果，开始往回走，遇到这种情况，就说明有物品放入背包，然后物品数减1，重量减去为i的重量，继续，最后就能求出哪 些物品放入背包了。</span><br></pre></td></tr></table></figure><p><strong>JAVA代码</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="hljs-keyword">int</span> allweight=<span class="hljs-number">12</span>;  <span class="hljs-comment">//总价值      </span></span><br><span class="line">         <span class="hljs-keyword">int</span> num=<span class="hljs-number">8</span>;   <span class="hljs-comment">//物品</span></span><br><span class="line">          bao[] baos=<span class="hljs-keyword">new</span> bao[num+<span class="hljs-number">1</span>];</span><br><span class="line">          baos[<span class="hljs-number">1</span>]=<span class="hljs-keyword">new</span> bao(<span class="hljs-number">2</span>, <span class="hljs-number">13</span>);</span><br><span class="line">          baos[<span class="hljs-number">2</span>]=<span class="hljs-keyword">new</span> bao(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);</span><br><span class="line">          baos[<span class="hljs-number">3</span>]=<span class="hljs-keyword">new</span> bao(<span class="hljs-number">3</span>, <span class="hljs-number">24</span>);</span><br><span class="line">          baos[<span class="hljs-number">4</span>]=<span class="hljs-keyword">new</span> bao(<span class="hljs-number">2</span>, <span class="hljs-number">15</span>);</span><br><span class="line">          baos[<span class="hljs-number">5</span>]=<span class="hljs-keyword">new</span> bao(<span class="hljs-number">4</span>, <span class="hljs-number">28</span>);</span><br><span class="line">          baos[<span class="hljs-number">6</span>]=<span class="hljs-keyword">new</span> bao(<span class="hljs-number">5</span>, <span class="hljs-number">33</span>);</span><br><span class="line">          baos[<span class="hljs-number">7</span>]=<span class="hljs-keyword">new</span> bao(<span class="hljs-number">3</span>, <span class="hljs-number">20</span>);</span><br><span class="line">          baos[<span class="hljs-number">8</span>]=<span class="hljs-keyword">new</span> bao(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);</span><br><span class="line">          <span class="hljs-keyword">int</span>[][] dp=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num+<span class="hljs-number">1</span>][allweight+<span class="hljs-number">1</span>];</span><br><span class="line">          <span class="hljs-comment">//构成动态规划表</span></span><br><span class="line">          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=num;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=allweight;j++)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      dp[i][j]=<span class="hljs-number">0</span>;</span><br><span class="line">                  &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                      <span class="hljs-keyword">if</span> (j&lt;baos[i].getWeight()) &#123;</span><br><span class="line">                        dp[i][j]=dp[i-<span class="hljs-number">1</span>][j];</span><br><span class="line">                    &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                        <span class="hljs-keyword">int</span> value=baos[i].getValue();</span><br><span class="line">                        <span class="hljs-keyword">int</span> weight=baos[i].getWeight();</span><br><span class="line">                        dp[i][j]=Math.max(dp[i-<span class="hljs-number">1</span>][j-weight]+value,dp[i-<span class="hljs-number">1</span>][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                  System.out.println(<span class="hljs-string">"dp"</span>+<span class="hljs-string">"["</span>+i+<span class="hljs-string">"]"</span>+<span class="hljs-string">"["</span>+j+<span class="hljs-string">"]"</span>+dp[i][j]);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="hljs-keyword">int</span> m=num;</span><br><span class="line">          <span class="hljs-keyword">int</span> n=allweight;</span><br><span class="line">          <span class="hljs-keyword">int</span> all=dp[m][n];</span><br><span class="line">          <span class="hljs-comment">//寻找哪些物品放入背包</span></span><br><span class="line">           <span class="hljs-keyword">while</span>(all&gt;=<span class="hljs-number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="hljs-keyword">if</span> (m&gt;<span class="hljs-number">0</span>&amp;&amp;dp[m][n]==dp[m-<span class="hljs-number">1</span>][n]) &#123;</span><br><span class="line">                   m=m-<span class="hljs-number">1</span>;</span><br><span class="line">                &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(baos[m]+<span class="hljs-string">"加入背包"</span>);</span><br><span class="line">                    m=m-<span class="hljs-number">1</span>;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (m==<span class="hljs-number">0</span>) &#123;</span><br><span class="line">                        <span class="hljs-keyword">return</span>;</span><br><span class="line">                    &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                        n=n-baos[m].getWeight();</span><br><span class="line">                        all=all-baos[m].getWeight();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以参照<a href="http://www.cnblogs.com/tgycoder/p/5042964.html" target="_blank" rel="noopener">动态规划 - 0-1背包问题的算法优化</a>、<a href="http://www.cnblogs.com/tgycoder/p/5329057.html" target="_blank" rel="noopener">动态规划-完全背包问题</a>、<a href="http://www.cnblogs.com/tgycoder/p/5329424.html" target="_blank" rel="noopener">动态规划-多重背包问题</a>、<a href="https://blog.csdn.net/qq_22222499/article/details/71017501" target="_blank" rel="noopener">01背包问题</a></p><h5 id="7、矩阵连乘（矩阵链问题）-参考《算法导论》"><a href="#7、矩阵连乘（矩阵链问题）-参考《算法导论》" class="headerlink" title="7、矩阵连乘（矩阵链问题）-参考《算法导论》"></a>7、矩阵连乘（矩阵链问题）-参考《算法导论》</h5><p>例如矩阵链&lt;A1,A2,A3&gt;,它们的维数分别为10<em>100,100</em>5,5<em>50，那么如果顺序相乘即((A1A2)A3)，共需10</em>100<em>5 + 10</em>5<em>50 = 7500次乘法，如果按照(A1(A2A3))顺序相乘，却需做100</em>5<em>50 + 10</em>100*50 = 75000次乘法。两者之间相差了10倍，所以说矩阵链的相乘顺序也决定了计算量的大小。</p><p>我们用利用动态规划的方式(dp[i][j]表示第i个矩阵至第j个矩阵这段的最优解,还有对于两个矩阵A(i,j)<em>B(j,k)则需要i</em>j*k次乘法)，推出状态转移方程：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = 0; (i ==j，表示只有一个矩阵，计算次数为0)</span><br><span class="line">dp[i][j] = min&#123;dp[i][k] + dp[k+1][j] + p[i-1]*p[k]*p[j]&#125;; (i&lt;j &amp;&amp; i&lt;=k&lt;j)            </span><br><span class="line">dp[1][n]即为最终求解.</span><br></pre></td></tr></table></figure><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> dp[MAXSIZE][MAXSIZE];<span class="hljs-comment">//存储最小的就算次数</span></span><br><span class="line"><span class="hljs-keyword">int</span> s[MAXSIZE][MAXSIZE];<span class="hljs-comment">//存储断点，用在输出上面</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> i, j, tmp；</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>; l &lt;= n; l++)&#123;<span class="hljs-comment">//j-i的长度,由于长度为1是相同的矩阵那么为0不用计算</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n - l + <span class="hljs-number">1</span>; i++)&#123;<span class="hljs-comment">//由于j-i =l - 1 , 那么j的最大值为n，所以i上限为 n - l+1;</span></span><br><span class="line">        j = i + l - <span class="hljs-number">1</span>;<span class="hljs-comment">//由于j-i = l - 1 , 那么j = l+i-1</span></span><br><span class="line">        dp[i][j] = dp[i + <span class="hljs-number">1</span>][j] + r[i] * c[i] * c[j];<span class="hljs-comment">//初始化，就是k = i；</span></span><br><span class="line">        s[i][j] = i;</span><br><span class="line">        <span class="hljs-keyword">for</span> (k = i + <span class="hljs-number">1</span>; k &lt; j; k++)&#123;<span class="hljs-comment">//循环枚举k i &lt; k &lt; j</span></span><br><span class="line">            tmp = dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + r[i] * c[k] * c[j];</span><br><span class="line">            <span class="hljs-keyword">if</span> (dp[i][j] &gt; tmp)&#123;</span><br><span class="line">                dp[i][j] = tmp;<span class="hljs-comment">//更新为最小值</span></span><br><span class="line">                s[i][j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//递归调用输出</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (i == j)&#123;</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"A%d"</span>, i);<span class="hljs-comment">//当两个相等的时候就不用继续递归就输出A</span></span><br><span class="line">        <span class="hljs-keyword">return</span>;<span class="hljs-comment">//返回上一层</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"("</span>);</span><br><span class="line">        output(i, s[i][j]);</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" x "</span>);</span><br><span class="line">        output(s[i][j] + <span class="hljs-number">1</span>, j);</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>太难了，没事多来看看示例希望早日彻底吃透！ </p><p>参考文章:<br><a href="https://www.cnblogs.com/tgycoder/p/5037559.html" target="_blank" rel="noopener">参考链接1</a><br><a href="https://www.cnblogs.com/George1994/p/6710675.html" target="_blank" rel="noopener">参考链接2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;（dynamic programing）和分治法类似，都是通过组合子问题的解来求解原问题的解。（在经典排序算法中的二路归并排序和快速排序都用到了分而治之的思想-分治法）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分治法&lt;/strong&gt;是将原问题划分为没有交集，相互独立的子问题，并分别求解后再进行合并，求出原问题的解。&lt;/p&gt;
&lt;p&gt;动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。分治法会做许多不必要的工作，它会反复地求解那些公共子问题。动态规划算法对每个子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都需要重新计算。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://removeif.github.io/categories/algorithm/"/>
    
    
      <category term="动态规划" scheme="https://removeif.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="dp" scheme="https://removeif.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>算法成长之路leetcode9-10</title>
    <link href="https://removeif.github.io/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode9-10.html"/>
    <id>https://removeif.github.io/algorithm/算法成长之路leetcode9-10.html</id>
    <published>2019-12-14T08:32:33.000Z</published>
    <updated>2019-12-14T09:11:18.965Z</updated>
    
    <content type="html"><![CDATA[<h3 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9. Palindrome Number</a></h3><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.<br><a id="more"></a></p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 121</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">Coud you solve it without converting the integer to a string?</span><br></pre></td></tr></table></figure><h4 id="Java-题解"><a href="#Java-题解" class="headerlink" title="Java 题解"></a>Java 题解</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> algorithm;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leetcode9</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 示例 1:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: 121</span></span><br><span class="line"><span class="hljs-comment">     * 输出: true</span></span><br><span class="line"><span class="hljs-comment">     * 示例 2:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: -121</span></span><br><span class="line"><span class="hljs-comment">     * 输出: false</span></span><br><span class="line"><span class="hljs-comment">     * 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span></span><br><span class="line"><span class="hljs-comment">     * 示例 3:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: 10</span></span><br><span class="line"><span class="hljs-comment">     * 输出: false</span></span><br><span class="line"><span class="hljs-comment">     * 解释: 从右向左读, 为 01 。因此它不是一个回文数。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment">     * 链接：https://leetcode-cn.com/problems/palindrome-number</span></span><br><span class="line"><span class="hljs-comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; <span class="hljs-number">10</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String source = x + <span class="hljs-string">""</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> length = source.length();</span><br><span class="line">        <span class="hljs-comment">//  mid中间位置1，mid1中间位置2</span></span><br><span class="line">        <span class="hljs-keyword">int</span> mid, mid1;</span><br><span class="line">        <span class="hljs-comment">// 偶数</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (length % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-comment">// 如 1221 偶数，中间位置分别为2，2</span></span><br><span class="line">            mid = length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;</span><br><span class="line">            mid1 = mid + <span class="hljs-number">1</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// 奇数时，212，中间位置分别是1，1</span></span><br><span class="line">            mid = length / <span class="hljs-number">2</span>;</span><br><span class="line">            mid1 = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 确定中心位置向两边扩展是否相等，直到扩展完位置</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (mid &gt;= <span class="hljs-number">0</span> &amp;&amp; source.charAt(mid) == source.charAt(mid1)) &#123;</span><br><span class="line">            mid = mid - <span class="hljs-number">1</span>;</span><br><span class="line">            mid1 = mid1 + <span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 如果循环结束并且所有数都遍历完</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (mid == -<span class="hljs-number">1</span> &amp;&amp; mid1 == length) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 特殊情况：</span></span><br><span class="line">        <span class="hljs-comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="hljs-comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="hljs-comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="hljs-comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; x != <span class="hljs-number">0</span>)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 一位一位反转的数</span></span><br><span class="line">        <span class="hljs-keyword">int</span> revertedNumber = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-comment">// 如121</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;</span><br><span class="line">            x /= <span class="hljs-number">10</span>;</span><br><span class="line">            System.out.println(<span class="hljs-string">"x="</span> + x + <span class="hljs-string">",revertedNumber="</span> + revertedNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="hljs-comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="hljs-comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="hljs-number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">         * -1</span></span><br><span class="line"><span class="hljs-comment">         * 121</span></span><br><span class="line"><span class="hljs-comment">         * 222</span></span><br><span class="line"><span class="hljs-comment">         * 2222</span></span><br><span class="line"><span class="hljs-comment">         * 1221</span></span><br><span class="line"><span class="hljs-comment">         * -12</span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">        System.out.println(isPalindrome(<span class="hljs-number">1221</span>));</span><br><span class="line">        System.out.println(isPalindrome1(<span class="hljs-number">121</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. Regular Expression Matching</a></h3><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’.</p><p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).</p><p>Note:</p><p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &apos;&apos; means zero or more of the preceding element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;cab&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;misisp*.&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h4 id="JAVA-题解"><a href="#JAVA-题解" class="headerlink" title="JAVA 题解"></a>JAVA 题解</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leetcode10</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * '.' 匹配任意单个字符</span></span><br><span class="line"><span class="hljs-comment">     * '*' 匹配零个或多个前面的那一个元素</span></span><br><span class="line"><span class="hljs-comment">     * 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 说明:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * s 可能为空，且只包含从 a-z 的小写字母。</span></span><br><span class="line"><span class="hljs-comment">     * p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</span></span><br><span class="line"><span class="hljs-comment">     * 示例 1:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入:</span></span><br><span class="line"><span class="hljs-comment">     * s = "aa"</span></span><br><span class="line"><span class="hljs-comment">     * p = "a"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: false</span></span><br><span class="line"><span class="hljs-comment">     * 解释: "a" 无法匹配 "aa" 整个字符串。</span></span><br><span class="line"><span class="hljs-comment">     * 示例 2:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入:</span></span><br><span class="line"><span class="hljs-comment">     * s = "aa"</span></span><br><span class="line"><span class="hljs-comment">     * p = "a*"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: true</span></span><br><span class="line"><span class="hljs-comment">     * 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。</span></span><br><span class="line"><span class="hljs-comment">     * 示例 3:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入:</span></span><br><span class="line"><span class="hljs-comment">     * s = "ab"</span></span><br><span class="line"><span class="hljs-comment">     * p = ".*"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: true</span></span><br><span class="line"><span class="hljs-comment">     * 解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。</span></span><br><span class="line"><span class="hljs-comment">     * 示例 4:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入:</span></span><br><span class="line"><span class="hljs-comment">     * s = "aab"</span></span><br><span class="line"><span class="hljs-comment">     * p = "c*a*b"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: true</span></span><br><span class="line"><span class="hljs-comment">     * 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。</span></span><br><span class="line"><span class="hljs-comment">     * 示例 5:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入:</span></span><br><span class="line"><span class="hljs-comment">     * s = "mississippi"</span></span><br><span class="line"><span class="hljs-comment">     * p = "mis*is*p*."</span></span><br><span class="line"><span class="hljs-comment">     * 输出: false</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment">     * 链接：https://leetcode-cn.com/problems/regular-expression-matching</span></span><br><span class="line"><span class="hljs-comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 如果模式串中有星号，它会出现在第二个位置，</span></span><br><span class="line"><span class="hljs-comment">     * 即pattern[1] 。这种情况下，我们可以直接忽略模式串中这一部分，</span></span><br><span class="line"><span class="hljs-comment">     * 或者删除匹配串的第一个字符，前提是它能够匹配模式串当前位置字符，即 pattern[0] 。</span></span><br><span class="line"><span class="hljs-comment">     * 如果两种操作中有任何一种使得剩下的字符串能匹配，那么初始时，匹配串和模式串就可以被匹配。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> text</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pattern</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String text, String pattern)</span> </span>&#123; <span class="hljs-comment">// 递归回溯</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (pattern.isEmpty()) <span class="hljs-keyword">return</span> text.isEmpty();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">boolean</span> first_match = (!text.isEmpty() &amp;&amp;</span><br><span class="line">                (pattern.charAt(<span class="hljs-number">0</span>) == text.charAt(<span class="hljs-number">0</span>) || pattern.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">'.'</span>));<span class="hljs-comment">// 判断第一个是否相等</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="hljs-string">"t="</span>+text+<span class="hljs-string">",p="</span>+pattern+<span class="hljs-string">",firstM="</span>+first_match);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (pattern.length() &gt;= <span class="hljs-number">2</span> &amp;&amp; pattern.charAt(<span class="hljs-number">1</span>) == <span class="hljs-string">'*'</span>)&#123; <span class="hljs-comment">// 长度&gt;=2 并且p第二个是*</span></span><br><span class="line">            System.out.println(<span class="hljs-string">"if1"</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> (isMatch(text, pattern.substring(<span class="hljs-number">2</span>)) || <span class="hljs-comment">// 直接忽略模式串中这一部分 如t=abc,p=a*. 直接忽略 a*</span></span><br><span class="line">                    (first_match &amp;&amp; isMatch(text.substring(<span class="hljs-number">1</span>), pattern))); <span class="hljs-comment">// 删除匹配串的第一个字符</span></span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"if2"</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> first_match &amp;&amp; isMatch(text.substring(<span class="hljs-number">1</span>), pattern.substring(<span class="hljs-number">1</span>));<span class="hljs-comment">// 第一个匹配后，后面逐个匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 状态</span></span><br><span class="line"><span class="hljs-comment">     * 首先状态 dp 一定能自己想出来。</span></span><br><span class="line"><span class="hljs-comment">     * dp[i][j] 表示 s 的前 ii 个是否能被 p 的前 jj 个匹配</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 转移方程</span></span><br><span class="line"><span class="hljs-comment">     * 怎么想转移方程？首先想的时候从已经求出了 dp[i-1][j-1] 入手，再加上已知 s[i]、p[j]，要想的问题就是怎么去求 dp[i][j]。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 已知 dp[i-1][j-1] 意思就是前面子串都匹配上了，不知道新的一位的情况。</span></span><br><span class="line"><span class="hljs-comment">     * 那就分情况考虑，所以对于新的一位 p[j] s[i] 的值不同，要分情况讨论：</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 考虑最简单的 p[j] == s[i] : dp[i][j] = dp[i-1][j-1]</span></span><br><span class="line"><span class="hljs-comment">     * 然后从 p[j] 可能的情况来考虑，让 p[j]=各种能等于的东西。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * p[j] == "." : dp[i][j] = dp[i-1][j-1]</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * p[j] ==" * ":</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 第一个难想出来的点：怎么区分 *∗ 的两种讨论情况</span></span><br><span class="line"><span class="hljs-comment">     * 首先给了 *，明白 * 的含义是 匹配零个或多个前面的那一个元素，所以要考虑他前面的元素 p[j-1]。* 跟着他前一个字符走，前一个能匹配上 s[i]，* 才能有用，前一个都不能匹配上 s[i]，* 也无能为力，只能让前一个字符消失，也就是匹配 00 次前一个字符。</span></span><br><span class="line"><span class="hljs-comment">     * 所以按照 p[j-1] 和 s[i] 是否相等，我们分为两种情况：</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 3.1 p[j-1] != s[i] : dp[i][j] = dp[i][j-2]</span></span><br><span class="line"><span class="hljs-comment">     * 这就是刚才说的那种前一个字符匹配不上的情况。</span></span><br><span class="line"><span class="hljs-comment">     * 比如(ab, abc * )。遇到 * 往前看两个，发现前面 s[i] 的 ab 对 p[j-2] 的 ab 能匹配，虽然后面是 c*，但是可以看做匹配 00 次 c，相当于直接去掉 c *，所以也是 True。注意 (ab, abc**) 是 False。</span></span><br><span class="line"><span class="hljs-comment">     * 3.2 p[j-1] == s[i] or p[j-1] == "."：</span></span><br><span class="line"><span class="hljs-comment">     * * 前面那个字符，能匹配 s[i]，或者 * 前面那个字符是万能的 .</span></span><br><span class="line"><span class="hljs-comment">     * 因为 . * 就相当于 . .，那就只要看前面可不可以匹配就行。</span></span><br><span class="line"><span class="hljs-comment">     * 比如 (##b , ###b *)，或者 ( ##b , ### . * ) 只看 ### 后面一定是能够匹配上的。</span></span><br><span class="line"><span class="hljs-comment">     * 所以要看 b 和 b * 前面那部分 ## 的地方匹不匹配。</span></span><br><span class="line"><span class="hljs-comment">     * 第二个难想出来的点：怎么判断前面是否匹配</span></span><br><span class="line"><span class="hljs-comment">     * dp[i][j] = dp[i-1][j] // 多个字符匹配的情况</span></span><br><span class="line"><span class="hljs-comment">     * or dp[i][j] = dp[i][j-1] // 单个字符匹配的情况</span></span><br><span class="line"><span class="hljs-comment">     * or dp[i][j] = dp[i][j-2] // 没有匹配的情况</span></span><br><span class="line"><span class="hljs-comment">     * 看 ### 匹不匹配，不是直接只看 ### 匹不匹配，要综合后面的 b b* 来分析</span></span><br><span class="line"><span class="hljs-comment">     * 这三种情况是 oror 的关系，满足任意一种都可以匹配上，同时是最难以理解的地方：</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * dp[i-1][j] 就是看 s 里 b 多不多， ### 和 ###b * 是否匹配，一旦匹配，s 后面再添个 b 也不影响，因为有 * 在，也就是 ###b 和 ###b *也会匹配。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * dp[i][j-1] 就是去掉 * 的那部分，###b 和 ###b 是否匹配，比如 qqb qqb</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * dp[i][j-2] 就是 去掉多余的 b *，p 本身之前的能否匹配，###b 和 ### 是否匹配，比如 qqb qqbb* 之前的 qqb qqb 就可以匹配，那多了的 b * 也无所谓，因为 b * 可以是匹配 00 次 b，相当于 b * 可以直接去掉了。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 三种满足一种就能匹配上。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 为什么没有 dp[i-1][j-2] 的情况？ 就是 ### 和 ### 是否匹配？因为这种情况已经是 dp[i][j-1] 的子问题。也就是 s[i]==p[j-1]，则 dp[i-1][j-2]=dp[i][j-1]。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 最后来个归纳：</span></span><br><span class="line"><span class="hljs-comment">     * 如果 p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1]；</span></span><br><span class="line"><span class="hljs-comment">     * 如果 p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1]；</span></span><br><span class="line"><span class="hljs-comment">     * 如果 p.charAt(j) == '*'：</span></span><br><span class="line"><span class="hljs-comment">     * 如果 p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty</span></span><br><span class="line"><span class="hljs-comment">     * 如果 p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.'：</span></span><br><span class="line"><span class="hljs-comment">     * dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a</span></span><br><span class="line"><span class="hljs-comment">     * or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a</span></span><br><span class="line"><span class="hljs-comment">     * or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 作者：kao-la-7</span></span><br><span class="line"><span class="hljs-comment">     * 链接：https://leetcode-cn.com/problems/regular-expression-matching/solution/dong-tai-gui-hua-zen-yao-cong-0kai-shi-si-kao-da-b/</span></span><br><span class="line"><span class="hljs-comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment">     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch1</span><span class="hljs-params">(String s, String p)</span> </span>&#123; <span class="hljs-comment">// 动态规划</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || p == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length() + <span class="hljs-number">1</span>][p.length() + <span class="hljs-number">1</span>];</span><br><span class="line">        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; p.length(); i++) &#123; <span class="hljs-comment">// here's the p's length, not s's</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (p.charAt(i) == <span class="hljs-string">'*'</span> &amp;&amp; dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>]) &#123;</span><br><span class="line">                dp[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// here's y axis should be i+1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (p.charAt(j) == <span class="hljs-string">'.'</span> || p.charAt(j) == s.charAt(i)) &#123;<span class="hljs-comment">//如果是任意元素 或者是对于元素匹配</span></span><br><span class="line">                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">if</span> (p.charAt(j) == <span class="hljs-string">'*'</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (p.charAt(j - <span class="hljs-number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j - <span class="hljs-number">1</span>) != <span class="hljs-string">'.'</span>) &#123;<span class="hljs-comment">//如果前一个元素不匹配 且不为任意元素</span></span><br><span class="line">                        dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];</span><br><span class="line">                    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                        dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = (dp[i + <span class="hljs-number">1</span>][j] || dp[i][j + <span class="hljs-number">1</span>] || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);</span><br><span class="line">                            <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">                            dp[i][j] = dp[i-1][j] // 多个字符匹配的情况</span></span><br><span class="line"><span class="hljs-comment">                            or dp[i][j] = dp[i][j-1] // 单个字符匹配的情况</span></span><br><span class="line"><span class="hljs-comment">                            or dp[i][j] = dp[i][j-2] // 没有匹配的情况</span></span><br><span class="line"><span class="hljs-comment">                             */</span></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 官方解法--</span></span><br><span class="line">    <span class="hljs-keyword">enum</span> Result &#123;</span><br><span class="line">        TRUE, FALSE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Result[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch2</span><span class="hljs-params">(String text, String pattern)</span> </span>&#123; <span class="hljs-comment">// 自顶向下 官方</span></span><br><span class="line">        memo = <span class="hljs-keyword">new</span> Result[text.length() + <span class="hljs-number">1</span>][pattern.length() + <span class="hljs-number">1</span>];</span><br><span class="line">        <span class="hljs-keyword">return</span> dp(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, text, pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (memo[i][j] != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> memo[i][j] == Result.TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">boolean</span> ans;</span><br><span class="line">        <span class="hljs-keyword">if</span> (j == pattern.length()) &#123;</span><br><span class="line">            ans = i == text.length();</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">boolean</span> first_match = (i &lt; text.length() &amp;&amp;</span><br><span class="line">                    (pattern.charAt(j) == text.charAt(i) ||</span><br><span class="line">                            pattern.charAt(j) == <span class="hljs-string">'.'</span>));</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j + <span class="hljs-number">1</span>) == <span class="hljs-string">'*'</span>) &#123;</span><br><span class="line">                ans = (dp(i, j + <span class="hljs-number">2</span>, text, pattern) ||</span><br><span class="line">                        first_match &amp;&amp; dp(i + <span class="hljs-number">1</span>, j, text, pattern));</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                ans = first_match &amp;&amp; dp(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, text, pattern);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i][j] = ans ? Result.TRUE : Result.FALSE;</span><br><span class="line">        <span class="hljs-keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch3</span><span class="hljs-params">(String text, String pattern)</span> </span>&#123; <span class="hljs-comment">//动态规划，自底向上</span></span><br><span class="line">        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[text.length() + <span class="hljs-number">1</span>][pattern.length() + <span class="hljs-number">1</span>];</span><br><span class="line">        dp[text.length()][pattern.length()] = <span class="hljs-keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = text.length(); i &gt;= <span class="hljs-number">0</span>; i--) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = pattern.length() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;</span><br><span class="line">                <span class="hljs-keyword">boolean</span> first_match = (i &lt; text.length() &amp;&amp;</span><br><span class="line">                        (pattern.charAt(j) == text.charAt(i) ||</span><br><span class="line">                                pattern.charAt(j) == <span class="hljs-string">'.'</span>));</span><br><span class="line">                <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j + <span class="hljs-number">1</span>) == <span class="hljs-string">'*'</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j + <span class="hljs-number">2</span>] || first_match &amp;&amp; dp[i + <span class="hljs-number">1</span>][j];</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = first_match &amp;&amp; dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 官方解法---</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// "abc","a*."</span></span><br><span class="line">        <span class="hljs-comment">// "abc","ab*."</span></span><br><span class="line">        System.out.println(isMatch(<span class="hljs-string">"abc"</span>,<span class="hljs-string">"ab*."</span>));</span><br><span class="line">        <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">         * log</span></span><br><span class="line"><span class="hljs-comment">         * t=abc,p=ab*.,firstM=true</span></span><br><span class="line"><span class="hljs-comment">         * if2</span></span><br><span class="line"><span class="hljs-comment">         * t=bc,p=b*.,firstM=true</span></span><br><span class="line"><span class="hljs-comment">         * if1</span></span><br><span class="line"><span class="hljs-comment">         * t=bc,p=.,firstM=true</span></span><br><span class="line"><span class="hljs-comment">         * if2</span></span><br><span class="line"><span class="hljs-comment">         * t=c,p=b*.,firstM=false</span></span><br><span class="line"><span class="hljs-comment">         * if1</span></span><br><span class="line"><span class="hljs-comment">         * t=c,p=.,firstM=true</span></span><br><span class="line"><span class="hljs-comment">         * if2</span></span><br><span class="line"><span class="hljs-comment">         * true</span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">        <span class="hljs-keyword">int</span> cons[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;</span><br><span class="line">        System.out.println(getLeastCoinAmount(<span class="hljs-number">3</span>,cons));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 常见DP小问题 参考自 https://www.cnblogs.com/fefjay/p/7541760.html</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 动态规划算法是一种比较灵活的算法，针对具体的问题要具体分析，其宗旨就是要找出要解决问题的状态，</span></span><br><span class="line"><span class="hljs-comment">     * 然后逆向转化为求解子问题，最终回到已知的初始态，然后再顺序累计各个子问题的解从而得到最终问题的解。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 关键点就是找到状态转移方程和初始边界条件，说白了就是要找到“递推公式”和初始值，然后计算时保存每一步中间结果，最后累加判断得到结果。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 0.求数组最值</span></span><br><span class="line"><span class="hljs-comment">     * 求数组最值方法很多，这里使用动态规划的思想来尝试处理，以便更好地理解DP的思想。为了方便这里假设数组a[i]大小为n，要找n个数当中的最大值。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 设dp[i]表示第0...i个数的最大值，dp[i-1]表示第0...i-1个数的最大值，所以求前i个数的最大值时，</span></span><br><span class="line"><span class="hljs-comment">     * 已经知道前i-1个是的最大值是dp[i-1]，那么只需要比较dp[i-1]和第i个数谁大就知道了，即dp[i] = max(dp[-1], a[i])。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = a.length;</span><br><span class="line">        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];</span><br><span class="line">        dp[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>];</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            dp[i] = (dp[i-<span class="hljs-number">1</span>] &gt; a[i]) ? dp[i-<span class="hljs-number">1</span>] : a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> dp[len-<span class="hljs-number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 1.求最大公共子序列长度</span></span><br><span class="line"><span class="hljs-comment">     * 给定一个字符串，想要删掉某些字符使得最后剩下的字符构成一个回文串（左右对称的字符串，如abcba），</span></span><br><span class="line"><span class="hljs-comment">     * 问最少删掉多少个字符可获得一个最长回文串。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 本题求回文串最大长度就转化为求两个字符串的最长公共子序列（不一定连续）</span></span><br><span class="line"><span class="hljs-comment">     * 策略：字符串可以看做是字符序列，即字符数组。</span></span><br><span class="line"><span class="hljs-comment">     *      比如有序列A=a0,a1,a2...an；有序列B=b0,b1,b2,b3...bm；设A序列和B序列的公共子序列为C=c0,c1,c2,c3...ck。</span></span><br><span class="line"><span class="hljs-comment">     *      设L[][]为公共子序列C的长度，L[i][j]的i、j分别表示A、B序列的字符下标，L[i][j]含义是A序列a0、a1、a2...ai和B序列b0、b1、b2、</span></span><br><span class="line"><span class="hljs-comment">     *      ...bj的公共子序列的长度。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     *      1）如果A序列的i字符和B序列的j字符相等，那么就有ck=ai=bj，公共子序列C的长度L[i][j]=L[i-1][j-1]+1。</span></span><br><span class="line"><span class="hljs-comment">     *      2）如果A序列的i字符和B序列的j字符不相等，若ai != ck则C为a0...ai-1和b0...bj的最长子序列，若bj != ck则C为a0...ai和b0...bj-1的最长子序列，</span></span><br><span class="line"><span class="hljs-comment">     *         所以此时公共子序列长度为L[i][j] = max(L[i][j-1], L[i-1][j])。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lcs</span><span class="hljs-params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>  ) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String rs = <span class="hljs-keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">        <span class="hljs-keyword">char</span>[] chars1 = s.toCharArray();</span><br><span class="line">        <span class="hljs-keyword">char</span>[] chars2 = rs.toCharArray();<span class="hljs-comment">//获得反序的字符串</span></span><br><span class="line">        <span class="hljs-keyword">int</span> n = chars1.length;</span><br><span class="line">        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(chars1[i] == chars2[j])&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;</span><br><span class="line">                &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="hljs-number">1</span>] &gt; dp[i-<span class="hljs-number">1</span>][j] ? dp[i][j-<span class="hljs-number">1</span>] : dp[i-<span class="hljs-number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> n - dp[n][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 2.硬币凑钱问题</span></span><br><span class="line"><span class="hljs-comment">     * 只有面值为1元、3元、5元的硬币，数量足够。现在要凑够n元，求需要的最少硬币枚数。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n 目标总钱数</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> coins 硬币数组【1，3，5】</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回凑够n元需要的最少硬币数</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLeastCoinAmount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[] coins)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (coins == <span class="hljs-keyword">null</span> || n &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>]; <span class="hljs-comment">//dp[i]=j表示凑够i元最少需要j枚硬币。数组长度设为（n+1）保证可以访问dp[n]。</span></span><br><span class="line">        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> coinValue = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">//问题规模从小到大，直到达到目标面值</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; coins.length; j++) &#123;<span class="hljs-comment">//遍历所有面值的硬币，j表示硬币面值的下标</span></span><br><span class="line">                coinValue = coins[j];</span><br><span class="line">                <span class="hljs-keyword">if</span> (i - coinValue &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">1</span> + dp[i-coinValue] &lt; dp[i])&#123; <span class="hljs-comment">//当前方案的硬币数更少，则使用当前方案</span></span><br><span class="line">                    dp[i] = <span class="hljs-number">1</span> + dp[i-coins[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 3.最长非降子序列</span></span><br><span class="line"><span class="hljs-comment">     * 一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 定义d(i)表示前i个数中"以A[i]结尾"的最长非降子序列的长度。</span></span><br><span class="line"><span class="hljs-comment">     * 对序列A1...Ai,找到的最长子序列长度d[i]分两种情况：</span></span><br><span class="line"><span class="hljs-comment">     * （1）包含最后一个数Ai,即d[i]=max&#123;d[j]+1&#125;(1&lt;=j&lt;i且Aj&lt;=Ai)，满足条件的Aj可能会有多个，选最大的d[j]，如果Aj都大于Ai则d[j]=0；</span></span><br><span class="line"><span class="hljs-comment">     * （2）不含最后一个数,即d[i]=d[i-1]</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 综上：d[i] = max&#123;d[i-1], max&#123;d[j]+1&#125;&#125;</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestIncreasingSubsequence</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (a.length &lt; <span class="hljs-number">1</span>)&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = a.length;</span><br><span class="line">        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<span class="hljs-comment">//dp[i]系统自动初始化为0</span></span><br><span class="line">        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<span class="hljs-comment">//迭代，求序列0...len-1的最长子序列长度</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<span class="hljs-comment">//寻找Ai之前的序列，看是否有不大于Ai的数字Aj</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (a[j] &lt;= a[i] &amp;&amp; dp[i] &lt; dp[j] + <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//假设最长子序列包含最后一个数</span></span><br><span class="line">                    dp[i] = dp[j] + <span class="hljs-number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">//寻找Ai之前的序列如果Ai都小于Aj，此时dp[i]并没有被修改仍为初始值0。所以包含最后一个数的最长子序列就只有最后一个数自身，长1</span></span><br><span class="line">            dp[i] = Math.max(<span class="hljs-number">1</span>, dp[i]);</span><br><span class="line">            <span class="hljs-comment">//至此，已经求出了包含最后一个数的最长子序列的长度，和不包含最后一个数的最长子序列长度比较，取最大值为当前的最大长度</span></span><br><span class="line">            dp[i] = Math.max(dp[i], dp[i-<span class="hljs-number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> dp[len-<span class="hljs-number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 4.经典01背包问题</span></span><br><span class="line"><span class="hljs-comment">     * 01背包问题：一个承重（或体积）为W的背包，可选物品有n个，第i个物品分别重w[i]和价值v[i]，</span></span><br><span class="line"><span class="hljs-comment">     * 每个物品只能拿或不拿，求背包可放物品的最大价值。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 策略：这里的关键制约因素是背包只能承重w，而且每放入一个物品其承重就会减少。</span></span><br><span class="line"><span class="hljs-comment">     *      因此定义maxValue=V[i][j]，数组表示目前可选物品有i个：0、1...i-1，背包承重（剩余的存放重量）为j的最大价值。</span></span><br><span class="line"><span class="hljs-comment">     *      现在假设已经知道了(i-1)个物品且剩余承重为j的最大价值V[i-1][j]，那么考虑准备放入第i个物品的情况：</span></span><br><span class="line"><span class="hljs-comment">     *     （1）如果第i个物品的重量大于背包的剩余承重w_i&gt;j，显然放不下了，所以此时V[i][j]=V[i-1][j];</span></span><br><span class="line"><span class="hljs-comment">     *      (2)w_i&lt;=j，显然可以放下第i个物品，物品可以放得下，但是一定要装进来吗？如果装进的物品价值较低且较重，无疑会影响后续物品的装入情况。</span></span><br><span class="line"><span class="hljs-comment">     *        所以还要考虑要不要放进来的子问题，V[i][j]=max&#123;vi+V[i-1][j-wi], V[i-1][j]&#125;。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> W</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> w</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> v</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> W, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span>[] v)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> ( W &lt; <span class="hljs-number">1</span> || n &lt; <span class="hljs-number">1</span> || w == <span class="hljs-keyword">null</span> || v == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>][W+<span class="hljs-number">1</span>]; <span class="hljs-comment">//可选的物品最多可以有n个，所以行数设为n+1。最大承重是W，所以列设为W+1。</span></span><br><span class="line">        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">//物品数肯定是从1开始。dp[0][j]系统初始化为0.</span></span><br><span class="line">            index = i-<span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= W ; j++) &#123;<span class="hljs-comment">//能装进的重量肯定是从1开始。dp[i][0]系统初始化为0.</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (w[index] &gt; j)&#123;</span><br><span class="line">                    dp[i][j] =  dp[i-<span class="hljs-number">1</span>][j];</span><br><span class="line">                &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] =  Math.max(dp[i - <span class="hljs-number">1</span>][j - w[index]] + v[index], dp[i - <span class="hljs-number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//找出是哪些物品放入背包</span></span><br><span class="line">        <span class="hljs-keyword">boolean</span>[] isTaken = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<span class="hljs-comment">//标记是否放入背包里</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt; <span class="hljs-number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (dp[i][W] != dp[i-<span class="hljs-number">1</span>][W])&#123;</span><br><span class="line">                isTaken[i-<span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//装入</span></span><br><span class="line">                W -= w[i-<span class="hljs-number">1</span>];<span class="hljs-comment">//装入之后背包的承重减少</span></span><br><span class="line">                System.out.println(i-<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> dp[n][W];<span class="hljs-comment">//返回n个物品承重为W时的最大价值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;9-Palindrome-Number&quot;&gt;&lt;a href=&quot;#9-Palindrome-Number&quot; class=&quot;headerlink&quot; title=&quot;9. Palindrome Number&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/palindrome-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;9. Palindrome Number&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://removeif.github.io/categories/algorithm/"/>
    
    
      <category term="动态规划" scheme="https://removeif.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="dp" scheme="https://removeif.github.io/tags/dp/"/>
    
      <category term="中心扩展" scheme="https://removeif.github.io/tags/%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>算法成长之路leetcode7-8</title>
    <link href="https://removeif.github.io/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode7-8.html"/>
    <id>https://removeif.github.io/algorithm/算法成长之路leetcode7-8.html</id>
    <published>2019-12-10T15:36:42.000Z</published>
    <updated>2019-12-11T01:49:16.996Z</updated>
    
    <content type="html"><![CDATA[<h3 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7. Reverse Integer</a></h3><p>Given a 32-bit signed integer, reverse digits of an integer.<br><a id="more"></a></p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure><p>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><h4 id="JAVA题解"><a href="#JAVA题解" class="headerlink" title="JAVA题解"></a>JAVA题解</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leetcode7</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * 示例 1:</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * 输入: 123</span></span><br><span class="line"><span class="hljs-comment">     * 输出: 321</span></span><br><span class="line"><span class="hljs-comment">     *  示例 2:</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * 输入: -123</span></span><br><span class="line"><span class="hljs-comment">     * 输出: -321</span></span><br><span class="line"><span class="hljs-comment">     * 示例 3:</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * 输入: 120</span></span><br><span class="line"><span class="hljs-comment">     * 输出: 21</span></span><br><span class="line"><span class="hljs-comment">     * 注意:</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment">     * 链接：https://leetcode-cn.com/problems/reverse-integer</span></span><br><span class="line"><span class="hljs-comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (x &gt; Integer.MAX_VALUE || x &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">boolean</span> isNe = x &lt; <span class="hljs-number">0</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;</span><br><span class="line">        x = Math.abs(x);</span><br><span class="line">        <span class="hljs-comment">// 取绝对值时越界了，直接返回0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (isNe &amp;&amp; x &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="hljs-keyword">long</span> m = <span class="hljs-number">10</span>;</span><br><span class="line">        <span class="hljs-keyword">long</span> base = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;</span><br><span class="line">            base = m * base;</span><br><span class="line">            <span class="hljs-keyword">long</span> re = x % base;</span><br><span class="line">            <span class="hljs-keyword">if</span> (base == <span class="hljs-number">10</span>) &#123;</span><br><span class="line">                sb.append(re);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                sb.append((re * m) / base);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (x &lt; base) &#123;</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Long res;</span><br><span class="line">        <span class="hljs-keyword">if</span> (isNe) &#123;</span><br><span class="line">            res = <span class="hljs-number">0</span> - Long.parseLong(sb.toString());</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            res = Long.parseLong(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> res.intValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> rev = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> pop = x % <span class="hljs-number">10</span>;</span><br><span class="line">            x /= <span class="hljs-number">10</span>;</span><br><span class="line">            <span class="hljs-comment">// Integer.MAX_VALUE = 2147483647,因为后面 rev = rev * 10 + pop，所以rev &gt;Integer.MAX_VALUE 溢出</span></span><br><span class="line">            <span class="hljs-comment">// rev == Integer.MAX_VALUE / 10 时，Integer.MAX_VALUE / 10 = 2147483640,so,pop &gt; 7时溢出</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (rev &gt; Integer.MAX_VALUE / <span class="hljs-number">10</span> || (rev == Integer.MAX_VALUE / <span class="hljs-number">10</span> &amp;&amp; pop &gt; <span class="hljs-number">7</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-comment">// Integer.MIN_VALUE = -2147483648</span></span><br><span class="line">            <span class="hljs-comment">// 同理如上</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (rev &lt; Integer.MIN_VALUE / <span class="hljs-number">10</span> || (rev == Integer.MIN_VALUE / <span class="hljs-number">10</span> &amp;&amp; pop &lt; -<span class="hljs-number">8</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">            rev = rev * <span class="hljs-number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Integer.MAX_VALUE);</span><br><span class="line"><span class="hljs-comment">//        System.out.println(reverse1(123));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. String to Integer (atoi)</a></h3><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p>Note:</p><p>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical </span><br><span class="line">             digit or a +/- sign. Therefore no valid conversion could be performed.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−2^31) is returned.</span><br></pre></td></tr></table></figure><h4 id="JAVA题解-1"><a href="#JAVA题解-1" class="headerlink" title="JAVA题解"></a>JAVA题解</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leetcode8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     *请你来实现一个 atoi 函数，使其能将字符串转换成整数。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 在任何情况下，若函数不能进行有效的转换时，请返回 0。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 说明：</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 示例 1:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: "42"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: 42</span></span><br><span class="line"><span class="hljs-comment">     * 示例 2:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: "   -42"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: -42</span></span><br><span class="line"><span class="hljs-comment">     * 解释: 第一个非空白字符为 '-', 它是一个负号。</span></span><br><span class="line"><span class="hljs-comment">     *      我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span></span><br><span class="line"><span class="hljs-comment">     * 示例 3:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: "4193 with words"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: 4193</span></span><br><span class="line"><span class="hljs-comment">     * 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。</span></span><br><span class="line"><span class="hljs-comment">     * 示例 4:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: "words and 987"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: 0</span></span><br><span class="line"><span class="hljs-comment">     * 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。</span></span><br><span class="line"><span class="hljs-comment">     *      因此无法执行有效的转换。</span></span><br><span class="line"><span class="hljs-comment">     * 示例 5:</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: "-91283472332"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: -2147483648</span></span><br><span class="line"><span class="hljs-comment">     * 解释: 数字 "-91283472332" 超过 32 位有符号整数范围。</span></span><br><span class="line"><span class="hljs-comment">     *      因此返回 INT_MIN (−2^31) 。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment">     * 链接：https://leetcode-cn.com/problems/string-to-integer-atoi</span></span><br><span class="line"><span class="hljs-comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(String str)</span> </span>&#123;</span><br><span class="line">        StringBuilder st = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">char</span> c = str.charAt(i);</span><br><span class="line">            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (st.length() &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                st.append(c);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'+'</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (st.length() &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                st.append(c);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">' '</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (st.length() &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-number">48</span> &amp;&amp; c &lt;= <span class="hljs-number">57</span>) &#123;</span><br><span class="line">                st.append(c);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (st.length() &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (Long.parseLong(st.toString()) &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">if</span> (Long.parseLong(st.toString()) &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (st.length() == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (st.toString().equals(<span class="hljs-string">"-"</span>) || st.toString().equals(<span class="hljs-string">"+"</span>)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> Long.valueOf(st.toString()).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi1</span><span class="hljs-params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (str.isEmpty())</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">char</span>[] mychar = str.toCharArray();</span><br><span class="line">        <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>, flag = <span class="hljs-number">1</span>, n = str.length();</span><br><span class="line">        <span class="hljs-comment">//排除字符串开头的空格元素</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (index &lt; n &amp;&amp; mychar[index] == <span class="hljs-string">' '</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//排除空格后判断首字符是+还是-还是都不是</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (index &lt; n &amp;&amp; mychar[index] == <span class="hljs-string">'+'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; n &amp;&amp; mychar[index] == <span class="hljs-string">'-'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            flag = -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//重点：只管是数字的时候，其余取0</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (index &lt; n &amp;&amp; (mychar[index] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; mychar[index] &lt;= <span class="hljs-string">'9'</span>)) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (ans != (<span class="hljs-keyword">int</span>) ans) &#123;<span class="hljs-comment">//超出int范围</span></span><br><span class="line">                <span class="hljs-keyword">return</span> (flag == <span class="hljs-number">1</span>) ? Integer.MAX_VALUE : Integer.MIN_VALUE;<span class="hljs-comment">//提前结束</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">// 巧妙的加起来值来 如 111 ，第一个1时 ans = 0 * 10 +1,第二个1时 ans = 1*10 + 1 = 11,第三个1时， ans = 11*10 + 1 = 111;</span></span><br><span class="line">            ans = ans * <span class="hljs-number">10</span> + mychar[index++] - <span class="hljs-string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="hljs-comment">// 强转long是否等于int 判断是否超界，机智</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (ans != (<span class="hljs-keyword">int</span>) ans) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> (flag == <span class="hljs-number">1</span>) ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (ans * flag);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">         * "42"</span></span><br><span class="line"><span class="hljs-comment">         * "----01"</span></span><br><span class="line"><span class="hljs-comment">         * "0-1"</span></span><br><span class="line"><span class="hljs-comment">         * "-5-"</span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">        System.out.println(myAtoi(<span class="hljs-string">"0-1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;7-Reverse-Integer&quot;&gt;&lt;a href=&quot;#7-Reverse-Integer&quot; class=&quot;headerlink&quot; title=&quot;7. Reverse Integer&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;7. Reverse Integer&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Given a 32-bit signed integer, reverse digits of an integer.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://removeif.github.io/categories/algorithm/"/>
    
    
      <category term="反转整数" scheme="https://removeif.github.io/tags/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    
      <category term="字符串转整数" scheme="https://removeif.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>mysql-b+Tree索引</title>
    <link href="https://removeif.github.io/database/mysql/mysql-b-Tree%E7%B4%A2%E5%BC%95.html"/>
    <id>https://removeif.github.io/database/mysql/mysql-b-Tree索引.html</id>
    <published>2019-12-10T10:36:42.000Z</published>
    <updated>2019-12-10T15:38:13.489Z</updated>
    
    <content type="html"><![CDATA[<p>索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。<br>索引最形象的比喻就是图书的目录了。注意这里的大量，数据量大了索引才显得有意义，如果我想要在 [1,2,3,4] 中找到 4 这个数据，直接对全数据检索也很快，没有必要费力气建索引再去查找。</p><p>索引在 MySQL 数据库中分三类：</p><ul><li>B+ 树索引</li><li>Hash 索引</li><li>全文索引<a id="more"></a></li></ul><p>我们今天要介绍的是工作开发中最常接触到的 InnoDB 存储引擎中的 B+ 树索引。要介绍 B+ 树索引，就不得不提二叉查找树，平衡二叉树和 B 树这三种数据结构。B+ 树就是从他们仨演化来的。</p><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>首先，让我们先看一张图：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180008.png" alt=""></p><p>从图中可以看到，我们为 user 表（用户信息表）建立了一个二叉查找树的索引。</p><p>图中的圆为二叉查找树的节点，节点中存储了键（key）和数据（data）。键对应 user 表中的 id，数据对应 user 表中的行数据。</p><p>二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。</p><p>如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下：</p><ul><li>将根节点作为当前节点，把 12 与当前节点的键值 10 比较，12 大于 10，接下来我们把当前节点&gt;的右子节点作为当前节点。</li><li>继续把 12 和当前节点的键值 13 比较，发现 12 小于 13，把当前节点的左子节点作为当前节点。</li><li>把 12 和当前节点的键值 12 对比，12 等于 12，满足条件，我们从当前节点中取出 data，即 id=12，name=xm。</li></ul><p>利用二叉查找树我们只需要 3 次即可找到匹配的数据。如果在表中一条条的查找的话，我们需要 6 次才能找到。</p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>上面我们讲解了利用二叉查找树可以快速的找到数据。但是，如果上面的二叉查找树是这样的构造：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180050.png" alt=""></p><p>这个时候可以看到我们的二叉查找树变成了一个链表。如果我们需要查找 id=17 的用户信息，我们需要查找 7 次，也就相当于全表扫描了。 </p><p>导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。</p><p>为了解决这个问题，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树了。 </p><p>平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1。 </p><p>下面是平衡二叉树和非平衡二叉树的对比：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180118.png" alt=""></p><p>由平衡二叉树的构造我们可以发现第一张图中的二叉树其实就是一棵平衡二叉树。</p><p>平衡二叉树保证了树的构造是平衡的，当我们插入或删除数据导致不满足平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡。具体的调整方式这里就不介绍了。</p><p>平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h2><p>因为内存的易失性。一般情况下，我们都会选择将 user 表中的数据和索引存储在磁盘这种外围设备中。</p><p>但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取数据的次数。</p><p>另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。</p><p>如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。</p><p>如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块。</p><p>我们都知道平衡二叉树可是每个节点只存储一个键值和数据的。那说明什么？说明每个磁盘块仅仅存储一个键值和数据！那如果我们要存储海量的数据呢？</p><p>可以想象到二叉树的节点将会非常多，高度也会极其高，我们查找数据时也会进行很多次磁盘 IO，我们查找数据的效率将会极低！</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180204.png" alt=""></p><p>为了解决平衡二叉树的这个弊端，我们应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的 B 树。</p><p>B 树（Balance Tree）即为平衡树的意思，下图即是一棵 B 树：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180223.png" alt=""></p><p>图中的 p 节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有，因为图的美观性，被省略了。</p><p>图中的每个节点称为页，页就是我们上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合 MySQL 中索引的底层数据结构。</p><p>从上图可以看出，B 树相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的 B 树为 3 阶 B 树，高度也会很低。</p><p>基于这个特性，B 树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。</p><p>假如我们要查找 id=28 的用户信息，那么我们在上图 B 树中查找的流程如下：</p><ul><li>先找到根节点也就是页 1，判断 28 在键值 17 和 35 之间，那么我们根据页 1 中的指针 p2 找到页 3。</li><li>将 28 和页 3 中的键值相比较，28 在 26 和 30 之间，我们根据页 3 中的指针 p2 找到页 8。</li><li>将 28 和页 8 中的键值相比较，发现有匹配的键值 28，键值 28 对应的用户信息为（28，bv）。</li></ul><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h2><p>B+ 树是对 B 树的进一步优化。让我们先来看下 B+ 树的结构图：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180242.png" alt=""></p><p>根据上图我们来看下 B+ 树和 B 树有什么不同：</p><p>①B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。</p><p>之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。</p><p>如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。</p><p>另外，B+ 树的阶数是等于键值的数量的，如果我们的 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。</p><p>一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。</p><p>②因为 B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。</p><p>那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。</p><p>有心的读者可能还发现上图 B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。</p><p>其实上面的 B 树我们也可以对各个节点加上链表。这些不是它们之前的区别，是因为在 MySQL 的 InnoDB 存储引擎中，索引就是这样存储的。</p><p>也就是说上图中的 B+ 树索引就是 InnoDB 中 B+ 树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。</p><p>通过上图可以看到，在 InnoDB 中，我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。</p><p>MyISAM 中的 B+ 树索引实现与 InnoDB 中的略有不同。在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。</p><h2 id="聚集索引-VS-非聚集索引"><a href="#聚集索引-VS-非聚集索引" class="headerlink" title="聚集索引 VS 非聚集索引"></a>聚集索引 VS 非聚集索引</h2><p>在上节介绍 B+ 树索引的时候，我们提到了图中的索引其实是聚集索引的实现方式。</p><p>那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。</p><p>这里我们着重介绍 InnoDB 中的聚集索引和非聚集索引：</p><p><strong>①聚集索引（聚簇索引）：</strong>以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。</p><p>这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。</p><p>这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。</p><p><strong>②非聚集索引（非聚簇索引）：</strong>以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。</p><p>非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。</p><p>明白了聚集索引和非聚集索引的定义，我们应该明白这样一句话：数据即索引，索引即数据。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Innodb的存储索引是基于B+tree，理所当然，聚集索引也是基于B+tree。与非聚集索引的区别则是，聚集索引既存储了索引，也存储了行值。当一个表有一个聚集索引，它的数据是存储在索引的叶子页（leaf pages）。因此innodb也能理解为基于索引的表。</span><br><span class="line"></span><br><span class="line">Innodb如何选择一个聚集索引，对于Innodb，主键毫无疑问是一个聚集索引。但是当一个表没有主键，或者没有一个索引，Innodb会如何处理呢。请看如下规则</span><br><span class="line"></span><br><span class="line">1. 如果一个主键被定义了，那么这个主键就是作为聚集索引</span><br><span class="line"></span><br><span class="line">2. 如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引</span><br><span class="line"></span><br><span class="line">3. 如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。</span><br><span class="line"></span><br><span class="line">还有一个需要注意的是：次级索引的叶子节点并不存储行数据的物理地址。而是存储的该行的主键值。</span><br><span class="line"></span><br><span class="line">所以：一次级索引包含了两次查找。一次是查找次级索引自身。然后查找主键（聚集索引）现在应该明白了吧，建立自增主键的原因是：</span><br><span class="line"></span><br><span class="line">Innodb中的每张表都会有一个聚集索引，而聚集索引又是以物理磁盘顺序来存储的，自增主键会把数据自动向后插入，避免了插入过程中的聚集索引排序问题。聚集索引的排序，必然会带来大范围的数据的物理移动，这里面带来的磁盘IO性能损耗是非常大的。 </span><br><span class="line">而如果聚集索引上的值可以改动的话，那么也会触发物理磁盘上的移动，于是就可能出现page分裂，表碎片横生。</span><br></pre></td></tr></table></figure><h2 id="利用聚集索引和非聚集索引查找数据"><a href="#利用聚集索引和非聚集索引查找数据" class="headerlink" title="利用聚集索引和非聚集索引查找数据"></a>利用聚集索引和非聚集索引查找数据</h2><p>前面我们讲解 B+ 树索引的时候并没有去说怎么在 B+ 树中进行数据的查找，主要就是因为还没有引出聚集索引和非聚集索引的概念。</p><p>下面我们通过讲解如何通过聚集索引以及非聚集索引查找数据表中数据的方式介绍一下 B+ 树索引查找数据方法。</p><h3 id="利用聚集索引查找数据"><a href="#利用聚集索引查找数据" class="headerlink" title="利用聚集索引查找数据"></a>利用聚集索引查找数据</h3><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180304.png" alt=""></p><p>还是这张 B+ 树索引图，现在我们应该知道这就是聚集索引，表中的数据存储在其中。</p><p>现在假设我们要查找 id&gt;=18 并且 id&lt;40 的用户数据。对应的 sql 语句为：</p><p><strong>MySQL</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id&gt;=18 and id &lt;40</span><br></pre></td></tr></table></figure><p>其中 id 为主键，具体的查找过程如下：</p><p><strong>①</strong>一般根节点都是常驻内存的，也就是说页 1 已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。</p><p>从内存中读取到页 1，要查找这个 id&gt;=18 and id &lt;40 或者范围值，我们首先需要找到 id=18 的键值。</p><p>从页 1 中我们可以找到键值 18，此时我们需要根据指针 p2，定位到页 3。</p><p><strong>②</strong>要从页 3 中查找数据，我们就需要拿着 p2 指针去磁盘中进行读取页 3。</p><p>从磁盘中读取页 3 后将页 3 放入内存中，然后进行查找，我们可以找到键值 18，然后再拿到页 3 中的指针 p1，定位到页 8。</p><p><strong>③</strong>同样的页 8 页不在内存中，我们需要再去磁盘中将页 8 读取到内存中。</p><p>将页 8 读取到内存中后。因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值 18。</p><p>此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值 18 对应的数据。</p><p>因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页 8 中的键值依次进行遍历查找并匹配满足条件的数据。</p><p>我们可以一直找到键值为 22 的数据，然后页 8 中就没有数据了，此时我们需要拿着页 8 中的 p 指针去读取页 9 中的数据。</p><p><strong>④</strong>因为页 9 不在内存中，就又会加载页 9 到内存中，并通过和页 8 中一样的方式进行数据的查找，直到将页 12 加载到内存中，发现 41 大于 40，此时不满足条件。那么查找到此终止。</p><p>最终我们找到满足条件的所有数据，总共 12 条记录：</p><p><code>(18,kl), (19,kl), (22,hj), (24,io), (25,vg) , (29,jk), (31,jk) , (33,rt) , (34,ty) , (35,yu) , (37,rt) , (39,rt) 。</code></p><p>下面看下具体的查找流程图</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180400.png" alt=""></p><h3 id="利用非聚集索引查找数据"><a href="#利用非聚集索引查找数据" class="headerlink" title="利用非聚集索引查找数据"></a>利用非聚集索引查找数据</h3><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180416.png" alt=""></p><p>读者看到这张图的时候可能会蒙，这是啥东西啊？怎么都是数字。如果有这种感觉，请仔细看下图中红字的解释。</p><p>什么？还看不懂？那我再来解释下吧。首先，这个非聚集索引表示的是用户幸运数字的索引（为什么是幸运数字？一时兴起想起来的:-)），此时表结构是这样的。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180434.png" alt=""></p><p>在叶子节点中，不再存储所有的数据了，存储的是键值和主键。对于叶子节点中的 x-y，比如 1-1。左边的 1 表示的是索引的键值，右边的 1 表示的是主键值。</p><p>如果我们要找到幸运数字为 33 的用户信息，对应的 sql 语句为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where luckNum=33</span><br></pre></td></tr></table></figure><p>查找的流程跟聚集索引一样，这里就不详细介绍了。我们最终会找到主键值 47，找到主键后我们需要再到聚集索引中查找具体对应的数据信息，此时又回到了聚集索引的查找流程。</p><p>下面看下具体的查找流程图：</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191210180507.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章从二叉查找树，详细说明了为什么 MySQL 用 B+ 树作为数据的索引，以及在 InnoDB 中数据库如何通过 B+ 树索引来存储数据以及查找数据。</p><p>我们一定要记住这句话：数据即索引，索引即数据。</p><p>参考文章:<br><a href="http://www.liuzk.com/410.html" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。&lt;br&gt;索引最形象的比喻就是图书的目录了。注意这里的大量，数据量大了索引才显得有意义，如果我想要在 [1,2,3,4] 中找到 4 这个数据，直接对全数据检索也很快，没有必要费力气建索引再去查找。&lt;/p&gt;
&lt;p&gt;索引在 MySQL 数据库中分三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B+ 树索引&lt;/li&gt;
&lt;li&gt;Hash 索引&lt;/li&gt;
&lt;li&gt;全文索引&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://removeif.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="b+tree" scheme="https://removeif.github.io/tags/b-tree/"/>
    
      <category term="聚簇索引" scheme="https://removeif.github.io/tags/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>算法成长之路leetcode5-6</title>
    <link href="https://removeif.github.io/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode5-6.html"/>
    <id>https://removeif.github.io/algorithm/算法成长之路leetcode5-6.html</id>
    <published>2019-12-05T13:14:49.026Z</published>
    <updated>2019-12-05T13:14:49.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. Longest Palindromic Substring</a></h3><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br><a id="more"></a></p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h4 id="JAVA题解"><a href="#JAVA题解" class="headerlink" title="JAVA题解"></a>JAVA题解</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leetcode5</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(longestPalindrome(<span class="hljs-string">"abbaabb"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 示例 1：</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: "babad"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: "bab"</span></span><br><span class="line"><span class="hljs-comment">     * 注意: "aba" 也是一个有效答案。</span></span><br><span class="line"><span class="hljs-comment">     * 示例 2：</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 输入: "cbbd"</span></span><br><span class="line"><span class="hljs-comment">     * 输出: "bb"</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment">     * 链接：https://leetcode-cn.com/problems/longest-palindromic-substring</span></span><br><span class="line"><span class="hljs-comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 终于看懂了这个中心向两边扩张算法是什么意思了。</span></span><br><span class="line"><span class="hljs-comment">     * 先来解释一下为什么中心是2n-1而不是n 比如有字符串abcba，这时回文子串是abcda，</span></span><br><span class="line"><span class="hljs-comment">     * 中心是c；又有字符串adccda，这时回文子串是adccda，中心是cc。 由此可见中心点既有可能是一个字符，</span></span><br><span class="line"><span class="hljs-comment">     * 也有可能是两个字符，当中心为一个字符的时候有n个中心，</span></span><br><span class="line"><span class="hljs-comment">     * 当中心为两个字符的时候有n-1个中心，所以一共有2n-1个中心。</span></span><br><span class="line"><span class="hljs-comment">     * 然后for循环开始从左到右遍历，为什么会有两次expandAroundCenter，一次是i和i本身，一次是i和i+1，</span></span><br><span class="line"><span class="hljs-comment">     * 这就是上面说到的一个中心与两个中心。 而后会去判断这两种情况下谁的回文子串最长，并标记出这个子串在原字符串中的定位，即start和end。</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="hljs-comment">// 一个数向两边扩张</span></span><br><span class="line">            <span class="hljs-keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="hljs-comment">// 两个数向两边扩张</span></span><br><span class="line">            <span class="hljs-keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="hljs-number">1</span>);</span><br><span class="line">            <span class="hljs-comment">// 取最长的回文</span></span><br><span class="line">            <span class="hljs-keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="hljs-comment">// 判读此时长度和原来的最长度</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">                <span class="hljs-comment">// 求最长回文开始位置</span></span><br><span class="line">                start = i - (len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;</span><br><span class="line">                <span class="hljs-comment">// 求最长回文结束位置</span></span><br><span class="line">                end = i + len / <span class="hljs-number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 截取最长回文</span></span><br><span class="line">        <span class="hljs-keyword">return</span> s.substring(start, end + <span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 向两边向两边扩张求长度</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> left</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> right</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expandAroundCenter</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 定位中心位置</span></span><br><span class="line">        <span class="hljs-keyword">int</span> L = left, R = right;</span><br><span class="line">        <span class="hljs-comment">// 判读中间位置是否相等，以及两边扩张是否相等</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (L &gt;= <span class="hljs-number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">            <span class="hljs-comment">// 向左扩张一位</span></span><br><span class="line">            L--;</span><br><span class="line">            <span class="hljs-comment">// 向右扩张一位</span></span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 回文的长度 如 aba 时,当 b = 1时，一个中心点进来,L = 1,R = 1,此时满足循环，L=0,R=2,此时也满足</span></span><br><span class="line">        <span class="hljs-comment">// 循环，L = -1,R=3,此时循环结束，长度为3 = 3 -（-1） -1</span></span><br><span class="line">        <span class="hljs-keyword">return</span> R - L - <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6. ZigZag Conversion"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. ZigZag Conversion</a></h3><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><p>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><h4 id="JAVA题解-1"><a href="#JAVA题解-1" class="headerlink" title="JAVA题解"></a>JAVA题解</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leetcode6</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * 比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时，排列如下：</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * L   C   I   R</span></span><br><span class="line"><span class="hljs-comment">     * E T O E S I I G</span></span><br><span class="line"><span class="hljs-comment">     * E   D   H   N</span></span><br><span class="line"><span class="hljs-comment">     * 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："LCIRETOESIIGEDHN"。</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * 请你实现这个将字符串进行指定行数变换的函数：</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * string convert(string s, int numRows);</span></span><br><span class="line"><span class="hljs-comment">     * 示例 1:</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * 输入: s = "LEETCODEISHIRING", numRows = 3</span></span><br><span class="line"><span class="hljs-comment">     * 输出: "LCIRETOESIIGEDHN"</span></span><br><span class="line"><span class="hljs-comment">     * 示例 2:</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * 输入: s = "LEETCODEISHIRING", numRows = 4</span></span><br><span class="line"><span class="hljs-comment">     * 输出: "LDREOEIIECIHNTSG"</span></span><br><span class="line"><span class="hljs-comment">     * 解释:</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * L     D     R</span></span><br><span class="line"><span class="hljs-comment">     * E   O E   I I</span></span><br><span class="line"><span class="hljs-comment">     * E C   I H   N</span></span><br><span class="line"><span class="hljs-comment">     * T     S     G</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="hljs-comment">     * 链接：https://leetcode-cn.com/problems/zigzag-conversion</span></span><br><span class="line"><span class="hljs-comment">     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">convert</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (numRows == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        List&lt;StringBuilder&gt; rows = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Math.min(numRows, s.length()); i++)</span><br><span class="line">            <span class="hljs-comment">// 确定有多少行，每一行放一个待填充的字符串</span></span><br><span class="line">            rows.add(<span class="hljs-keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="hljs-comment">// 当前行</span></span><br><span class="line">        <span class="hljs-keyword">int</span> curRow = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-comment">// 上移或下移 false上移</span></span><br><span class="line">        <span class="hljs-keyword">boolean</span> goingDown = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="hljs-comment">// 挨着放字符到对应的行</span></span><br><span class="line">            rows.get(curRow).append(c);</span><br><span class="line">            <span class="hljs-comment">// 判断是否下移，当第一行和最后一行的时候转向</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (curRow == <span class="hljs-number">0</span> || curRow == numRows - <span class="hljs-number">1</span>) goingDown = !goingDown;</span><br><span class="line">            <span class="hljs-comment">// 下移行数+1，上移行数-1</span></span><br><span class="line">            curRow += goingDown ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 存最终结果</span></span><br><span class="line">        StringBuilder ret = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="hljs-comment">// 遍历每行，进行连接</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (StringBuilder row : rows) ret.append(row);</span><br><span class="line">        <span class="hljs-keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Leetcode6 l = <span class="hljs-keyword">new</span> Leetcode6();</span><br><span class="line">        System.out.println(l.convert(<span class="hljs-string">"weweqw"</span>, <span class="hljs-number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;5-Longest-Palindromic-Substring&quot;&gt;&lt;a href=&quot;#5-Longest-Palindromic-Substring&quot; class=&quot;headerlink&quot; title=&quot;5. Longest Palindromic Substring&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;5. Longest Palindromic Substring&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://removeif.github.io/categories/algorithm/"/>
    
    
      <category term="最长回文" scheme="https://removeif.github.io/tags/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87/"/>
    
      <category term="Z字变换" scheme="https://removeif.github.io/tags/Z%E5%AD%97%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>二分查找法模板的基本思想-leetcode35</title>
    <link href="https://removeif.github.io/algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-leetcode35.html"/>
    <id>https://removeif.github.io/algorithm/二分查找法模板的基本思想-leetcode35.html</id>
    <published>2019-12-03T10:38:01.100Z</published>
    <updated>2019-12-03T10:38:01.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode35"><a href="#leetcode35" class="headerlink" title="leetcode35"></a>leetcode35</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。<br><a id="more"></a></p><p><strong>示例 1:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>传统解法：</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="hljs-keyword">if</span> (nums[len - <span class="hljs-number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;</span><br><span class="line">            <span class="hljs-comment">// 等于的情况最简单，我们应该放在第 1 个分支进行判断</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="hljs-comment">// 题目要我们返回大于或者等于目标值的第 1 个数的索引</span></span><br><span class="line">                <span class="hljs-comment">// 此时 mid 一定不是所求的左边界，</span></span><br><span class="line">                <span class="hljs-comment">// 此时左边界更新为 mid + 1</span></span><br><span class="line">                left = mid + <span class="hljs-number">1</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// 既然不会等于，此时 nums[mid] &gt; target</span></span><br><span class="line">                <span class="hljs-comment">// mid 也一定不是所求的右边界</span></span><br><span class="line">                <span class="hljs-comment">// 此时右边界更新为 mid - 1</span></span><br><span class="line">                right = mid - <span class="hljs-number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 注意：一定得返回左边界 left，</span></span><br><span class="line">        <span class="hljs-comment">// 如果返回右边界 right 提交代码不会通过</span></span><br><span class="line">        <span class="hljs-comment">// 【注意】下面我尝试说明一下理由，如果你不太理解下面我说的，那是我表达的问题</span></span><br><span class="line">        <span class="hljs-comment">// 但我建议你不要纠结这个问题，因为我将要介绍的二分查找法模板，可以避免对返回 left 和 right 的讨论</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1</span></span><br><span class="line">        <span class="hljs-comment">// 在上面的 while (left &lt;= right) 退出循环以后，right &lt; left，right = 0 ，left = 1</span></span><br><span class="line">        <span class="hljs-comment">// 根据题意应该返回 left，</span></span><br><span class="line">        <span class="hljs-comment">// 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 right</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>a、当把二分查找法的循环可以进行的条件写成 while (left &lt;= right) 时，在写最后一句 return 的时候，如果不假思索，把左边界 left 返回回去，虽然写对了，但可以思考一下为什么不返回右边界 right 呢？</p><p>b、但是事实上，返回 left 是有一定道理的，如果题目换一种问法，你可能就要返回右边界 right，这句话不太理解没有关系，我也不打算讲得很清楚（在上面代码的注释中我已经解释了原因），因为实在太绕了，这不是我要说的重点。</p><h3 id="二分查找法模板的基本思想"><a href="#二分查找法模板的基本思想" class="headerlink" title="二分查找法模板的基本思想"></a>二分查找法模板的基本思想</h3><p><strong>1、首先把循环可以进行的条件写成 while(left &lt; right)，在退出循环的时候，一定有 left == right 成立，此时返回 left 或者 right 都可以</strong><br>或许你会问：退出循环的时候还有一个数没有看啊（退出循环之前索引 left 或 索引 right 上的值）？<br>没有关系，我们就等到退出循环以后来看，甚至经过分析，有时都不用看，就能确定它是目标数值。</p><p>（什么时候需要看最后剩下的那个数，什么时候不需要，会在后面介绍。）</p><p>更深层次的思想是“<strong>夹逼法</strong>”或者称为“<strong>排除法</strong>”。</p><p><strong>2、“神奇的”二分查找法模板的基本思想（特别重要）</strong><br>“排除法”即：在每一轮循环中排除一半以上的元素，于是在对数级别的时间复杂度内，就可以把区间“夹逼” 只剩下 1 个数，而这个数是不是我们要找的数，单独做一次判断就可以了。</p><p>“夹逼法”或者“排除法”是二分查找算法的基本思想，“二分”是手段，在目标元素不确定的情况下，“二分” 也是“最大熵原理”告诉我们的选择。</p><p>还是 LeetCode 第 35 题，下面给出使用 while (left &lt; right) 模板写法的 2 段参考代码，以下代码的细节部分在后文中会讲到，因此一些地方不太明白没有关系，暂时跳过即可。</p><p><strong>参考代码 1</strong>：重点理解为什么候选区间的索引范围是 [0, size]。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="hljs-comment"># 返回大于等于 target 的索引，有可能是最后一个</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="hljs-comment"># 特判</span></span><br><span class="line">        <span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line">        left = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># 如果 target 比 nums里所有的数都大，则最后一个数的索引 + 1 就是候选值，因此，右边界应该是数组的长度</span></span><br><span class="line">        right = size</span><br><span class="line">        <span class="hljs-comment"># 二分的逻辑一定要写对，否则会出现死循环或者数组下标越界</span></span><br><span class="line">        <span class="hljs-keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="hljs-number">2</span></span><br><span class="line">            <span class="hljs-keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">assert</span> nums[mid] &gt;= target</span><br><span class="line">                <span class="hljs-comment"># [1,5,7] 2</span></span><br><span class="line">                right = mid</span><br><span class="line">        <span class="hljs-comment"># 调试语句</span></span><br><span class="line">        <span class="hljs-comment"># print('left = &#123;&#125;, right = &#123;&#125;, mid = &#123;&#125;'.format(left, right, mid))</span></span><br><span class="line">        <span class="hljs-keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>参考代码 2</strong>：对于是否接在原有序数组后面单独判断，不满足的时候，再在候选区间的索引范围 <code>[0, size - 1]</code> 内使用二分查找法进行搜索。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="hljs-comment"># 返回大于等于 target 的索引，有可能是最后一个</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="hljs-comment"># 特判 1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># 特判 2：如果比最后一个数字还要大，直接接在它后面就可以了</span></span><br><span class="line">        <span class="hljs-keyword">if</span> target &gt; nums[<span class="hljs-number">-1</span>]:</span><br><span class="line">            <span class="hljs-keyword">return</span> size</span><br><span class="line"></span><br><span class="line">        left = <span class="hljs-number">0</span></span><br><span class="line">        right = size - <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment"># 二分的逻辑一定要写对，否则会出现死循环或者数组下标越界</span></span><br><span class="line">        <span class="hljs-keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="hljs-number">2</span></span><br><span class="line">            <span class="hljs-keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">assert</span> nums[mid] &gt;= target</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="hljs-keyword">return</span> left</span><br></pre></td></tr></table></figure><h3 id="细节、注意事项、调试方法"><a href="#细节、注意事项、调试方法" class="headerlink" title="细节、注意事项、调试方法"></a>细节、注意事项、调试方法</h3><p><strong>1、前提：思考左、右边界，如果左、右边界不包括目标数值，会导致错误结果</strong><br>例：LeetCode 第 69 题：x 的平方根</p><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>分析：一个非负整数的平方根最小可能是 0 ，最大可能是它自己。<br>因此左边界可以取 0 ，右边界可以取 x。<br>可以分析得再细一点，但这道题没有必要，因为二分查找法会帮你排除掉不符合的区间元素。</p><p>例：LeetCode 第 287 题：寻找重复数</p><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>分析：题目告诉我们“其数字都在 1 到 n 之间（包括 1 和 n）”。因此左边界可以取 1 ，右边界可以取 n。</p><p>要注意 2 点：</p><p>如果 left 和 right 表示的是数组的索引，就要考虑“索引是否有效” ，即“索引是否越界” 是重要的定界依据；</p><p>左右边界一定要包括目标元素，例如 LeetCode 第 35 题：“搜索插入位置” ，当 target 比数组中的最后一个数字还要大（不能等于）的时候，插入元素的位置就是数组的最后一个位置 + 1，即 (len - 1 + 1 =) len，如果忽略掉这一点，把右边界定为 len - 1 ，代码就不能通过在线测评。</p><p><strong>2、中位数先写 int mid = (left + right) &gt;&gt;&gt; 1 ; 根据循环里分支的编写情况，再做调整</strong><br>理解这一点，首先要知道：当数组的元素个数是偶数的时候，中位数有左中位数和右中位数之分。</p><p>当数组的元素个数是<strong>偶数</strong>的时候：<br>使用 <strong>int mid = left + (right - left) / 2</strong> ; 得到<strong>左中位数</strong>的索引；</p><p>使用 <strong>int mid = left + (right - left + 1) / 2</strong> ; 得到<strong>右中位数</strong>的索引。</p><p>当数组的元素个数是奇数的时候，以上二者都能选到最中间的那个中位数。<br>其次，</p><p><strong>int mid = left + (right - left) / 2 ; 等价于 int mid = (left + right) &gt;&gt;&gt; 1；</strong></p><p><strong>int mid = left + (right - left + 1) / 2 ; 等价于 int mid = (left + right + 1) &gt;&gt;&gt; 1 。</strong></p><p>我们使用一个具体的例子来验证：当左边界索引 left = 3，右边界索引 right = 4 的时候，</p><p><strong>mid1 = left + (right - left) // 2 = 3 + (4 - 3) // 2 = 3 + 0 = 3，</strong></p><p><strong>mid2 = left + (right - left + 1) // 2 = 3 + (4 - 3 + 1) // 2 = 3 + 1 = 4。</strong></p><p>左中位数 mid1 是索引 left，右中位数 mid2 是索引 right。</p><p><strong>记忆方法：</strong></p><p>(right - left) 不加 11 选左中位数，加 11 选右中位数。</p><p>那么，什么时候使用左中位数，什么时候使用右中位数呢？选中位数的依据是为了避免死循环，得根据分支的逻辑来选择中位数，而分支逻辑的编写也有技巧，下面具体说。</p><p><strong>3、先写逻辑上容易想到的分支逻辑，这个分支逻辑通常是排除中位数的逻辑；</strong><br>在逻辑上，“可能是也有可能不是”让我们感到犹豫不定，但<strong>“一定不是”是我们非常坚决的，通常考虑的因素特别单一，因此“好想” </strong>。在生活中，我们经常听到这样的话：找对象时，“有车、有房，可以考虑，但没有一定不要”；找工作时，“事儿少、离家近可以考虑，但是钱少一定不去”，就是这种思想的体现。</p><p>例：LeetCode 第 69 题：x 的平方根</p><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>分析：因为题目中说“返回类型是整数，结果只保留整数的部分，小数部分将被舍去”。例如 55 的平方根约等于 2.2362.236，在这道题应该返回 22。因此如果一个数的平方小于或者等于 x，那么这个数有可能是也有可能不是 x 的平方根，但是能很肯定的是，如果一个数的平方大于 x ，这个数肯定不是 x 的平方根。</p><p>注意：先写“好想”的分支，排除了中位数之后，通常另一个分支就不排除中位数，而不必具体考虑另一个分支的逻辑的具体意义，且代码几乎是固定的。</p><p><strong>4、循环内只写两个分支，一个分支排除中位数，另一个分支不排除中位数，循环中不单独对中位数作判断</strong><br>既然是“夹逼”法，没有必要在每一轮循环开始前单独判断当前中位数是否是目标元素，因此分支数少了一支，代码执行效率更高。</p><p>以下是“排除中位数的逻辑”思考清楚以后，可能出现的两个模板代码。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191203181303.png" alt=""></p><p>可以排除“中位数”的逻辑，通常比较好想，但并不绝对，这一点视情况而定。</p><p>分支条数变成 2 条，比原来 3 个分支要考虑的情况少，好处是：</p><p>不用在每次循环开始单独考虑中位数是否是目标元素，节约了时间，我们只要在退出循环的时候，即左右区间压缩成一个数（索引）的时候，去判断这个索引表示的数是否是目标元素，而不必在二分的逻辑中单独做判断。</p><p>这一点很重要，希望读者结合具体练习仔细体会，每次循环开始的时候都单独做一次判断，在统计意义上看，二分时候的中位数恰好是目标元素的概率并不高，并且即使要这么做，也不是普适性的，不能解决绝大部分的问题。</p><p>还以 LeetCode 第 35 题为例，通过之前的分析，我们需要找到“大于或者等于目标值的第 1 个数的索引”。对于这道题而言：</p><ul><li><p>如果中位数小于目标值，它就应该被排除，左边界 left 就至少是 mid + 1；</p></li><li><p>如果中位数大于等于目标值，还不能够肯定它就是我们要找的数，因为要找的是等于目标值的第 11 个数的索引，中位数以及中位数的左边都有可能是符合题意的数，因此右边界就不能把 mid 排除，因此右边界 right 至多是 mid，此时右边界不向左边收缩。</p></li></ul><p>下一点就更关键了。</p><p><strong>5、根据分支逻辑选择中位数的类型，可能是左中位数，也可能是右位数，选择的标准是避免死循环</strong></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191203181337.png" alt=""></p><p>死循环容易发生在区间只有 22 个元素时候，此时中位数的选择尤为关键。选择中位数的依据是：避免出现死循环。我们需要确保：</p><p>（下面的这两条规则说起来很绕，可以暂时跳过）。</p><ul><li><p>如果分支的逻辑，在选择左边界的时候，不能排除中位数，那么中位数就选“右中位数”，只有这样区间才会收缩，否则进入死循环；</p></li><li><p>同理，如果分支的逻辑，在选择右边界的时候，不能排除中位数，那么中位数就选“左中位数”，只有这样区间才会收缩，否则进入死循环。</p></li></ul><p>理解上面的这个规则可以通过具体的例子。针对以上规则的第 1 点：如果分支的逻辑，在选择左边界的时候不能排除中位数，例如：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">while</span> left &lt; right:</span><br><span class="line">      <span class="hljs-comment"># 不妨先写左中位数，看看你的分支会不会让你代码出现死循环，从而调整</span></span><br><span class="line">    mid = left + (right - left) // <span class="hljs-number">2</span></span><br><span class="line">    <span class="hljs-comment"># 业务逻辑代码</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (check(mid)):</span><br><span class="line">        <span class="hljs-comment"># 选择右边界的时候，可以排除中位数</span></span><br><span class="line">        right = mid - <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        <span class="hljs-comment"># 选择左边界的时候，不能排除中位数</span></span><br><span class="line">        left = mid</span><br></pre></td></tr></table></figure><p>在区间中的元素只剩下 22 个时候，例如：left = 3，right = 4。此时左中位数就是左边界，如果你的逻辑执行到 left = mid 这个分支，且你选择的中位数是左中位数，此时左边界就不会得到更新，区间就不会再收缩（理解这句话是关键），从而进入死循环；<br>为了避免出现死循环，你需要选择中位数是右中位数，当逻辑执行到 left = mid 这个分支的时候，因为你选择了右中位数，让逻辑可以转而执行到 right = mid - 1 让区间收缩，最终成为 1 个数，退出 while 循环。<br>上面这段话不理解没有关系，因为我还没有举例子，你有个印象就好，类似地，理解选择中位数的依据的第 2 点。</p><p><strong>6、退出循环的时候，可能需要对“夹逼”剩下的那个数单独做一次判断，这一步称之为“后处理”。</strong><br>二分查找法之所以高效，是因为它利用了数组有序的特点，在每一次的搜索过程中，都可以排除将近一半的数，使得搜索区间越来越小，直到区间成为一个数。回到这一节最开始的疑问：“区间左右边界相等（即收缩成 1 个数）时，这个数是否会漏掉”，解释如下：</p><ul><li><p>如果你的业务逻辑保证了你要找的数一定在左边界和右边界所表示的区间里出现，那么可以放心地返回 left 或者 right，无需再做判断；</p></li><li><p>如果你的业务逻辑不能保证你要找的数一定在左边界和右边界所表示的区间里出现，那么只要在退出循环以后，再针对 nums[left] 或者 nums[right] （此时 <code>nums[left] == nums[right]</code>）单独作一次判断，看它是不是你要找的数即可，这一步操作常常叫做“后处理”。</p></li></ul><p>如果你能确定候选区间里目标元素一定存在，则不必做“后处理”。<br>例：LeetCode 第 69 题：x 的平方根</p><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>分析：非负实数 x 的平方根在 [0, x] 内一定存在，故退出 while (left &lt; right) 循环以后，不必单独判断 left 或者 right 是否符合题意。</p><p>如果你不能确定候选区间里目标元素一定存在，需要单独做一次判断。<br>例：LeetCode 第 704 题：二分查找</p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>分析：因为目标数有可能不在数组中，当候选区间夹逼成一个数的时候，要单独判断一下这个数是不是目标数，如果不是，返回 -1。</p><p><strong>7、取中位数的时候，要避免在计算上出现整型溢出；</strong><br>int mid = (left + right) / 2; 的问题：在 left 和 right 很大的时候，left + right 会发生整型溢出，变成负数，这是一个 bug ，得改！</p><p>int mid = left + (right - left) / 2; 在 right 很大、 left 是负数且很小的时候， right - left 也有可能超过 int 类型能表示的最大值，只不过一般情况下 left 和 right 表示的是数组索引值，left 是非负数，因此 right - left 溢出的可能性很小。因此，它是正确的写法。下面介绍推荐的写法。</p><p>int mid = (left + right) &gt;&gt;&gt; 1; 如果这样写， left + right 在发生整型溢出以后，会变成负数，此时如果除以 22 ，mid 是一个负数，但是经过无符号右移，可以得到在不溢出的情况下正确的结果。</p><p>解释“无符号右移”：在 Java 中，无符号右移运算符 &gt;&gt;&gt; 和右移运算符 &gt;&gt; 的区别如下：</p><p>右移运算符 &gt;&gt; 在右移时，丢弃右边指定位数，左边补上符号位；<br>无符号右移运算符 &gt;&gt;&gt; 在右移时，丢弃右边指定位数，左边补上 00，也就是说，对于正数来说，二者一样，而负数通过 &gt;&gt;&gt; 后能变成正数。<br>下面解释上面的模板中，取中位数的时候使用先用“＋”，然后“无符号右移”。</p><p>a、int mid = (left + right) / 2 与 int mid = left + (right - left) / 2 两种写法都有整型溢出的风险，没有哪一个是绝对安全的，注意：这里我们取平均值用的是除以 2，并且是整除：</p><p>int mid = (left + right) / 2 在 left 和 right 都很大的时候会溢出；<br>int mid = left + (right - left) / 2 在 right 很大，且 left 是负数且很小的时候会溢出；<br>b、写算法题的话，一般是让你在数组中做二分查找，因此 left 和 right 一般都表示数组的索引，因此 left 在绝大多数情况下不会是负数并且很小，因此使用 int mid = left + (right - left) // 2 相对 int mid = (left + right) // 2 更安全一些，并且也能向别人展示我们注意到了整型溢出这种情况，但事实上，还有更好的方式；</p><p>c、建议使用 int mid = (left + right) &gt;&gt;&gt; 1 这种写法，其实是大有含义的：</p><p>JDK8 中采用 int mid = (left + right) &gt;&gt;&gt; 1 ，重点不在 + ，而在 &gt;&gt;&gt; 。</p><p>我们看极端的情况，left 和 high 都是整型最大值的时候，注意，此时 3232 位整型最大值它的二进制表示的最高位是 00，它们相加以后，最高位是 11 ，变成负数，但是再经过无符号右移 &gt;&gt;&gt;（重点是忽略了符号位，空位都以 00 补齐），就能保证使用 + 在整型溢出了以后结果还是正确的。</p><p>Java 中 Collections 和 Arrays 提供的 binarySearch 方法，我们点进去看 left 和 right 都表示索引，使用无符号右移又不怕整型溢出，那就用 int mid = (left + right) &gt;&gt;&gt; 1 好啦。位运算本来就比使用除法快，这样看来使用 + 和 &lt;&lt;&lt; 真的是又快又好了。</p><p>我想这一点可能是 JDK8 的编写者们更层次的考量。</p><p>看来以后写算法题，就用 int mid = (left + right) &gt;&gt;&gt; 1 吧，反正更多的时候 left 和 right 表示索引。</p><p><strong>8、编码一旦出现死循环，输出必要的变量值、分支逻辑是调试的重要方法。</strong><br>当出现死循环的时候的调试方法：打印输出左右边界、中位数的值和目标值、分支逻辑等必要的信息。</p><p>按照我的经验，一开始编码的时候，稍不注意就很容易出现死循环，不过没有关系，你可以你的代码中写上一些输出语句，就容易理解“在区间元素只有 2 个的时候容易出现死循环”。具体编码调试的细节，可以参考我在「力扣」第 69 题：x 的平方根的题解《二分查找 + 牛顿法（Python 代码、Java 代码）》 。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下，我爱用这个模板的原因、技巧、优点和注意事项：</p><p><strong>原因：</strong><br>无脑地写 while left &lt; right: ，这样你就不用判断，在退出循环的时候你应该返回 left 还是 right，因为返回 left 或者 right 都对；</p><p><strong>技巧：</strong><br>先写分支逻辑，并且先写排除中位数的逻辑分支（因为更多时候排除中位数的逻辑容易想，但是前面我也提到过，这并不绝对），另一个分支的逻辑你就不用想了，写出第 1 个分支的反面代码即可（下面的说明中有介绍），再根据分支的情况选择使用左中位数还是右中位数；</p><p>说明：这里再多说一句。如果从代码可读性角度来说，只要是你认为好想的逻辑分支，就把它写在前面，并且加上你的注释，这样方便别人理解，而另一个分支，你就不必考虑它的逻辑了。有的时候另一个分支的逻辑并不太好想，容易把自己绕进去。如果你练习做得多了，会形成条件反射。</p><p>我简单总结了一下，左右分支的规律就如下两点：</p><p>如果第 1 个分支的逻辑是“左边界排除中位数”（left = mid + 1），那么第 2 个分支的逻辑就一定是“右边界不排除中位数”（right = mid），反过来也成立；</p><p>如果第 2 个分支的逻辑是“右边界排除中位数”（right = mid - 1），那么第 2 个分支的逻辑就一定是“左边界不排除中位数”（left = mid），反之也成立。</p><p>“反过来也成立”的意思是：如果在你的逻辑中，“边界不能排除中位数”的逻辑好想，你就把它写在第 1 个分支，另一个分支是它的反面，你可以不用管逻辑是什么，按照上面的规律直接给出代码就可以了。能这么做的理论依据就是“排除法”。</p><p>在「力扣」第 287 题：寻找重复数的题解《二分法（Python 代码、Java 代码）》和这篇题解的评论区中，有我和用户<br>@fighterhit 给出的代码，在一些情况下，我们先写了不排除中位数的逻辑分支，更合适的标准就是“哪个逻辑分支好想，就先写哪一个”，欢迎大家参与讨论。</p><p><strong>优点：</strong><br>分支条数只有 2 条，代码执行效率更高，不用在每一轮循环中单独判断中位数是否符合题目要求，写分支的逻辑的目的是尽量排除更多的候选元素，而判断中位数是否符合题目要求我们放在最后进行，这就是第 5 点；</p><p>说明：每一轮循环开始都单独判断中位数是否符合要求，这个操作不是很有普适性，因为从统计意义上说，中位数直接就是你想找的数的概率并不大，有的时候还要看看左边，还要看看右边。不妨就把它放在最后来看，把候选区间“夹逼”到只剩 11 个元素的时候，视情况单独再做判断即可。</p><p><strong>注意事项 1：</strong><br>左中位数还是右中位数选择的标准根据分支的逻辑而来，标准是每一次循环都应该让区间收缩，当候选区间只剩下 22 个元素的时候，为了避免死循环发生，选择正确的中位数类型。如果你实在很晕，不防就使用有 22 个元素的测试用例，就能明白其中的原因，另外在代码出现死循环的时候，建议你可以将左边界、右边界、你选择的中位数的值，还有分支逻辑都打印输出一下，出现死循环的原因就一目了然了；</p><p><strong>注意事项 2：</strong><br>如果能确定要找的数就在候选区间里，那么退出循环的时候，区间最后收缩成为 11 个数后，直接把这个数返回即可；如果你要找的数有可能不在候选区间里，区间最后收缩成为 11 个数后，还要单独判断一下这个数是否符合题意。</p><p>最后给出两个模板，大家看的时候看注释，不必也无需记忆它们。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191203181446.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191203181505.png" alt=""></p><p>说明：我写的时候，一般是先默认将中位数写成左中位数，再根据分支的情况，看看是否有必要调整成右中位数，即是不是要在 (right - left) 这个括号里面加 11 。</p><p>虽说是两个模板，区别在于选中位数，中位数根据分支逻辑来选，原则是区间要收缩，且不出现死循环，退出循环的时候，视情况，有可能需要对最后剩下的数单独做判断。</p><p>我想我应该是成功地把你绕晕了，如果您觉得啰嗦的地方，就当我是“重要的事情说了三遍”吧，确实是重点的地方我才会重复说。当然，最好的理解这个模板的方法还是应用它。在此建议您不妨多做几道使用“二分查找法”解决的问题，用一下我说的这个模板，在发现问题的过程中，体会这个模板好用的地方，相信你一定会和我一样爱上这个模板的。</p><p>在「力扣」的探索版块中，给出了二分查找法的 3 个模板，我这篇文章着重介绍了第 2 个模板，但是我介绍的角度和这个版块中给出的角度并不一样，第 1 个模板被我“嫌弃”了，第 3 个模板我看过了，里面给出的例题也可以用第 2 个模板来完成，如果大家有什么使用心得，欢迎与我交流。</p><p>来源：<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">力扣（LeetCode）</a>，作者：liweiwei1419</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;leetcode35&quot;&gt;&lt;a href=&quot;#leetcode35&quot; class=&quot;headerlink&quot; title=&quot;leetcode35&quot;&gt;&lt;/a&gt;leetcode35&lt;/h3&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;你可以假设数组中无重复元素。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://removeif.github.io/categories/algorithm/"/>
    
    
      <category term="二分查找" scheme="https://removeif.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>github Issue 作为博客微型数据库的应用</title>
    <link href="https://removeif.github.io/theme/github-Issue-%E4%BD%9C%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%BE%AE%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%BA%94%E7%94%A8.html"/>
    <id>https://removeif.github.io/theme/github-Issue-作为博客微型数据库的应用.html</id>
    <published>2019-11-28T14:02:05.000Z</published>
    <updated>2019-12-13T02:22:22.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>众所周知，对于hexo框架搭建的静态博客，难免会产生一些动态的数据，比如一些碎碎念、友链、音乐、时间轴等微型数据。目前一般的做法:</p><p>a.是创建一个json数据，来存储这些微型数据，但是如果数据太多的话，一是比较慢，二是有个硬伤问题，就是json数据不能分页请求，只能一次拿完，太多的话网络带宽占用太多。<br><a id="more"></a></p><p>b.或者有的直接后台写一些接口服务啥的，还得在买个服务器部署上去，然后博客中访问接口。</p><p>c.或者有些可能就直接写到html中。</p><p>对于a、c方法都比较麻烦，每次更新了都要编译部署，不能很方便的动态更新。对于b的话，成本以及技术要求可能就更多一些了。</p><p>基于上面出现的问题，目前想到的一个解决方案就是，利用github 的issue作为一个微型数据库。能够很方便的动态更新，也能分页，也不需要啥json文件，想想都很方便。</p><h3 id="issue数据库使用步骤"><a href="#issue数据库使用步骤" class="headerlink" title="issue数据库使用步骤"></a>issue数据库使用步骤</h3><h4 id="issue的创建"><a href="#issue的创建" class="headerlink" title="issue的创建"></a>issue的创建</h4><p>先创建一个Repository，对于此Repository可以专门作为微型的数据库，取名issue_database。创建好之后建立一些issue</p><p>如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191128213154.png" alt=""></p><p>目前博客中，所有的动态数据都放到issue中了。</p><h4 id="issue中存储数据"><a href="#issue中存储数据" class="headerlink" title="issue中存储数据"></a>issue中存储数据</h4><p>对于创建好的issue，就可以往里面写数据了，比如我的友链数据为issue：blog_friends</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191128213427.png" alt=""></p><p>对于issue中存储的数据最好存json格式的，因为可以方便后面取出来使用。存储好数据后，如果太多的话，可以点击hide,隐藏起来。同时这个issue最好给<code>Lock conversation</code>这样的好处是，防止别人往里面加些脏数据，只能自己往里写数据。哈哈，一般也没有闲的无聊的网友恶作剧。这样就存储好数据了。</p><h4 id="博客中获取issue数据"><a href="#博客中获取issue数据" class="headerlink" title="博客中获取issue数据"></a>博客中获取issue数据</h4><p>博客中通过js获取issue中的数据，以博客友链为例，以下是获取代码，以及处理</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// author by removef</span></span><br><span class="line"><span class="hljs-comment">// https://removeif.github.io/</span></span><br><span class="line">$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//获取处理友链数据，来自issue，一次取完</span></span><br><span class="line">    $.getJSON(<span class="hljs-string">"https://api.github.com/repos/removeif/issue_database/issues/2/comments?per_page=100&amp;client_id=46a9f3481b46ea0129d8&amp;client_secret=79c7c9cb847e141757d7864453bcbf89f0655b24"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> data = [];</span><br><span class="line">        <span class="hljs-keyword">var</span> source1;</span><br><span class="line">        source1 = source;</span><br><span class="line">      <span class="hljs-comment">// 以后每次更新的都在后面，此处倒序，按时间降序排</span></span><br><span class="line">        source1.reverse();</span><br><span class="line">      <span class="hljs-comment">// 把所有的数据放到data的列表中</span></span><br><span class="line">        $.each(source1, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i, e</span>) </span>&#123;</span><br><span class="line">            data.push(...JSON.parse(e.body));</span><br><span class="line">        &#125;);</span><br><span class="line">      </span><br><span class="line">        $.each(data, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i, e</span>) </span>&#123;</span><br><span class="line">          <span class="hljs-comment">// 博客中html文件的构建，渲染</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中client_id、client_secret在另一篇文章中<strong><a href="https://removeif.github.io/2019/09/19/%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB.html">博客源码分享</a></strong>有详细的说明,可以查看一下。这样就能获取到相应的数据，进行操作。</p><h4 id="issue数据的更新"><a href="#issue数据的更新" class="headerlink" title="issue数据的更新"></a>issue数据的更新</h4><p>比如想更新任意一项数据都可以进github中对应的仓库的issue下进行更新，添加。然后实时去博客中查看。</p><h3 id="扩展一下"><a href="#扩展一下" class="headerlink" title="扩展一下"></a>扩展一下</h3><p>对于有些爱唠叨的人（比如我），弄个类似碎碎念的东西就比较实用了。之前想过各种方案，存json数据太不方便；后台写个服务部署服务器也太麻烦。最后思来想去还是利用了下现成的优秀项目<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">gitalk</a>,稍稍改改就能很好使用。</p><h4 id="博客中的碎碎念"><a href="#博客中的碎碎念" class="headerlink" title="博客中的碎碎念"></a>博客中的碎碎念</h4><p>对于博主而言，有发表框和修改的操作，能够方便发表和修改。</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191128215148.png" alt=""></p><p>可能有时候还会发表一些图片，对图片的样式做了一些控制</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191128215345.png" alt=""></p><p>对于网友的话只能查看以及点赞加❤️</p><p><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191128215555.png" alt=""></p><p>做法就是源码中改下返回html的文件内容，如果是管理员和非管理员返回一些不同的元素，能够很好的实现碎碎念的功能。<br>查看<a href="https://removeif.github.io/self-talking/">碎碎念</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>静态博客的动态数据是个痛点，GitHub Issue有很多可利用的地方。多去探索发掘其中的奥妙。</p><p>利用GitHub Issue来解决目前也是一种解决方法。希望后面会出现更好的解决方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;众所周知，对于hexo框架搭建的静态博客，难免会产生一些动态的数据，比如一些碎碎念、友链、音乐、时间轴等微型数据。目前一般的做法:&lt;/p&gt;
&lt;p&gt;a.是创建一个json数据，来存储这些微型数据，但是如果数据太多的话，一是比较慢，二是有个硬伤问题，就是json数据不能分页请求，只能一次拿完，太多的话网络带宽占用太多。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具教程" scheme="https://removeif.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
      <category term="主题工具" scheme="https://removeif.github.io/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具教程" scheme="https://removeif.github.io/tags/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>苹果6s ios12 nfc 模拟门禁</title>
    <link href="https://removeif.github.io/ios/%E8%8B%B9%E6%9E%9C6s-ios12-nfc-%E6%A8%A1%E6%8B%9F%E9%97%A8%E7%A6%81.html"/>
    <id>https://removeif.github.io/ios/苹果6s-ios12-nfc-模拟门禁.html</id>
    <published>2019-11-23T12:51:32.000Z</published>
    <updated>2019-11-23T13:54:47.357Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，ios系统封闭了对NFC的功能使用。据了解，国外是可以使用的，国内不行，实在搞不懂，有NFC又不能用，这不是浪费资源，多此一举嘛！<br><a id="more"></a></p><h3 id="设备信息"><a href="#设备信息" class="headerlink" title="设备信息"></a>设备信息</h3><p><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123204913.png" alt="设备信息"></div><br><strong>本机信息6s ios12.4 16G</strong><br>ios 11 直接就能读出卡，没这么复杂。<br>ios 12 可以使用，比较复杂。<br>ios 13 好像不能使用。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="越狱"><a href="#越狱" class="headerlink" title="越狱"></a>越狱</h4><p>使用之前需要设备能够越狱，关于越狱后的一系列安全问题请自行百度。越狱方法可以进<a href="https://www.feng.com/" target="_blank" rel="noopener">威锋论坛</a><br>找到自己机型版块里的对应教程。<br>本机是通过Windows爱思助手，一键越狱完成。</p><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>源为图中倒数第三个P开头那个，插件为插件图中打钩的那个，有些插件和源的不能用，目前测试这个源和插件是可用的。</p><p><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212225.png" alt="源"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212307.png" alt="插件"><div></div></div></p><h4 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h4><p><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212532.png" alt="图1"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212614.png" alt="图2"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212642.png" alt="图3"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212703.png" alt="图4"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212727.png" alt="图5"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191123212755.png" alt="图6"></div><br>1.图1，如果是ios11,点击最上面的scan按钮，靠近门禁卡或公交卡就能读出来，但是iOS12读不出。<br>2.图2，点最后一项。<br>3.图3，点击Connect按钮，把卡靠近手机后壳。<br>4.图4，已经读出UID。<br>5.图5，把UID填上。<br>6.图6，然后点击Start按钮，如图开始模拟nfc卡。靠近刷卡机刷卡。<br>我添加的是门禁卡，亲测成功。也能读取添加公交卡，没测试，应该是可以的。<br>每次只能模拟一张卡，使用另外一张需要手动更换UID。</p><h3 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h3><p>操作中造成的一切损失与博主无关，请自行掂量谨慎操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，ios系统封闭了对NFC的功能使用。据了解，国外是可以使用的，国内不行，实在搞不懂，有NFC又不能用，这不是浪费资源，多此一举嘛！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ios" scheme="https://removeif.github.io/categories/ios/"/>
    
    
      <category term="ios" scheme="https://removeif.github.io/tags/ios/"/>
    
      <category term="nfc" scheme="https://removeif.github.io/tags/nfc/"/>
    
  </entry>
  
  <entry>
    <title>常见隔夜菜谨慎食用</title>
    <link href="https://removeif.github.io/health/%E5%B8%B8%E8%A7%81%E9%9A%94%E5%A4%9C%E8%8F%9C%E8%B0%A8%E6%85%8E%E9%A3%9F%E7%94%A8.html"/>
    <id>https://removeif.github.io/health/常见隔夜菜谨慎食用.html</id>
    <published>2019-11-18T08:05:43.000Z</published>
    <updated>2019-11-18T10:04:16.229Z</updated>
    
    <content type="html"><![CDATA[<p>我们有许多习惯，总是重复来，重复去，就像上世纪中的人们带着保温盒去上班，现在的人又重回带着饭盒去公司的现象。自己带饭去公司吃的话，不仅大大地节省了一笔吃外卖的费用，而且菜色也可以随便换。但是，很多人带的都是前一天晚上就准备好的隔夜菜，这样对我们的身体健康到底是有益还是有害呢?<br><a id="more"></a></p><h3 id="隔夜菜的危害大"><a href="#隔夜菜的危害大" class="headerlink" title="隔夜菜的危害大"></a>隔夜菜的危害大</h3><p>节俭归节俭，殊不知，隔夜菜不仅营养流失严重，而且还会产生对身体有危害的物质。要提醒大家的是，<code>隔夜蔬菜、海鲜</code>不要吃，肉类食用时一定要蒸热熟透，以防食物储存时间长，腐败变质，导致食物中毒。</p><p>据说，<code>胃癌发病率低，与不吃隔夜蔬菜的习惯有关</code>。由于部分绿叶类蔬菜中含有较多的硝酸盐类，煮熟后假如放置的时间过久，在细菌的分解作用下，硝酸盐便会还原成亚硝酸盐，有致癌作用，加热也不能去除。</p><p><strong>健康吃法</strong>：通常<strong>茎叶类蔬菜硝酸盐含量最高</strong>，<strong>瓜类蔬菜稍低</strong>，<strong>根茎类和花菜类居中</strong>。因此，假如同时购买了不同种类的蔬菜，应该先吃茎叶类的，比如大白菜、菠菜等。假如预备多做一些菜第二天热着吃的话，应尽量<code>少做茎叶类蔬菜</code>，而<code>选择瓜类蔬菜</code>。</p><h3 id="五种隔夜菜千万别吃"><a href="#五种隔夜菜千万别吃" class="headerlink" title="五种隔夜菜千万别吃"></a>五种隔夜菜千万别吃</h3><p><strong>绿叶菜隔夜最危险</strong>。通常茎叶类蔬菜硝酸盐含量最高，瓜类蔬菜稍低，根茎类和花菜类居中。因此，如果同时购买了大量蔬菜，应该先吃叶菜类的，比如大白菜、菠菜等。如果准备多做一些菜第二天热着吃，应尽量少做茎叶类蔬菜，而选择瓜类蔬菜。</p><p><strong>隔夜海鲜损肝肾</strong>。螃蟹、鱼类、虾类等海鲜，隔夜后会产生蛋白质降解物，损伤肝、肾功能。如果实在买多了，可以把生海鲜用保鲜袋或保鲜盒装好，放入冰箱冷冻，下次再烹调。</p><p><strong>半熟蛋易致病</strong>。很多人都爱吃蛋黄软软的半熟蛋，可是这种蛋杀菌不彻底，再加上鸡蛋营养丰富，格外容易滋生细菌，食用后会发生危险。如果蛋已熟透，而且低温密封保存得当，隔夜再吃是没有问题的。</p><p><strong>银耳蘑菇要当心</strong>。不论是野生的还是人工栽培的银耳、蘑菇等，都容易残留很多硝酸盐。如果放的时间实在有点久，就只能忍痛扔掉。</p><p><strong>汤别放金属器皿里</strong>。熬汤费时费力，人们往往熬一大锅，一连吃好几天。剩汤如果长时间盛在铝锅、铁锅内，会析出对人体有害的物质。存汤的最好办法是，汤里不要放盐之类的调味料，煮好汤用干净的勺子盛出当天要喝的，喝不完的，最好是用瓦锅或保鲜盒存放在冰箱里。</p><h3 id="隔夜菜的保存和食用"><a href="#隔夜菜的保存和食用" class="headerlink" title="隔夜菜的保存和食用"></a>隔夜菜的保存和食用</h3><p>因为蔬菜对于健康有明确的好处，我们不可能因为“可能”有硝酸盐和亚硝酸盐的存在就不吃。对许多人来说，买一次菜吃几天也是很普通很平常的事情。所以，保存蔬菜，就成了食品健康中很重要的问题。</p><p>蔬菜中亚硝酸盐的产生，原料是蔬菜中的硝酸盐，转化条件主要是细菌生长，“隔夜”只是时间长短的问题。减少亚硝酸盐的产生，可以多管齐下。首先，减少蔬菜尤其是绿叶蔬菜的保存时间，增加买菜频率。其次，需要保存的蔬菜，洗净包好可以减少携带的细菌。做好没吃完的蔬菜，也可以封好保存在冰箱中。</p><p>“隔夜”并非亚硝酸盐产生的关键，加热也不会增加致癌物的含量。当然，蔬菜中的许多种维生素，在加热的时候会被破坏，多次加热的蔬菜也比较难吃。从“ 好吃”的角度来说，“隔夜菜”确实比较差;从营养的角度说，多次加热也没什么好处。</p><h3 id="常见的蔬菜分类"><a href="#常见的蔬菜分类" class="headerlink" title="常见的蔬菜分类"></a>常见的蔬菜分类</h3><p><strong>瓜类蔬菜</strong>种类较多,主要有黄瓜、西葫芦、南瓜、节瓜、<a href="https://www.baidu.com/s?wd=青瓜&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">青瓜</a>、丝瓜、云南小瓜、苦瓜、白瓜、茄瓜、毛瓜、<a href="https://www.baidu.com/s?wd=瓠瓜&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">瓠瓜</a>、<a href="https://www.baidu.com/s?wd=佛手瓜&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">佛手瓜</a>、<a href="https://www.baidu.com/s?wd=蛇瓜&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">蛇瓜</a>等。其中，黄瓜为果菜兼用的<a href="https://www.baidu.com/s?wd=大众&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">大众</a>蔬菜，南瓜、苦瓜是药食兼用的保健蔬菜，冬瓜为秋淡季的主要蔬菜，其它瓜类则风味各异，都是膳食佳品。瓜类蔬菜在栽培中具有以下通性：<br>1、瓜类蔬菜均为喜温耐热性作物，生长期间需要充足的光照。<br>2、瓜类蔬菜根系<a href="https://www.baidu.com/s?wd=再生能力&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">再生能力</a>弱，栽培上除直播外，育苗移栽的要保护好根系，培育壮苗。<br>3、瓜类蔬菜均为蔓性作物，生产中通过设立支架可提高产品的产量与品质。<br>4、大部分瓜类蔬菜的采收要及时，防止产品生理成熟后降低品质。<br>5、瓜类蔬菜均为雌雄异花作物，虫媒<a href="https://www.baidu.com/s?wd=异花授粉&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">异花授粉</a></p><p><strong>蔬菜植物</strong>的产品器官有根、茎、叶、花、果等5类，因此按产品器官分类也分成5种。<br><strong>(1)根菜类</strong>：这类莱的产品(食用)器官为肉质根或块根。<br>    ①肉质根类菜：萝卜、胡萝卜、大头菜(<a href="https://www.baidu.com/s?wd=根用芥菜&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">根用芥菜</a>)、芜普、<a href="https://www.baidu.com/s?wd=芜菁甘蓝&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">芜菁甘蓝</a>和根用甜菜等。<br>    ②块根类菜：豆薯和葛等。</p><p><strong>(2)茎菜类</strong>：这类蔬菜食用部分为茎或茎的变态。<br>    ①地下茎类：马铃薯、菊芋、莲藕、姜、荸荠、慈菇和芋等。<br>    ②地上茎类：茭白、石刁柏、竹笋、莴苣笋、<a href="https://www.baidu.com/s?wd=球茎甘蓝&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">球茎甘蓝</a>和榨菜等。</p><p><strong>(3)叶莱类</strong>：这类蔬菜以普通叶片或叶球、叶丛、变态叶为产品器官。<br>    ①普通叶菜类：小白菜、芥菜、菠菜、芹菜和苋菜等。<br>    ②结球叶莱类：<a href="https://www.baidu.com/s?wd=结球甘蓝&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">结球甘蓝</a>、大白菜、<a href="https://www.baidu.com/s?wd=结球莴苣&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">结球莴苣</a>和<a href="https://www.baidu.com/s?wd=包心芥菜&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">包心芥菜</a>等。<br>    ③辛番叶菜类：葱、韭菜、芜荽和茴香等。<br>    ④鳞茎菜类：洋葱、大蒜和百合等。</p><p><strong>(4)花菜类</strong>：这类蔬菜以花、肥大的花茎或花球为产品器官，如花椰菜、金针菜、青花菜、紫菜蔓、 朝鲜蓟和芥蓝等。</p><p><strong>(5)果菜类</strong>：这类蔬菜以嫩果实或成熟的果实为产品器官。<br>    ①茄果类：茄子、番茄和辣椒等。<br>    ②荚果类：豆类菜，菜豆、肛豆、刀豆、毛豆、豌豆、蚕豆、眉豆、扁豆和四棱豆等。<br>    ③瓠果类：黄瓜、南瓜、冬瓜、丝瓜、菜瓜、瓠瓜和蛇瓜等，以及西瓜和甜瓜等鲜食的瓜类。</p><p>参考文章:<br><a href="http://shipin.people.com.cn/n/2015/1026/c85914-27740921.html" target="_blank" rel="noopener">参考链接1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们有许多习惯，总是重复来，重复去，就像上世纪中的人们带着保温盒去上班，现在的人又重回带着饭盒去公司的现象。自己带饭去公司吃的话，不仅大大地节省了一笔吃外卖的费用，而且菜色也可以随便换。但是，很多人带的都是前一天晚上就准备好的隔夜菜，这样对我们的身体健康到底是有益还是有害呢?&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="health" scheme="https://removeif.github.io/categories/health/"/>
    
    
      <category term="health" scheme="https://removeif.github.io/tags/health/"/>
    
  </entry>
  
  <entry>
    <title>马拉松-2019西昌最美赛道邛海马拉松</title>
    <link href="https://removeif.github.io/marathon/%E9%A9%AC%E6%8B%89%E6%9D%BE-2019%E8%A5%BF%E6%98%8C%E6%9C%80%E7%BE%8E%E8%B5%9B%E9%81%93%E9%82%9B%E6%B5%B7%E9%A9%AC%E6%8B%89%E6%9D%BE.html"/>
    <id>https://removeif.github.io/marathon/马拉松-2019西昌最美赛道邛海马拉松.html</id>
    <published>2019-11-10T02:03:35.000Z</published>
    <updated>2019-11-12T01:42:59.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最美赛道，2019西昌邛海湿地马拉松于2019.11.09举行。<br><a id="more"></a></p></blockquote><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>比赛之前抱佛脚的方式晚上跑了几晚，还是训练太少，导致最后的悲剧产生，怨不得别人还是自己不努力，捂脸.jpg。<br>以下是比赛之前的部分数据。总共跑了6次。</p><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110101312.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110101333.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110101358.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110101412.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110101429.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110101555.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110101615.jpg" alt=""></div><h3 id="路上风景"><a href="#路上风景" class="headerlink" title="路上风景"></a>路上风景</h3><p>从成都出发去西昌，一路上风景还是很美的，盘山高速立于半空之中，很刺激。途中的岩石，丛林，纷繁各异。<br>不得不惊叹祖国的大好河山，以及大自然的鬼斧神工。<br>车上位置不太好，也拍了几张。<br>途中流彩。</p><div class="img-x"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102533.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102629.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102653.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102729.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102746.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102820.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102911.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102934.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110102953.jpg" alt=""></div><h3 id="赛前"><a href="#赛前" class="headerlink" title="赛前"></a>赛前</h3><p>比赛之前领了相关的参赛包。找好了相应的住宿，然后休息。</p><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104003.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104025.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104046.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104105.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104121.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104141.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104157.jpg" alt=""></div><h3 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h3><p>整个赛道中风景很美，最美赛道也不是吹的，哈哈。<br>赛中流彩1</p><div class="img-x"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110104953.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105016.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105044.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105112.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105135.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105159.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105352.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105417.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105436.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105453.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105513.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105531.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105555.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110105614.jpg" alt=""></div><br>赛中流彩2<br><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110120604.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110120703.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110110218.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110110239.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110120818.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110120933.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110121042.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110121208.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110114345.jpg" alt=""></div><h3 id="完赛"><a href="#完赛" class="headerlink" title="完赛"></a>完赛</h3><p>人生不经历一场全程马拉松真的不知道自己身体有多差，跑到30KM之后基本靠走，抽筋，一会儿左脚一会右脚，太难了。<br>归根到底还是前期准备太少了，跑的太少了，不能临时抱佛脚啊。没有捷径，得一步一步的积累啊。这就是血淋淋的案例啊。<br>跑两步，抽一下，又不得不停下来走，真的是太难了，之前跑过两次半马，没出现这个情况，可能我的极限就是30KM了吧。<br>最后还是坚持走完了，用时<code>5小时8分钟</code>，赶在6小时关门前跑完了。第一次全马，也算PB了吧。<br>全马数据。</p><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110115052.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110115113.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110115127.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110115143.jpg" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110115156.jpg" alt=""></div><h3 id="奖牌"><a href="#奖牌" class="headerlink" title="奖牌"></a>奖牌</h3><p>奖牌还是挺不错的，挺有纪念意义的。人生第一次全马，也可能是最后一次，庆幸自己坚持下来安全完赛，给自己点个赞👍！</p><div class="img-y"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110115954.png" alt=""><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191110120101.png" alt=""></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>人生就像一场马拉松，有悲有乐，有意外有惊喜，沿途有各种美丽的风景，遇见。这一路肯定不会一番风顺，希望我们遇到困难险阻时都能乘风破浪，坚持到最后。<br>当我们到了人生暮年的时候，回想起过去，也能都感觉到这人生不虚此行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最美赛道，2019西昌邛海湿地马拉松于2019.11.09举行。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="marathon" scheme="https://removeif.github.io/categories/marathon/"/>
    
    
      <category term="marathon" scheme="https://removeif.github.io/tags/marathon/"/>
    
  </entry>
  
  <entry>
    <title>算法成长之路leetcode1-4</title>
    <link href="https://removeif.github.io/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode1-4.html"/>
    <id>https://removeif.github.io/algorithm/算法成长之路leetcode1-4.html</id>
    <published>2019-11-05T10:18:47.000Z</published>
    <updated>2019-11-07T05:31:41.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1.Two Sum"></a>1.<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a></h2><h3 id="desc"><a href="#desc" class="headerlink" title="desc"></a>desc</h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br><a id="more"></a></p><p><strong>Example:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><h4 id="s-eg1"><a href="#s-eg1" class="headerlink" title="s.eg1."></a>s.eg1.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//24 ms38 MB s.O(n^2) k.O(1)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span>[] result =<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length-<span class="hljs-number">1</span>;i++)&#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                    result[<span class="hljs-number">0</span>] = i;</span><br><span class="line">                    result[<span class="hljs-number">1</span>] = j;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eg2"><a href="#eg2" class="headerlink" title="eg2."></a>eg2.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 3 ms37.2 MB s.O(n) k.O(n)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; cache = <span class="hljs-keyword">new</span> HashMap();</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(cache.get(nums[i]) != <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;cache.get(nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            cache.put(target-nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2.Add Two Numbers"></a>2.<a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">Add Two Numbers</a></h2><h3 id="des"><a href="#des" class="headerlink" title="des"></a>des</h3><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h3><h4 id="eg1"><a href="#eg1" class="headerlink" title="eg1."></a>eg1.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 2 ms44.7 MB</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">         <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>; <span class="hljs-comment">// 进位</span></span><br><span class="line">         ListNode head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);</span><br><span class="line">         ListNode cur = head; <span class="hljs-comment">// 一定要用两个链表，不能用一个操作</span></span><br><span class="line">       <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> ||l2 != <span class="hljs-keyword">null</span>|| carry != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// lastSum当最后一位刚好进1的时候，需要在循环</span></span><br><span class="line">           </span><br><span class="line">            <span class="hljs-keyword">int</span> l1v =  l1 == <span class="hljs-keyword">null</span>?<span class="hljs-number">0</span>:l1.val;</span><br><span class="line">            <span class="hljs-keyword">int</span> l2v =  l2 == <span class="hljs-keyword">null</span>?<span class="hljs-number">0</span>:l2.val;</span><br><span class="line">            <span class="hljs-keyword">int</span> temp =l1v+l2v+carry;</span><br><span class="line">            ListNode node;</span><br><span class="line">            <span class="hljs-keyword">if</span>(temp&gt;=<span class="hljs-number">10</span>)&#123;</span><br><span class="line">               node = <span class="hljs-keyword">new</span> ListNode(temp-<span class="hljs-number">10</span>);</span><br><span class="line">               lastSum = <span class="hljs-number">1</span>;</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">               node = <span class="hljs-keyword">new</span> ListNode(temp);</span><br><span class="line">               lastSum = <span class="hljs-number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-keyword">null</span>) l2 = l2.next;</span><br><span class="line">         </span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3.Longest Substring Without Repeating Characters"></a>3.<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></h2><h3 id="desc-1"><a href="#desc-1" class="headerlink" title="desc"></a>desc</h3><p>Given a string, find the length of the longest substring without repeating characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h3><h4 id="eg1-1"><a href="#eg1-1" class="headerlink" title="eg1."></a>eg1.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//2 ms 24.05% 36.9 MB 95.35%</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; strSet = <span class="hljs-keyword">new</span> HashSet();</span><br><span class="line">        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span>(s != <span class="hljs-keyword">null</span> &amp;&amp; s.length() &gt;<span class="hljs-number">0</span>)&#123;</span><br><span class="line">            <span class="hljs-keyword">char</span> ss[] = s.toCharArray(); <span class="hljs-comment">//利用toCharArray方法转换</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ss.length-<span class="hljs-number">1</span>; i++) &#123;</span><br><span class="line">                strSet.add(ss[i]);</span><br><span class="line">                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j&lt;ss.length; j++)&#123;</span><br><span class="line">                    <span class="hljs-keyword">int</span> oL = strSet.size();</span><br><span class="line">                    strSet.add(ss[j]);</span><br><span class="line">                    <span class="hljs-keyword">int</span> cL = strSet.size();</span><br><span class="line">                    <span class="hljs-keyword">if</span>(oL != cL)&#123; <span class="hljs-comment">// 不相等时记下个数</span></span><br><span class="line">                        <span class="hljs-keyword">if</span>(cL &gt; maxLen)&#123;</span><br><span class="line">                            maxLen = cL;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 相等时 跳出此次循环 清空set</span></span><br><span class="line">                           strSet.clear();</span><br><span class="line">                           <span class="hljs-keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span>(maxLen == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 全相等时</span></span><br><span class="line">                maxLen = <span class="hljs-number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eg2-1"><a href="#eg2-1" class="headerlink" title="eg2."></a>eg2.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 2 ms37.3 MB</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="hljs-keyword">int</span> leftIndex = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录最左边相等时的值，然后向右滑动窗口</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; chars.length; j++) &#123;</span><br><span class="line">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> innerIndex = leftIndex; innerIndex &lt; j; innerIndex++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (chars[innerIndex] == chars[j]) &#123;</span><br><span class="line">              maxLength = Math.max(maxLength, j - leftIndex);</span><br><span class="line">              leftIndex = innerIndex + <span class="hljs-number">1</span>;</span><br><span class="line">              <span class="hljs-keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> Math.max(chars.length - leftIndex, maxLength);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4.Median of Two Sorted Arrays"></a>4.<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">Median of Two Sorted Arrays</a></h2><h3 id="desc-2"><a href="#desc-2" class="headerlink" title="desc"></a>desc</h3><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><p><strong>Example 1:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><h3 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h3><h4 id="eg1-2"><a href="#eg1-2" class="headerlink" title="eg1."></a>eg1.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 20 ms  10.07%</span></span><br><span class="line"><span class="hljs-comment">// 2.2 MB 99.84%</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> maxL = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (nums1.length &gt;= nums2.length) &#123;</span><br><span class="line">            maxL = nums1.length;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            maxL = nums2.length;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; newList = <span class="hljs-keyword">new</span> ArrayList(maxL);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxL; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (i &lt; nums1.length) &#123;</span><br><span class="line">                newList.add(nums1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (i &lt; nums2.length) &#123;</span><br><span class="line">                newList.add(nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> size = newList.size();</span><br><span class="line">        <span class="hljs-keyword">int</span> index = size / <span class="hljs-number">2</span>;</span><br><span class="line">        newList.sort(Comparator.comparing(Integer::valueOf));</span><br><span class="line">        <span class="hljs-keyword">if</span> (size % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> (newList.get(index) + newList.get(index - <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span>d;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> newList.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eg2-2"><a href="#eg2-2" class="headerlink" title="eg2."></a>eg2.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> n = nums1.length + nums2.length;</span><br><span class="line">        <span class="hljs-keyword">double</span> res = <span class="hljs-number">0.0</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            res = (findKth(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n / <span class="hljs-number">2</span>) + findKth(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            res = findKth(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKth</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> start1, <span class="hljs-keyword">int</span> start2, <span class="hljs-keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (start1 &gt;= nums1.length) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> nums2[start2 + k - <span class="hljs-number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (start2 &gt;= nums2.length) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> nums1[start1 + k - <span class="hljs-number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">int</span> left = start1 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &gt;= nums1.length ? Integer.MAX_VALUE : nums1[start1 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>];</span><br><span class="line">        <span class="hljs-keyword">int</span> right = start2 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &gt;= nums2.length ? Integer.MAX_VALUE : nums2[start2 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>];</span><br><span class="line">        <span class="hljs-keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> findKth(nums1, nums2, start1 + k / <span class="hljs-number">2</span>, start2, k - k / <span class="hljs-number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> findKth(nums1, nums2, start1, start2 + k / <span class="hljs-number">2</span>, k - k / <span class="hljs-number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eg3"><a href="#eg3" class="headerlink" title="eg3."></a>eg3.</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 二分查找、分治算法</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//m:A数组的长度</span></span><br><span class="line">        <span class="hljs-keyword">int</span> m = A.length;</span><br><span class="line">        <span class="hljs-comment">//n:B数组的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> n = B.length;</span><br><span class="line">        <span class="hljs-comment">//如果A的长度大于B</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (m &gt; n) &#123; <span class="hljs-comment">// to ensure m&lt;=n</span></span><br><span class="line">            <span class="hljs-comment">//交换AB数组，确保m&lt;=n</span></span><br><span class="line">            <span class="hljs-keyword">int</span>[] temp = A; A = B; B = temp;</span><br><span class="line">            <span class="hljs-keyword">int</span> tmp = m; m = n; n = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//设置两个指针，iMin为头指针，IMAX为尾指针，halfLen为中位数指针</span></span><br><span class="line">        <span class="hljs-keyword">int</span> iMin = <span class="hljs-number">0</span>, iMax = m, halfLen = (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;</span><br><span class="line">        <span class="hljs-comment">//如果头指针走向不大于尾指针，进行循环</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (iMin &lt;= iMax) &#123;</span><br><span class="line">            <span class="hljs-comment">//i为中位数</span></span><br><span class="line">            <span class="hljs-keyword">int</span> i = (iMin + iMax) / <span class="hljs-number">2</span>;</span><br><span class="line">            <span class="hljs-comment">//j为</span></span><br><span class="line">            <span class="hljs-keyword">int</span> j = halfLen - i;</span><br><span class="line">            <span class="hljs-keyword">if</span> (i &lt; iMax &amp;&amp; B[j - <span class="hljs-number">1</span>] &gt; A[i])&#123;</span><br><span class="line">                iMin = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// i is too small</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; iMin &amp;&amp; A[i - <span class="hljs-number">1</span>] &gt; B[j]) &#123;</span><br><span class="line">                iMax = i - <span class="hljs-number">1</span>; <span class="hljs-comment">// i is too big</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// i is perfect</span></span><br><span class="line">                <span class="hljs-keyword">int</span> maxLeft = <span class="hljs-number">0</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123; maxLeft = B[j-<span class="hljs-number">1</span>]; &#125;</span><br><span class="line">                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123; maxLeft = A[i - <span class="hljs-number">1</span>]; &#125;</span><br><span class="line">                <span class="hljs-keyword">else</span> &#123; maxLeft = Math.max(A[i - <span class="hljs-number">1</span>], B[j - <span class="hljs-number">1</span>]); &#125;</span><br><span class="line">                <span class="hljs-keyword">if</span> ( (m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> ) &#123; <span class="hljs-keyword">return</span> maxLeft; &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">int</span> minRight = <span class="hljs-number">0</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span> (i == m) &#123; minRight = B[j]; &#125;</span><br><span class="line">                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == n) &#123; minRight = A[i]; &#125;</span><br><span class="line">                <span class="hljs-keyword">else</span> &#123; minRight = Math.min(B[j], A[i]); &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">return</span> (maxLeft + minRight) / <span class="hljs-number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Two-Sum&quot;&gt;&lt;a href=&quot;#1-Two-Sum&quot; class=&quot;headerlink&quot; title=&quot;1.Two Sum&quot;&gt;&lt;/a&gt;1.&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Two Sum&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;desc&quot;&gt;&lt;a href=&quot;#desc&quot; class=&quot;headerlink&quot; title=&quot;desc&quot;&gt;&lt;/a&gt;desc&lt;/h3&gt;&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://removeif.github.io/categories/algorithm/"/>
    
    
      <category term="二分查找" scheme="https://removeif.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="分治算法" scheme="https://removeif.github.io/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://removeif.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="滑动窗口" scheme="https://removeif.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
</feed>
