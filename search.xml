<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Immutable Object(不可变对象)模式]]></title>
    <url>%2F2018%2F11%2F13%2FImmutable-Object-%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1-%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[多线程下，一个对象会被多个线程共享，存在多线程并发地修改对象的属性，需要做些同步访问控制，如显示锁，CAS操作，会带来额外的开销和问题，如上下文切换、等待时间、ABA问题。Immutable Object模式意图通过使用对外可见的状态不可变的对象，使得天生具有线程安全性。 车辆管理系统状态可变的位置信息模型123456789101112131415161718192021public class Location &#123; private double x; private double y; public Location(double x, double y) &#123; this.x = x; this.y = y; &#125; public double getX() &#123; return x; &#125; public double getY() &#123; return y; &#125; public void setXY(double x, double y) &#123; this.x = x; this.y = y; &#125;&#125; 管理系统中会调用Location的setXY方法来更新位置，因为是非线程安全，并非原子操作，导致调用时会出现数据不一致的情况 改进：状态不可变的位置信息模型123456789public final class Location&#123; public final double x; public final double y; public Location(double x,double y)&#123; this.x = x; this.y = y; &#125;&#125; 使用状态不可变的对象时，更新信息模型时，如果车辆的位置发生变动，更新的是整个位置信息的对象 更新不可变对象的位置信息123456public class VehicleTracker&#123; private Map&lt;String,Location&gt; locMap = new ConcurrentHashMap&lt;String, Location&gt;(); public void updateLocation(String vehicleId,Location newLocation)&#123; locMap.put(vehicleId,newLocation); &#125; &#125; 一个严格意义上的不可变对象应该满足以下所有条件 类本身用final修饰 所有字段都是用final修饰，这个语意在多线程环境下由JVM保证了被修饰字段所引用对象的初始化安全，即final修饰的字段在其他线程是可见的，必定是初始化完成的。 在对象的创建过程中，this关键字没有泄露给其他类，防止其他类在对象创建过程中修改其状态 任何字段如果引用其他状态可变的对象，如集合数组，这些字段必须是private修饰的，不能暴露给外部，所有相关方法要返回这些字段值，应该防止防御性复制 实例： 某彩信网关系统 在处理由增值业务提供商VASP下发给手机终端用户的彩信信息时，需要根据彩信接收方号码的前缀选择对应的彩信中心MMSC，然后转发消息给选中的彩信中心。由其他系统将彩信信息下发给手机终端用户。选择彩信中心的过程称为 路由 ，手机前缀和彩信中心对应的关系叫路由表，在系统中多线程共享，很少改变此数据，不希望访问这些数据时进行加锁并发访问控制，避免产生不必要的开销，所以选择immutable object模型。 彩信中心路由规则管理器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/***彩信中心路由规则管理器**/public final class MMSCRouter&#123; // 保证多线程环境下该变量的可见性 private static volatile MMSCRouter instance = new MMSCRouter(); // 维护手机号码前缀到彩信中心之间的映射关系 private final Map&lt;String,MMSCInfo&gt; routerMap; public MMSCRouter()&#123; // 将数据库表中的数据加载到内存，存为Map this.routerMap = MMSCRouter.retrieveRouterMapFromDB(); &#125; private static Map&lt;String,MMSCInfo&gt; retrieveRouterMapFromDB()&#123; Map&lt;String,MMSCInfo&gt; map = new HashMap&lt;&gt;(); // 省略其余代码 return map; &#125; public static MMSCRouter getInstance()&#123; return instance; &#125; /** *根据手机号前缀获取彩信中心信息 **/ public MMSCInfo getMMSC(String msisdPrefix)&#123; return routerMap.get(msisdPrefix); &#125; /** *更新为指定的新实例 **/ public static void setInstance(MMSCRouter newInstance)&#123; instance = newInstance; &#125; /** *防御性复制 **/ private static Map&lt;String,MMSCInfo&gt; deepCopy(Map&lt;String,MMSCInfo&gt; m)&#123; Map&lt;String,MMSCInfo&gt; result = new HashMap&lt;String,MMSCInfo&gt;(); for(String key : m.keySet())&#123; result.put(key, new MMSCInfo(m.get(key))); &#125; return result; &#125; // 防止外部代码修改可变数据routerMap的值 public Map&lt;String,MMSCInfo&gt; getRouterMap()&#123; return Collections.unmodifiableMap(deepCopy(routerMap)); &#125;&#125; 彩信中心信息123456789101112131415161718192021222324252627282930public final class MMSCInfo&#123; private final String deviceId; private final String url; private final int maxAttachmentSizeInBytes; public MMSCInfo(String deviceId, String url, int maxAttachmentSizeInBytes)&#123; this.deviceId = deviceId; this.url = url; this.maxAttachmentSizeInBytes = maxAttachmentSizeInBytes; &#125; public MMSCInfo(MMSCInfo protoType)&#123; this.deviceId = protoType.deviceId; this.url = protoType.url; this.maxAttachmentSizeInBytes = protoType.maxAttachmentSizeInBytes; &#125; public String getDeviceId()&#123; return deviceId; &#125; public String getUrl()&#123; return url; &#125; public int getMaxAttachmentSizeInBytes()&#123; return maxAttachmentSizeInBytes; &#125; &#125; 彩信中心信息变更的频率也同样不高。因此，当彩信网关系统通过网络被通知到这种彩信中心信息本身或者路由变更时，网关系统会重新生成新的MMSInfo和MMSRouter来反应变更。 彩信中心、路由表的变更123456789101112131415161718public class OMCAgent extends Thread&#123; @Override public void run()&#123; boolean isTableModificationMsg = false; String updatedTableName = null; while(true)&#123; // 省略代码 从与OMC 连接中读取信息进行解析 // 解析到数据表更新信息后，重置MMSCRouter实例 if(isTableModificationMsg)&#123; if("MMSCInfo".equals(updatedTableName))&#123; // new MMSCRouter() 从数据库中加载变更的信息存入 MMSCRouter.setInstance(new MMSCRouter()); &#125; &#125; // 省略其他代码 &#125; &#125;&#125; 本列中MMSCInfo 是一个严格意义上的不可变对象，虽然MMSCRouter对象对外提供了setInstance方法用于改变静态字段instance的值，但它仍然可被视作一个等效的不可变对象。因为setInstance仅仅改变instance变量指向的对象，而instance变量采用volatile修饰保证了其余线程的可见性，所以无需加锁其他线程也能获取到最新的instance 总结Immutable Object 模型使用场景 被建模对象的状态变化不频繁 同时对一组相关的数据进行写操作，因此需要保证原子性 使用某个对象作为安全的HashMap的可以key。由于final不可变对象不变所有hashcode不变，所以适合作为HashMap 的key。 ###参考文献java多线程编程实战指南（设计模式篇）黄文海/著]]></content>
      <categories>
        <category>current</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>immutable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elasticsearch6 query 全文查询与词项查询]]></title>
    <url>%2F2018%2F11%2F13%2Felasticsearch6-query-%E5%85%A8%E6%96%87%E6%9F%A5%E8%AF%A2%E4%B8%8E%E8%AF%8D%E9%A1%B9%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[query全文查询 QueryBuilders.matchQuery(“filed”,”value”).operator(Operator.AND); // 对查询的语句进行分词，分词后的词任意一个匹配doc都能查出来 term query 查询的是词项&lt;分词后的&gt; （eg：Java编程思想） Java编程 term query 不能查到 分词后变成（Java 编程 思想） matchQuery能查到 QueryBuilders.matchPhraseQuery(“field”,”value”);对value进行分词，可以自定义分词器,满足两个条件才能被搜到： 分词后的所有词项都要匹配原字段 顺序还需要一致 QueryBuilders.matchPhrasePrefixQuery(“field”,”value”);与matchPhraseQuery类似,最后一个term支持前缀匹配eg.matchPhraseQuery 查 “hello word” matchPhrasePrefixQuery只需要查 “hello w”即可 QueryBuilders.multiMatchQuery(“value”,”field1”,”field2”); 多字段支持查询，字段可以使用通配符eg,{&quot;中国&quot;,&quot;tit*&quot;,&quot;wor?&quot;} QueryBuilders.commonTermsQuery(“哇”,”hehe”);通用查询，会自动分词为低频和高频项，先查低频，可以控制低频、高频出现概率 eg.the word the就是高频 ，可以先查 word QueryBuilders.queryStringQuery(“”);支持lucene查询语法 QueryBuilders.simpleQueryStringQuery(“”);支持lucene查询语法，具有非常完善的语法查询，解析过程中出现异常不会抛错 QueryBuilders.matchAllQuery();查所有和不写同样效果 词项查询 term query 词项检索 terms query 词项检索，可以多个词项，查到一个都能匹配结果 range query 查询范围内的 gt 大于 gte 大于等于 lt 小于 lte 小于等于 exist query 查询会返回字段中至少有一个非空空字符串也返回的doc prefix query 查询字段中给定前缀的文档 eg.{&quot;title&quot;:&quot;hel&quot;} wildcard query 查询字段通配符eg.&quot;{&quot;title&quot;:&quot;hell?/ *ell*&quot;} regexp query 正则匹配查询eg.{&quot;title&quot;:&quot;W[0-9].+&quot;} fuzzy query 模糊查询，最接近的查询，单词拼错一个字母的时候，消耗资源多 type query 指定类型的文档 ids query 查询具有指定id的文档]]></content>
      <categories>
        <category>elasticsearch6</category>
      </categories>
      <tags>
        <tag>elasticsearch6</tag>
        <tag>query</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new " My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1-Two Sum]]></title>
    <url>%2F2018%2F11%2F11%2Fleetcode-1-Two-Sum%2F</url>
    <content type="text"><![CDATA[description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. common method 1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] ret = new int[2]; for(int i =0; i&lt;nums.length-1 ;i++)&#123; for (int j = i+1 ;j &lt; nums.length ;j++ )&#123; if (nums[i] + nums[j] == target)&#123; ret = new int[]&#123;i, j&#125;; return ret; &#125; &#125; &#125; return ret ; &#125;&#125; best method1234567891011121314151617class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int len=nums.length; HashMap&lt;Integer, Integer&gt; map=new HashMap&lt;&gt;(); map.put(nums[0], 0); for(int i=1;i&lt;len;i++)&#123; if(map.containsKey(target-nums[i]))&#123; int[] returnArray=&#123;map.get(target-nums[i]),i&#125;; return returnArray; &#125; else&#123; map.put(nums[i], i); &#125; &#125; int[] returnArray=&#123;0,0&#125;; return returnArray; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arithmetic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello blog]]></title>
    <url>%2F2018%2F11%2F11%2FHello-blog%2F</url>
    <content type="text"><![CDATA[this is a first blog.It&#39;s a very exciting time make a plan execute have a harvest come on 12345public void start()&#123; while(true)&#123; System.out.println("struggle！"); &#125;&#125;]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>think</tag>
      </tags>
  </entry>
</search>
