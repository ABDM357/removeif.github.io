<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode-2-Add Two Numbers]]></title>
    <url>%2Fleetcode-2-Add-Two-Numbers.html</url>
    <content type="text"><![CDATA[Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. ##common 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); // 一点要赋值一个节点，进行操作 ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next; &#125;&#125; best123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */ class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); int carry = 0; while(l1!=null||l2!=null||carry&gt;0) &#123; ListNode itr = head; while(itr.next!=null) itr = itr.next; // 寻找最后一个节点 int sum = ( (l1==null ? 0 : l1.val) + (l2==null ? 0 : l2.val) + carry); carry = sum/10; ListNode temp = new ListNode(sum%10); itr.next = temp; if(l1!=null) l1 = l1.next; if(l2!=null) l2 = l2.next; &#125; return head.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>problems,java,leetcode,Add Two Numbers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之观察者模式]]></title>
    <url>%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[定义 在阎宏博士的《JAVA与模式》一书中开头是这样描述观察者（Observer）模式的：观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 推结构模式推模式相关结构说明一个软件系统里面包含了各种对象，就像一片欣欣向荣的森林充满了各种生物一样。在一片森林中，各种生物彼此依赖和约束，形成一个个生物链。一种生物的状态变化会造成其他一些生物的相应行动，每一个生物都处于别的生物的互动之中。 同样，一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易于复用，应该选择低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，保证高度的协作。观察者模式是满足这一要求的各种设计方案中最重要的一种。 下面以一个简单的示意性实现为例，讨论观察者模式的结构。 观察者模式所涉及的角色有： ● 抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。 ● 具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。 ● 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。 ● 具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。 主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。 抽象观察者角色1234public interface Observer &#123; void update(String state); String getName();&#125; 具体观察者1234567891011121314151617181920212223242526public class ConcreteObserver implements Observer &#123; private String name; private String state; public ConcreteObserver(String name) &#123; this.name = name; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; @Override public void update(String state) &#123; // 更新观察 着状态 this.state = state; System.out.println(getName() + "观察者状态更新为：" + state); &#125; @Override public String getName() &#123; return name; &#125;&#125; 抽象主题角色1234567891011121314151617181920212223242526272829303132public abstract class Subject &#123; /** * 保存观察者的容器 */ private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); /** * 注册观察者 */ public void register(Observer o) &#123; list.add(o); System.out.println("增加了一个观察者:" + o.getName()); &#125; /** * 移除观察者 * * @param o */ public void remove(Observer o) &#123; System.out.println("移除了一个观察者:" + o.getName()); list.remove(o); &#125; /** * 通知观察者 * * @param newState */ public void nodifyObservers(String newState) &#123; for (Observer observer : list) &#123; observer.update(newState); &#125; &#125;&#125; 具体主题角色12345678910111213141516public class ConcreteSubject extends Subject &#123; /** * 状态 */ private String state; public String getState() &#123; return state; &#125; public void change(String newState) &#123; state = newState; System.out.println("状态变为：" + newState); System.out.println("开始通知观察者..."); this.nodifyObservers(state); &#125;&#125; 测试类12345678910111213public class MainTest &#123; public static void main(String[] args) &#123; Observer o1 = new ConcreteObserver("o1"); Observer o2 = new ConcreteObserver("o2"); Observer o3 = new ConcreteObserver("o3"); ConcreteSubject csj = new ConcreteSubject(); csj.register(o1); csj.register(o2); csj.register(o3); csj.remove(o2); csj.change("new State！"); &#125;&#125; 输出结果 在运行时，这个客户端首先创建了具体主题类的实例，以及一个观察者对象。然后，它调用主题对象的register()方法，将这个观察者对象向主题对象登记，也就是将它加入到主题对象的聚集中去。 这时，客户端调用主题的change()方法，改变了主题对象的内部状态。主题对象在状态发生变化时，调用超类的notifyObservers()方法，通知所有登记过的观察者对象 拉模式结构说明 主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。 抽象观察者角色12345678public interface Observer &#123; /** * 传入主题，获取中的对象 * @param subject */ void update(Subject subject); String getName();&#125; 具体观察者123456789101112131415161718192021222324252627public class ConcreteObserver implements Observer &#123; private String name; private String state; public ConcreteObserver(String name) &#123; this.name = name; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; @Override public String getName() &#123; return name; &#125; @Override public void update(Subject subject) &#123; // 主动去主题里拿数据 state = ((ConcreteSubject) subject).getState(); System.out.println(getName() + "观察者状态更新为：" + state); &#125;&#125; 抽象主题角色1234567891011121314151617181920212223242526272829303132333435public abstract class Subject &#123; /** * 保存观察者的容器 */ private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); /** * 注册观察者 */ public void register(Observer o) &#123; list.add(o); System.out.println("增加了一个观察者:" + o.getName()); &#125; /** * 移除观察者 * * @param o */ public void remove(Observer o) &#123; System.out.println("移除了一个观察者:" + o.getName()); list.remove(o); &#125; /** * 通知观察者 * * @param newState */ public void nodifyObservers() &#123; for (Observer observer : list) &#123; observer.update(this); &#125; &#125;&#125; 具体主题角色123456789101112131415161718public class ConcreteSubject extends Subject &#123; /** * 状态 */ private String state; public String getState() &#123; return state; &#125; public void change(String newState) &#123; state = newState; System.out.println("状态变为：" + newState); System.out.println("开始通知观察者..."); this.nodifyObservers(); &#125;&#125; 测试12345678910111213public class MainTest &#123; public static void main(String[] args) &#123; Observer o1 = new ConcreteObserver("o1"); Observer o2 = new ConcreteObserver("o2"); Observer o3 = new ConcreteObserver("o3"); ConcreteSubject csj = new ConcreteSubject(); csj.register(o1); csj.register(o2); csj.register(o3); csj.remove(o2); csj.change("new State！"); &#125;&#125; 测试结果 两种模式的比较 推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。 推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。 参考链接]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者</tag>
        <tag>推模式</tag>
        <tag>拉模式</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Immutable Object(不可变对象)模式]]></title>
    <url>%2FImmutable-Object-%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1-%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[多线程下，一个对象会被多个线程共享，存在多线程并发地修改对象的属性，需要做些同步访问控制，如显示锁，CAS操作，会带来额外的开销和问题，如上下文切换、等待时间、ABA问题。Immutable Object模式意图通过使用对外可见的状态不可变的对象，使得天生具有线程安全性。 车辆管理系统状态可变的位置信息模型123456789101112131415161718192021public class Location &#123; private double x; private double y; public Location(double x, double y) &#123; this.x = x; this.y = y; &#125; public double getX() &#123; return x; &#125; public double getY() &#123; return y; &#125; public void setXY(double x, double y) &#123; this.x = x; this.y = y; &#125;&#125; 管理系统中会调用Location的setXY方法来更新位置，因为是非线程安全，并非原子操作，导致调用时会出现数据不一致的情况 改进：状态不可变的位置信息模型123456789public final class Location&#123; public final double x; public final double y; public Location(double x,double y)&#123; this.x = x; this.y = y; &#125;&#125; 使用状态不可变的对象时，更新信息模型时，如果车辆的位置发生变动，更新的是整个位置信息的对象 更新不可变对象的位置信息123456public class VehicleTracker&#123; private Map&lt;String,Location&gt; locMap = new ConcurrentHashMap&lt;String, Location&gt;(); public void updateLocation(String vehicleId,Location newLocation)&#123; locMap.put(vehicleId,newLocation); &#125; &#125; 一个严格意义上的不可变对象应该满足以下所有条件 类本身用final修饰 所有字段都是用final修饰，这个语意在多线程环境下由JVM保证了被修饰字段所引用对象的初始化安全，即final修饰的字段在其他线程是可见的，必定是初始化完成的。 在对象的创建过程中，this关键字没有泄露给其他类，防止其他类在对象创建过程中修改其状态 任何字段如果引用其他状态可变的对象，如集合数组，这些字段必须是private修饰的，不能暴露给外部，所有相关方法要返回这些字段值，应该防止防御性复制 实例： 某彩信网关系统 在处理由增值业务提供商VASP下发给手机终端用户的彩信信息时，需要根据彩信接收方号码的前缀选择对应的彩信中心MMSC，然后转发消息给选中的彩信中心。由其他系统将彩信信息下发给手机终端用户。选择彩信中心的过程称为 路由 ，手机前缀和彩信中心对应的关系叫路由表，在系统中多线程共享，很少改变此数据，不希望访问这些数据时进行加锁并发访问控制，避免产生不必要的开销，所以选择immutable object模型。 彩信中心路由规则管理器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/***彩信中心路由规则管理器**/public final class MMSCRouter&#123; // 保证多线程环境下该变量的可见性 private static volatile MMSCRouter instance = new MMSCRouter(); // 维护手机号码前缀到彩信中心之间的映射关系 private final Map&lt;String,MMSCInfo&gt; routerMap; public MMSCRouter()&#123; // 将数据库表中的数据加载到内存，存为Map this.routerMap = MMSCRouter.retrieveRouterMapFromDB(); &#125; private static Map&lt;String,MMSCInfo&gt; retrieveRouterMapFromDB()&#123; Map&lt;String,MMSCInfo&gt; map = new HashMap&lt;&gt;(); // 省略其余代码 return map; &#125; public static MMSCRouter getInstance()&#123; return instance; &#125; /** *根据手机号前缀获取彩信中心信息 **/ public MMSCInfo getMMSC(String msisdPrefix)&#123; return routerMap.get(msisdPrefix); &#125; /** *更新为指定的新实例 **/ public static void setInstance(MMSCRouter newInstance)&#123; instance = newInstance; &#125; /** *防御性复制 **/ private static Map&lt;String,MMSCInfo&gt; deepCopy(Map&lt;String,MMSCInfo&gt; m)&#123; Map&lt;String,MMSCInfo&gt; result = new HashMap&lt;String,MMSCInfo&gt;(); for(String key : m.keySet())&#123; result.put(key, new MMSCInfo(m.get(key))); &#125; return result; &#125; // 防止外部代码修改可变数据routerMap的值 public Map&lt;String,MMSCInfo&gt; getRouterMap()&#123; return Collections.unmodifiableMap(deepCopy(routerMap)); &#125;&#125; 彩信中心信息123456789101112131415161718192021222324252627282930public final class MMSCInfo&#123; private final String deviceId; private final String url; private final int maxAttachmentSizeInBytes; public MMSCInfo(String deviceId, String url, int maxAttachmentSizeInBytes)&#123; this.deviceId = deviceId; this.url = url; this.maxAttachmentSizeInBytes = maxAttachmentSizeInBytes; &#125; public MMSCInfo(MMSCInfo protoType)&#123; this.deviceId = protoType.deviceId; this.url = protoType.url; this.maxAttachmentSizeInBytes = protoType.maxAttachmentSizeInBytes; &#125; public String getDeviceId()&#123; return deviceId; &#125; public String getUrl()&#123; return url; &#125; public int getMaxAttachmentSizeInBytes()&#123; return maxAttachmentSizeInBytes; &#125; &#125; 彩信中心信息变更的频率也同样不高。因此，当彩信网关系统通过网络被通知到这种彩信中心信息本身或者路由变更时，网关系统会重新生成新的MMSInfo和MMSRouter来反应变更。 彩信中心、路由表的变更123456789101112131415161718public class OMCAgent extends Thread&#123; @Override public void run()&#123; boolean isTableModificationMsg = false; String updatedTableName = null; while(true)&#123; // 省略代码 从与OMC 连接中读取信息进行解析 // 解析到数据表更新信息后，重置MMSCRouter实例 if(isTableModificationMsg)&#123; if("MMSCInfo".equals(updatedTableName))&#123; // new MMSCRouter() 从数据库中加载变更的信息存入 MMSCRouter.setInstance(new MMSCRouter()); &#125; &#125; // 省略其他代码 &#125; &#125;&#125; 本列中MMSCInfo 是一个严格意义上的不可变对象，虽然MMSCRouter对象对外提供了setInstance方法用于改变静态字段instance的值，但它仍然可被视作一个等效的不可变对象。因为setInstance仅仅改变instance变量指向的对象，而instance变量采用volatile修饰保证了其余线程的可见性，所以无需加锁其他线程也能获取到最新的instance 总结Immutable Object 模型使用场景 被建模对象的状态变化不频繁 同时对一组相关的数据进行写操作，因此需要保证原子性 使用某个对象作为安全的HashMap的可以key。由于final不可变对象不变所有hashcode不变，所以适合作为HashMap 的key。 参考文献java多线程编程实战指南（设计模式篇）黄文海/著]]></content>
      <categories>
        <category>current</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>immutable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elasticsearch6 query 全文查询与词项查询]]></title>
    <url>%2Felasticsearch6-query-%E5%85%A8%E6%96%87%E6%9F%A5%E8%AF%A2%E4%B8%8E%E8%AF%8D%E9%A1%B9%E6%9F%A5%E8%AF%A2.html</url>
    <content type="text"><![CDATA[query全文查询 QueryBuilders.matchQuery(“filed”,”value”).operator(Operator.AND); // 对查询的语句进行分词，分词后的词任意一个匹配doc都能查出来 term query 查询的是词项&lt;分词后的&gt; （eg：Java编程思想） Java编程 term query 不能查到 分词后变成（Java 编程 思想） matchQuery能查到 QueryBuilders.matchPhraseQuery(“field”,”value”);对value进行分词，可以自定义分词器,满足两个条件才能被搜到： 分词后的所有词项都要匹配原字段 顺序还需要一致 QueryBuilders.matchPhrasePrefixQuery(“field”,”value”);与matchPhraseQuery类似,最后一个term支持前缀匹配eg.matchPhraseQuery 查 “hello word” matchPhrasePrefixQuery只需要查 “hello w”即可 QueryBuilders.multiMatchQuery(“value”,”field1”,”field2”); 多字段支持查询，字段可以使用通配符eg,{&quot;中国&quot;,&quot;tit*&quot;,&quot;wor?&quot;} QueryBuilders.commonTermsQuery(“哇”,”hehe”);通用查询，会自动分词为低频和高频项，先查低频，可以控制低频、高频出现概率 eg.the word the就是高频 ，可以先查 word QueryBuilders.queryStringQuery(“”);支持lucene查询语法 QueryBuilders.simpleQueryStringQuery(“”);支持lucene查询语法，具有非常完善的语法查询，解析过程中出现异常不会抛错 QueryBuilders.matchAllQuery();查所有和不写同样效果 词项查询 term query 词项检索 terms query 词项检索，可以多个词项，查到一个都能匹配结果 range query 查询范围内的 gt 大于 gte 大于等于 lt 小于 lte 小于等于 exist query 查询会返回字段中至少有一个非空空字符串也返回的doc prefix query 查询字段中给定前缀的文档 eg.{&quot;title&quot;:&quot;hel&quot;} wildcard query 查询字段通配符eg.&quot;{&quot;title&quot;:&quot;hell?/ *ell*&quot;} regexp query 正则匹配查询eg.{&quot;title&quot;:&quot;W[0-9].+&quot;} fuzzy query 模糊查询，最接近的查询，单词拼错一个字母的时候，消耗资源多 type query 指定类型的文档 ids query 查询具有指定id的文档]]></content>
      <categories>
        <category>elasticsearch6</category>
      </categories>
      <tags>
        <tag>elasticsearch6</tag>
        <tag>query</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new " My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1-Two Sum]]></title>
    <url>%2Fleetcode-1-Two-Sum.html</url>
    <content type="text"><![CDATA[description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. common method 1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] ret = new int[2]; for(int i =0; i&lt;nums.length-1 ;i++)&#123; for (int j = i+1 ;j &lt; nums.length ;j++ )&#123; if (nums[i] + nums[j] == target)&#123; ret = new int[]&#123;i, j&#125;; return ret; &#125; &#125; &#125; return ret ; &#125;&#125; best method1234567891011121314151617class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int len=nums.length; HashMap&lt;Integer, Integer&gt; map=new HashMap&lt;&gt;(); map.put(nums[0], 0); for(int i=1;i&lt;len;i++)&#123; if(map.containsKey(target-nums[i]))&#123; int[] returnArray=&#123;map.get(target-nums[i]),i&#125;; return returnArray; &#125; else&#123; map.put(nums[i], i); &#125; &#125; int[] returnArray=&#123;0,0&#125;; return returnArray; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arithmetic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello blog]]></title>
    <url>%2FHello-blog.html</url>
    <content type="text"><![CDATA[this is a first blog.It&#39;s a very exciting time make a plan execute have a harvest come on 12345public void start()&#123; while(true)&#123; System.out.println("struggle！"); &#125;&#125;]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>think</tag>
      </tags>
  </entry>
</search>
