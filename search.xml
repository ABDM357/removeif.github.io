<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java设计模式之工厂模式]]></title>
    <url>%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[工厂模式序言工厂模式在《Java与模式》中分为三类： 简单工厂模式（Simple Factory）：不利于产生系列产品； 工厂方法模式（Factory Method）：又称为多形性工厂； 抽象工厂模式（Abstract Factory）：又称为工具箱，产生产品族，但不利于产生新的产品； 这三种模式从上到下逐步抽象，并且更具一般性。GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。 简单工厂模式 简单工厂模式又称静态工厂方法模式。从命名上就可以看出这个模式一定很简单。它存在的目的很简单：定义一个用于创建对象的接口。在简单工厂模式中,一个工厂类处于对产品类实例化调用的中心位置上,它决定那一个产品类应当被实例化, 如同一个交通警察站在来往的车辆流中,决定放行那一个方向的车辆向那一个方向流动一样。 组成角色： 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。 简单工厂模式的UML图 简单工厂模式的Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 抽象接口 人类public interface Human &#123; public void say();&#125;// 男人public class Man implements Human &#123; @Override public void say() &#123; System.out.println("男人"); &#125;&#125;// 女人public class Woman implements Human &#123; @Override public void say() &#123; System.out.println("女人"); &#125;&#125;// 简单工厂public class SampleFactory &#123; public static Human makeHuman(String type)&#123; if(type.equals("man"))&#123; Human man = new Man(); return man; &#125;else if(type.equals("womman"))&#123; Human woman = new Woman(); return woman; &#125;else&#123; System.out.println("生产不出来"); return null; &#125; &#125;&#125;// 简单工厂模式反射实现public class SampleFactory1 &#123; public static Human makeHuman(Class c)&#123; Human human = null; try &#123; human = (Human) Class.forName(c.getName()).newInstance(); &#125; catch (InstantiationException e) &#123; // TODO Auto-generated catch block System.out.println("不支持抽象类或接口"); e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println("没有足够权限，即不能访问私有对象"); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block System.out.println("类不存在"); e.printStackTrace(); &#125; return human; &#125;&#125;// 简单工厂测试public class Client &#123; public static void main(String[] args) &#123; Human man = SampleFactory.makeHuman("man"); man.say(); Human womman = SampleFactory.makeHuman("womman"); womman.say(); Human test = SampleFactory.makeHuman("tttt"); Human man = SampleFactory1.makeHuman(Man.class); man.say(); Human woman = SampleFactory1.makeHuman(Woman.class); woman.say(); &#125;&#125; 优缺点： 优点：工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利，有利于整个软件体系结构的优化。 ​ 缺点：由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利； 工厂方法模式 工厂方法模式是简单工厂模式的进一步抽象化和推广，工厂方法模式里不再只由一个工厂类决定那一个产品类应当被实例化,这个决定被交给抽象工厂的子类去做。 组成角色： 抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的“上帝类”。正如上面所说，这样便分担了对象承受的压力；而且这样使得结构变得灵活 起来——当有新的产品（即暴发户的汽车）产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有的代 码。可以看出工厂角色的结构也是符合开闭原则的！ 工厂方法模式Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344//抽象产品角色public interface Moveable &#123; void run();&#125;//具体产品角色public class Plane implements Moveable &#123; @Override public void run() &#123; System.out.println("plane...."); &#125;&#125;public class Broom implements Moveable &#123; @Override public void run() &#123; System.out.println("broom....."); &#125;&#125;//抽象工厂public abstract class VehicleFactory &#123; abstract Moveable create();&#125;//具体工厂public class PlaneFactory extends VehicleFactory&#123; public Moveable create() &#123; return new Plane(); &#125;&#125;public class BroomFactory extends VehicleFactory&#123; public Moveable create() &#123; return new Broom(); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; VehicleFactory factory = new BroomFactory(); Moveable m = factory.create(); m.run(); &#125;&#125; 可以看出工厂方法的加入，使得对象的数量成倍增长。当产品种类非常多时，会出现大量的与之对应的工厂对象，这不是我们所希望的。因为如果不能避免这种情 况，可以考虑使用简单工厂模式与工厂方法模式相结合的方式来减少工厂类：即对于产品树上类似的种类（一般是树的叶子中互为兄弟的）使用简单工厂模式来实 现。 简单工厂和工厂方法模式的比较 工厂方法模式和简单工厂模式在定义上的不同是很明显的。工厂方法模式的核心是一个抽象工厂类,而不像简单工厂模式, 把核心放在一个实类上。工厂方法模式可以允许很多实的工厂类从抽象工厂类继承下来, 从而可以在实际上成为多个简单工厂模式的综合,从而推广了简单工厂模式。 反过来讲,简单工厂模式是由工厂方法模式退化而来。设想如果我们非常确定一个系统只需要一个实的工厂类, 那么就不妨把抽象工厂类合并到实的工厂类中去。而这样一来,我们就退化到简单工厂模式了。 抽象工厂模式1234567891011121314151617181920212223242526272829303132333435//抽象工厂类public abstract class AbstractFactory &#123; public abstract Vehicle createVehicle(); public abstract Weapon createWeapon(); public abstract Food createFood();&#125;//具体工厂类，其中Food,Vehicle，Weapon是抽象类，public class DefaultFactory extends AbstractFactory&#123; @Override public Food createFood() &#123; return new Apple(); &#125; @Override public Vehicle createVehicle() &#123; return new Car(); &#125; @Override public Weapon createWeapon() &#123; return new AK47(); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; AbstractFactory f = new DefaultFactory(); Vehicle v = f.createVehicle(); v.run(); Weapon w = f.createWeapon(); w.shoot(); Food a = f.createFood(); a.printName(); &#125;&#125; 在抽象工厂模式中，抽象产品 (AbstractProduct) 可能是一个或多个，从而构成一个或多个产品族(Product Family)。 在只有一个产品族的情况下，抽象工厂模式实际上退化到工厂方法模式。 总结 简单工厂模式是由一个具体的类去创建其他类的实例，父类是相同的，父类是具体的。 工厂方法模式是有一个抽象的父类定义公共接口，子类负责生成具体的对象，这样做的目的是将类的实例化操作延迟到子类中完成。 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。它针对的是有多个产品的等级结构。而工厂方法模式针对的是一个产品的等级结构。 参考：http://www.cnblogs.com/liaoweipeng/p/5768197.html http://www.cnblogs.com/forlina/archive/2011/06/21/2086114.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
        <tag>简单工作模式</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective-Java-2-遇到多个构造器参数时考虑用构建器]]></title>
    <url>%2FEffective-Java-2-%E9%81%87%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E6%97%B6%E8%80%83%E8%99%91%E7%94%A8%E6%9E%84%E5%BB%BA%E5%99%A8.html</url>
    <content type="text"><![CDATA[遇到多个构造器参数时考虑用构建器静态工厂和构造器有个共同的局限性：它们都不能很好地扩展到大量的可选参数。当有超过20个可选域是必须的时候，对于此种情况，程序员一般考虑采用重叠构造器模式。这种模式下，提供第一个只有必要参数的构造器，第二个构造器有一个可选参数，第三个有两个可选参数，以此类推，最后一个构造器包含所有的参数。 重叠构造器模式 含有四个可选域的情况 1234567891011121314151617181920212223242526272829public class NutritionFacts&#123; private final int servingSize; // required private final int servings; // required private final int calories; // optional private final int fat; // optional private final int sodium; // optional private final int carbohydrate; // optional public NutritionFacts(int servingSize, int servings)&#123; this(servingSize, servings, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories)&#123; this(servingSize, servings, calories, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat)&#123; this(servingSize, servings, calories, fat, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium)&#123; this(servingSize, servings, calories, fat, sodium, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate)&#123; this(servingSize, servings, calories, fat, sodium, carbohydrate); &#125; &#125; 当你想创建实例的时候，就利用参数列表最短的构造器。 重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难编写，并且较难阅读，使用的时候容易混淆部分参数容易出错 JavaBeans模式这种模式调用一个无参构造器来创建对象，然后用setter方法来设置必要的参数以及相关参数的值。 12345678910111213141516171819public class NutritionFacts &#123; private int servingSize = -1; // required private int servings = -1; // required private int calories = 0; // optional private int fat = 0; // optional private int sodium = 0; // optional private int carbohydrate = 0; // optional public NutritionFacts()&#123; &#125; public void setServingSize(int val) &#123; servingSize = val; &#125; public void setServings(int val) &#123; servings = val; &#125; public void setCalories(int val) &#123; calories = val; &#125; public void setFat(int val) &#123; fat = val; &#125; public void setSodium(int val) &#123; sodium = val; &#125; public void setCarbohydrate(int val) &#123; carbohydrate = val; &#125;&#125; 这种方式弥补了重叠构造器模式的不足，创建实例容易，阅读代码也容易。 12345NutritionFacts cocaCola = new NutritionFacts();cocaCola.setServingSize(10);cocaCola.setServings(10);cocaCola.setCalories(10);cocaCola.setFat(10); 遗憾的是自身有严重的缺陷。构造过程被分到了几个调用中，构造过程中JavaBean可能处于不一致状态的对象，将会导致失败。类无法仅仅通难过校验构造器参数的有效性来保证一致性，Javabeans模式阻止了把类做成不可变的可能，需要付出额外的努力来确保它的线程安全。 Builder模式既能保证像重叠构造器模式那样的安全性，也能保证像JavaBeans模式那样的可读性。 不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器（或静态工厂），得到一个builder对象。然后客户端在builder对象上调用类似于setter的方法，来设置每个相关的可选参数。最后，客户端调用无参的build方法来生成不可变的对象，这个builder是它构建的类的静态成员类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class NutritionFacts&#123; private final int servingSize; // required private final int servings; // required private final int calories; // optional private final int fat; // optional private final int sodium; // optional private final int carbohydrate; // optional public static class Builder&#123; private final int servingSize; // required private final int servings; // required private final int calories = 0; // optional private final int fat = 0; // optional private final int sodium = 0; // optional private final int carbohydrate = 0; // optional public Builder(int servingSize, int servings)&#123; this.servingSize = servingSize; this.servings =servings; &#125; public Builder calories(int val)&#123; calories = val; return this; &#125; public Builder fat(int val)&#123; fat = val; return this; &#125; public Builder sodium(int val)&#123; sodium = val; return this; &#125; public Builder carbohydrate(int val)&#123; carbohydrate = val; return this; &#125; public NutritionFacts build()&#123; return new NutritionFacts(this); &#125; &#125; private NutritionFacts(Builder builder)&#123; servingSize = builder.servingSize; servings = builder.servingSize; calories = builder.servingSize; fat = builder.servingSize; sodium = builder.servingSize; carbohydrate = builder.servingSize; &#125;&#125; 注意NutritionFacts是不可变的，所有的默认参数值都单独放一个地方。builder的setter方法返回builder本身，以便可以把调用用调用链连接起来。 1NutritionFacts cocaCola = new NutritionFacts.Builder(200,20).calories(10).fat(15).sodium(10).build(); builder像个构造器一样，可以对其参数强加约束条件。build方法可以检验这些约束条件，将参数从builder拷贝到对象中之后，并在对象域而不是builder域中对他们进行校验，这一点很重要。如果违反了任何约束条件，build方法就应该抛出IllegalStateException,显示违背了哪个约束条件。 对多个参数强加约束条件的另一个方法，用多个setter方法对某个约束条件必须持有的所有参数进行检查。如果该约束条件没有得到满足，setter方法就抛出IllegalStateException，不用等到在build的时候。 设置了参数的builder生成了一个很好的抽象工厂，客户端可以将这样一个builder传给方法，使该方法能够为客户端创建一个或者多个对象。要使用这种用法，需要有个类型来表示builder，只要一个泛型就能满足所有的builder，无论他们在构建哪种类型的对象： 123public interface Builder&lt;T&gt;&#123; public T build();&#125; 可以声明NutritionFacts.Builder类来实现Builder&lt;NutritionFacts&gt; 。 带有Builder实例的方法通常利用有限制的通配符类型来约束构建器的类型参数。eg.下面就是构建每个节点的方法，它利用一个客户端提供的Builder实例来构建树： 1Tree buildTree(Builder&lt;? extends Node&gt; nodeBuilder)&#123; ... &#125; **Builder模式还比重叠构造器模式更加冗长，因此它只有在很难参数的时候才使用，比如4个或者更多。但是你要记住，将来可能添加参数。简而言之，如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是种不错的选择，特别是大多参数都是可选的时候。代码易于阅读编写，构建器也比JavaBeans更加安全。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>Effective-Java</category>
      </categories>
      <tags>
        <tag>Effective-Java</tag>
        <tag>构建起</tag>
        <tag>builder模式</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之单例模式]]></title>
    <url>%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[单例模式 确保一个类只有一个实例，并提供一个全局访问点！ 饿汉式：线程安全，但效率比较低123456789101112131415161718/** * 单例模式的实现：饿汉式,线程安全 但效率比较低 */ public class SingletonTest &#123; // 定义一个私有的构造方法 private SingletonTest() &#123; &#125; // 将自身的实例对象设置为一个属性,并加上Static和final修饰符 private static final SingletonTest instance = new SingletonTest(); // 静态方法返回该类的实例 public static SingletonTest getInstancei() &#123; return instance; &#125; &#125; 单例模式的实现：饱汉式，非线程安全12345678910111213141516171819/** * 单例模式的实现：饱汉式,非线程安全 * */ public class SingletonTest &#123; // 定义私有构造方法（防止通过 new SingletonTest()去实例化） private SingletonTest() &#123; &#125; // 定义一个SingletonTest类型的变量（不初始化，注意这里没有使用final关键字） private static SingletonTest instance; // 定义一个静态的方法（调用时再初始化SingletonTest，但是多线程访问时，可能造成重复初始化问题） public static SingletonTest getInstance() &#123; if (instance == null) instance = new SingletonTest(); return instance; &#125; &#125; 饱汉式，线程安全简单实现1234567891011121314151617181920/** * 单例模式的实现：饱汉式,线程安全简单实现 * */ public class SingletonTest &#123; // 定义私有构造方法（防止通过 new SingletonTest()去实例化） private SingletonTest() &#123; &#125; // 定义一个SingletonTest类型的变量（不初始化，注意这里没有使用final关键字） private static SingletonTest instance; // 定义一个静态的方法（调用时再初始化SingletonTest，使用synchronized 避免多线程访问时，可能造成重的复初始化问题） public static synchronized SingletonTest getInstance() &#123; if (instance == null) instance = new SingletonTest(); return instance; &#125; &#125; 双重锁机制：线程安全，效率高，单例模式最优方案12345678910111213141516171819202122232425262728/** * 单例模式最优方案 * 线程安全 并且效率高 * */ public class SingletonTest &#123; // 定义一个私有构造方法 private SingletonTest() &#123; &#125; //定义一个静态私有变量(不初始化，不使用final关键字，使用volatile保证了多线程访问时instance变量的可见性，避免了instance初始化时其他变量属性还没赋值完时，被另外线程调用) private static volatile SingletonTest instance; //定义一个共有的静态方法，返回该类型实例 public static SingletonTest getIstance() &#123; // 对象实例化时与否判断（不使用同步代码块，instance不等于null时，直接返回对象，提高运行效率） if (instance == null) &#123; //同步代码块（对象未初始化时，使用同步代码块，保证多线程访问时对象在第一次创建后，不再重复被创建） synchronized (SingletonTest.class) &#123; //未初始化，则初始instance变量 if (instance == null) &#123; instance = new SingletonTest(); &#125; &#125; &#125; return instance; &#125; &#125; 静态内部类方式12345678910111213/** * 静态内部类方式 * */ public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟第三种和第四种方式不同的是（很细微的差别）：第三种和第四种方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比第三和第四种方式就显得很合理。 总结【以上单例模式】传统的两私有一公开（私有构造方法、私有静态实例(懒实例化/直接实例化)、公开的静态获取方法）涉及线程安全问题（即使有多重检查锁也可以通过反射破坏单例）目前最为安全的实现单例的方法是通过内部静态enum的方法来实现，因为JVM会保证enum不能被反射并且构造器方法只执行一次。 利用反射模式获取1234567891011121314151617181920212223242526272829303132333435363738// 饿汉试单例模式public class HelloWorld &#123; private HelloWorld()&#123;&#125;; private static HelloWorld hell = new HelloWorld(); public static HelloWorld getHello()&#123; return hell; &#125; public void getWorld()&#123; System.out.println("hahahahah"); &#125;&#125;// java反射机制 调用getWorld()方法public class HelloJava&#123; public static void main(String[] args)&#123; /* HelloWorld hell = HelloWorld.getHello(); hell.getWorld(); */ try &#123; Class class1 = Class.forName("cn.jr.text.HelloWorld"); Constructor[] constructors = class1.getDeclaredConstructors(); AccessibleObject.setAccessible(constructors, true); for (Constructor con : constructors) &#123; if (con.isAccessible()) &#123; Object classObject = con.newInstance(); Method method = class1.getMethod("getWorld"); method.invoke(classObject); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用枚举的单例模式123456789101112131415161718public class EnumSingleton&#123; private EnumSingleton()&#123;&#125; public static EnumSingleton getInstance()&#123; return Singleton.INSTANCE.getInstance(); &#125; private static enum Singleton&#123; INSTANCE; private EnumSingleton singleton; //JVM会保证此方法绝对只调用一次 private Singleton()&#123; singleton = new EnumSingleton(); &#125; public EnumSingleton getInstance()&#123; return singleton; &#125; &#125;&#125; 使用枚举，static处调用，初始化一次1234567891011121314151617181920212223public class StaticInitTest &#123; private static List&lt;Integer&gt; dataList = null; static&#123; dataList = Singleton.INSTANCE.init(); &#125; private static enum Singleton &#123; INSTANCE; private List&lt;Integer&gt; list; private Singleton()&#123; fillData(); &#125; private void fillData()&#123; list = new ArrayList&lt;Integer&gt;(5); for(int i =1; i&lt;6; i++)&#123; list.add(i); &#125; &#125; public List&lt;Integer&gt; init()&#123; return list; &#125; &#125;&#125; 最终总结有两个问题需要注意： 如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类 装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。 如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。 对第一个问题修复的办法是： 123456789private static Class getClass(String classname) throws ClassNotFoundException &#123; ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); if(classLoader == null) classLoader = Singleton.class.getClassLoader(); return (classLoader.loadClass(classname)); &#125; &#125; 对第二个问题修复的办法是： 12345678910public class Singleton implements java.io.Serializable &#123; public static Singleton INSTANCE = new Singleton(); protected Singleton() &#123; &#125; private Object readResolve() &#123; return INSTANCE; &#125; &#125; 对我来说，我比较喜欢第a和e种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第a种方式，只有在要明确实现lazy loading效果时才会使用第e种方式，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1.5已经没有双重检查锁定的问题了。 参考资料：java单例之enum实现方式 设计模式 java设计模式–单例模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
        <tag>饿汉式</tag>
        <tag>饱汉式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-2-Add Two Numbers]]></title>
    <url>%2Fleetcode-2-Add-Two-Numbers.html</url>
    <content type="text"><![CDATA[Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. common 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); // 一点要赋值一个节点，进行操作 ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next; &#125;&#125; best123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */ class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); int carry = 0; while(l1!=null||l2!=null||carry&gt;0) &#123; ListNode itr = head; while(itr.next!=null) itr = itr.next; // 寻找最后一个节点 int sum = ( (l1==null ? 0 : l1.val) + (l2==null ? 0 : l2.val) + carry); carry = sum/10; ListNode temp = new ListNode(sum%10); itr.next = temp; if(l1!=null) l1 = l1.next; if(l2!=null) l2 = l2.next; &#125; return head.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>problems</tag>
        <tag>leetcode</tag>
        <tag>Add Two Numbers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之观察者模式]]></title>
    <url>%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[定义 在阎宏博士的《JAVA与模式》一书中开头是这样描述观察者（Observer）模式的：观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 推结构模式推模式相关结构说明一个软件系统里面包含了各种对象，就像一片欣欣向荣的森林充满了各种生物一样。在一片森林中，各种生物彼此依赖和约束，形成一个个生物链。一种生物的状态变化会造成其他一些生物的相应行动，每一个生物都处于别的生物的互动之中。 同样，一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易于复用，应该选择低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，保证高度的协作。观察者模式是满足这一要求的各种设计方案中最重要的一种。 下面以一个简单的示意性实现为例，讨论观察者模式的结构。 观察者模式所涉及的角色有： ● 抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。 ● 具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。 ● 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。 ● 具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。 主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。 抽象观察者角色1234public interface Observer &#123; void update(String state); String getName();&#125; 具体观察者1234567891011121314151617181920212223242526public class ConcreteObserver implements Observer &#123; private String name; private String state; public ConcreteObserver(String name) &#123; this.name = name; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; @Override public void update(String state) &#123; // 更新观察 着状态 this.state = state; System.out.println(getName() + "观察者状态更新为：" + state); &#125; @Override public String getName() &#123; return name; &#125;&#125; 抽象主题角色1234567891011121314151617181920212223242526272829303132public abstract class Subject &#123; /** * 保存观察者的容器 */ private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); /** * 注册观察者 */ public void register(Observer o) &#123; list.add(o); System.out.println("增加了一个观察者:" + o.getName()); &#125; /** * 移除观察者 * * @param o */ public void remove(Observer o) &#123; System.out.println("移除了一个观察者:" + o.getName()); list.remove(o); &#125; /** * 通知观察者 * * @param newState */ public void nodifyObservers(String newState) &#123; for (Observer observer : list) &#123; observer.update(newState); &#125; &#125;&#125; 具体主题角色12345678910111213141516public class ConcreteSubject extends Subject &#123; /** * 状态 */ private String state; public String getState() &#123; return state; &#125; public void change(String newState) &#123; state = newState; System.out.println("状态变为：" + newState); System.out.println("开始通知观察者..."); this.nodifyObservers(state); &#125;&#125; 测试类12345678910111213public class MainTest &#123; public static void main(String[] args) &#123; Observer o1 = new ConcreteObserver("o1"); Observer o2 = new ConcreteObserver("o2"); Observer o3 = new ConcreteObserver("o3"); ConcreteSubject csj = new ConcreteSubject(); csj.register(o1); csj.register(o2); csj.register(o3); csj.remove(o2); csj.change("new State！"); &#125;&#125; 输出结果 在运行时，这个客户端首先创建了具体主题类的实例，以及一个观察者对象。然后，它调用主题对象的register()方法，将这个观察者对象向主题对象登记，也就是将它加入到主题对象的聚集中去。 这时，客户端调用主题的change()方法，改变了主题对象的内部状态。主题对象在状态发生变化时，调用超类的notifyObservers()方法，通知所有登记过的观察者对象 拉模式结构说明 主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。 抽象观察者角色12345678public interface Observer &#123; /** * 传入主题，获取中的对象 * @param subject */ void update(Subject subject); String getName();&#125; 具体观察者123456789101112131415161718192021222324252627public class ConcreteObserver implements Observer &#123; private String name; private String state; public ConcreteObserver(String name) &#123; this.name = name; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; @Override public String getName() &#123; return name; &#125; @Override public void update(Subject subject) &#123; // 主动去主题里拿数据 state = ((ConcreteSubject) subject).getState(); System.out.println(getName() + "观察者状态更新为：" + state); &#125;&#125; 抽象主题角色1234567891011121314151617181920212223242526272829303132333435public abstract class Subject &#123; /** * 保存观察者的容器 */ private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); /** * 注册观察者 */ public void register(Observer o) &#123; list.add(o); System.out.println("增加了一个观察者:" + o.getName()); &#125; /** * 移除观察者 * * @param o */ public void remove(Observer o) &#123; System.out.println("移除了一个观察者:" + o.getName()); list.remove(o); &#125; /** * 通知观察者 * * @param newState */ public void nodifyObservers() &#123; for (Observer observer : list) &#123; observer.update(this); &#125; &#125;&#125; 具体主题角色123456789101112131415161718public class ConcreteSubject extends Subject &#123; /** * 状态 */ private String state; public String getState() &#123; return state; &#125; public void change(String newState) &#123; state = newState; System.out.println("状态变为：" + newState); System.out.println("开始通知观察者..."); this.nodifyObservers(); &#125;&#125; 测试12345678910111213public class MainTest &#123; public static void main(String[] args) &#123; Observer o1 = new ConcreteObserver("o1"); Observer o2 = new ConcreteObserver("o2"); Observer o3 = new ConcreteObserver("o3"); ConcreteSubject csj = new ConcreteSubject(); csj.register(o1); csj.register(o2); csj.register(o3); csj.remove(o2); csj.change("new State！"); &#125;&#125; 测试结果 两种模式的比较 推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。 推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。 参考链接]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者</tag>
        <tag>推模式</tag>
        <tag>拉模式</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Immutable Object(不可变对象)模式]]></title>
    <url>%2FImmutable-Object-%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1-%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[多线程下，一个对象会被多个线程共享，存在多线程并发地修改对象的属性，需要做些同步访问控制，如显示锁，CAS操作，会带来额外的开销和问题，如上下文切换、等待时间、ABA问题。Immutable Object模式意图通过使用对外可见的状态不可变的对象，使得天生具有线程安全性。 车辆管理系统状态可变的位置信息模型123456789101112131415161718192021public class Location &#123; private double x; private double y; public Location(double x, double y) &#123; this.x = x; this.y = y; &#125; public double getX() &#123; return x; &#125; public double getY() &#123; return y; &#125; public void setXY(double x, double y) &#123; this.x = x; this.y = y; &#125;&#125; 管理系统中会调用Location的setXY方法来更新位置，因为是非线程安全，并非原子操作，导致调用时会出现数据不一致的情况 改进：状态不可变的位置信息模型123456789public final class Location&#123; public final double x; public final double y; public Location(double x,double y)&#123; this.x = x; this.y = y; &#125;&#125; 使用状态不可变的对象时，更新信息模型时，如果车辆的位置发生变动，更新的是整个位置信息的对象 更新不可变对象的位置信息123456public class VehicleTracker&#123; private Map&lt;String,Location&gt; locMap = new ConcurrentHashMap&lt;String, Location&gt;(); public void updateLocation(String vehicleId,Location newLocation)&#123; locMap.put(vehicleId,newLocation); &#125; &#125; 一个严格意义上的不可变对象应该满足以下所有条件 类本身用final修饰 所有字段都是用final修饰，这个语意在多线程环境下由JVM保证了被修饰字段所引用对象的初始化安全，即final修饰的字段在其他线程是可见的，必定是初始化完成的。 在对象的创建过程中，this关键字没有泄露给其他类，防止其他类在对象创建过程中修改其状态 任何字段如果引用其他状态可变的对象，如集合数组，这些字段必须是private修饰的，不能暴露给外部，所有相关方法要返回这些字段值，应该防止防御性复制 实例： 某彩信网关系统 在处理由增值业务提供商VASP下发给手机终端用户的彩信信息时，需要根据彩信接收方号码的前缀选择对应的彩信中心MMSC，然后转发消息给选中的彩信中心。由其他系统将彩信信息下发给手机终端用户。选择彩信中心的过程称为 路由 ，手机前缀和彩信中心对应的关系叫路由表，在系统中多线程共享，很少改变此数据，不希望访问这些数据时进行加锁并发访问控制，避免产生不必要的开销，所以选择immutable object模型。 彩信中心路由规则管理器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/***彩信中心路由规则管理器**/public final class MMSCRouter&#123; // 保证多线程环境下该变量的可见性 private static volatile MMSCRouter instance = new MMSCRouter(); // 维护手机号码前缀到彩信中心之间的映射关系 private final Map&lt;String,MMSCInfo&gt; routerMap; public MMSCRouter()&#123; // 将数据库表中的数据加载到内存，存为Map this.routerMap = MMSCRouter.retrieveRouterMapFromDB(); &#125; private static Map&lt;String,MMSCInfo&gt; retrieveRouterMapFromDB()&#123; Map&lt;String,MMSCInfo&gt; map = new HashMap&lt;&gt;(); // 省略其余代码 return map; &#125; public static MMSCRouter getInstance()&#123; return instance; &#125; /** *根据手机号前缀获取彩信中心信息 **/ public MMSCInfo getMMSC(String msisdPrefix)&#123; return routerMap.get(msisdPrefix); &#125; /** *更新为指定的新实例 **/ public static void setInstance(MMSCRouter newInstance)&#123; instance = newInstance; &#125; /** *防御性复制 **/ private static Map&lt;String,MMSCInfo&gt; deepCopy(Map&lt;String,MMSCInfo&gt; m)&#123; Map&lt;String,MMSCInfo&gt; result = new HashMap&lt;String,MMSCInfo&gt;(); for(String key : m.keySet())&#123; result.put(key, new MMSCInfo(m.get(key))); &#125; return result; &#125; // 防止外部代码修改可变数据routerMap的值 public Map&lt;String,MMSCInfo&gt; getRouterMap()&#123; return Collections.unmodifiableMap(deepCopy(routerMap)); &#125;&#125; 彩信中心信息123456789101112131415161718192021222324252627282930public final class MMSCInfo&#123; private final String deviceId; private final String url; private final int maxAttachmentSizeInBytes; public MMSCInfo(String deviceId, String url, int maxAttachmentSizeInBytes)&#123; this.deviceId = deviceId; this.url = url; this.maxAttachmentSizeInBytes = maxAttachmentSizeInBytes; &#125; public MMSCInfo(MMSCInfo protoType)&#123; this.deviceId = protoType.deviceId; this.url = protoType.url; this.maxAttachmentSizeInBytes = protoType.maxAttachmentSizeInBytes; &#125; public String getDeviceId()&#123; return deviceId; &#125; public String getUrl()&#123; return url; &#125; public int getMaxAttachmentSizeInBytes()&#123; return maxAttachmentSizeInBytes; &#125; &#125; 彩信中心信息变更的频率也同样不高。因此，当彩信网关系统通过网络被通知到这种彩信中心信息本身或者路由变更时，网关系统会重新生成新的MMSInfo和MMSRouter来反应变更。 彩信中心、路由表的变更123456789101112131415161718public class OMCAgent extends Thread&#123; @Override public void run()&#123; boolean isTableModificationMsg = false; String updatedTableName = null; while(true)&#123; // 省略代码 从与OMC 连接中读取信息进行解析 // 解析到数据表更新信息后，重置MMSCRouter实例 if(isTableModificationMsg)&#123; if("MMSCInfo".equals(updatedTableName))&#123; // new MMSCRouter() 从数据库中加载变更的信息存入 MMSCRouter.setInstance(new MMSCRouter()); &#125; &#125; // 省略其他代码 &#125; &#125;&#125; 本列中MMSCInfo 是一个严格意义上的不可变对象，虽然MMSCRouter对象对外提供了setInstance方法用于改变静态字段instance的值，但它仍然可被视作一个等效的不可变对象。因为setInstance仅仅改变instance变量指向的对象，而instance变量采用volatile修饰保证了其余线程的可见性，所以无需加锁其他线程也能获取到最新的instance 总结Immutable Object 模型使用场景 被建模对象的状态变化不频繁 同时对一组相关的数据进行写操作，因此需要保证原子性 使用某个对象作为安全的HashMap的可以key。由于final不可变对象不变所有hashcode不变，所以适合作为HashMap 的key。 参考文献java多线程编程实战指南（设计模式篇）黄文海/著]]></content>
      <categories>
        <category>current</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>immutable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elasticsearch6 query 全文查询与词项查询]]></title>
    <url>%2Felasticsearch6-query-%E5%85%A8%E6%96%87%E6%9F%A5%E8%AF%A2%E4%B8%8E%E8%AF%8D%E9%A1%B9%E6%9F%A5%E8%AF%A2.html</url>
    <content type="text"><![CDATA[query全文查询 QueryBuilders.matchQuery(“filed”,”value”).operator(Operator.AND); // 对查询的语句进行分词，分词后的词任意一个匹配doc都能查出来 term query 查询的是词项&lt;分词后的&gt; （eg：Java编程思想） Java编程 term query 不能查到 分词后变成（Java 编程 思想） matchQuery能查到 QueryBuilders.matchPhraseQuery(“field”,”value”);对value进行分词，可以自定义分词器,满足两个条件才能被搜到： 分词后的所有词项都要匹配原字段 顺序还需要一致 QueryBuilders.matchPhrasePrefixQuery(“field”,”value”);与matchPhraseQuery类似,最后一个term支持前缀匹配eg.matchPhraseQuery 查 “hello word” matchPhrasePrefixQuery只需要查 “hello w”即可 QueryBuilders.multiMatchQuery(“value”,”field1”,”field2”); 多字段支持查询，字段可以使用通配符eg,{&quot;中国&quot;,&quot;tit*&quot;,&quot;wor?&quot;} QueryBuilders.commonTermsQuery(“哇”,”hehe”);通用查询，会自动分词为低频和高频项，先查低频，可以控制低频、高频出现概率 eg.the word the就是高频 ，可以先查 word QueryBuilders.queryStringQuery(“”);支持lucene查询语法 QueryBuilders.simpleQueryStringQuery(“”);支持lucene查询语法，具有非常完善的语法查询，解析过程中出现异常不会抛错 QueryBuilders.matchAllQuery();查所有和不写同样效果 词项查询 term query 词项检索 terms query 词项检索，可以多个词项，查到一个都能匹配结果 range query 查询范围内的 gt 大于 gte 大于等于 lt 小于 lte 小于等于 exist query 查询会返回字段中至少有一个非空空字符串也返回的doc prefix query 查询字段中给定前缀的文档 eg.{&quot;title&quot;:&quot;hel&quot;} wildcard query 查询字段通配符eg.&quot;{&quot;title&quot;:&quot;hell?/ *ell*&quot;} regexp query 正则匹配查询eg.{&quot;title&quot;:&quot;W[0-9].+&quot;} fuzzy query 模糊查询，最接近的查询，单词拼错一个字母的时候，消耗资源多 type query 指定类型的文档 ids query 查询具有指定id的文档]]></content>
      <categories>
        <category>elasticsearch6</category>
      </categories>
      <tags>
        <tag>elasticsearch6</tag>
        <tag>query</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new " My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1-Two Sum]]></title>
    <url>%2Fleetcode-1-Two-Sum.html</url>
    <content type="text"><![CDATA[description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. common method 1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] ret = new int[2]; for(int i =0; i&lt;nums.length-1 ;i++)&#123; for (int j = i+1 ;j &lt; nums.length ;j++ )&#123; if (nums[i] + nums[j] == target)&#123; ret = new int[]&#123;i, j&#125;; return ret; &#125; &#125; &#125; return ret ; &#125;&#125; best method1234567891011121314151617class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int len=nums.length; HashMap&lt;Integer, Integer&gt; map=new HashMap&lt;&gt;(); map.put(nums[0], 0); for(int i=1;i&lt;len;i++)&#123; if(map.containsKey(target-nums[i]))&#123; int[] returnArray=&#123;map.get(target-nums[i]),i&#125;; return returnArray; &#125; else&#123; map.put(nums[i], i); &#125; &#125; int[] returnArray=&#123;0,0&#125;; return returnArray; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arithmetic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello blog]]></title>
    <url>%2FHello-blog.html</url>
    <content type="text"><![CDATA[this is a first blog.It&#39;s a very exciting time make a plan execute have a harvest come on 12345public void start()&#123; while(true)&#123; System.out.println("struggle！"); &#125;&#125;]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>think</tag>
      </tags>
  </entry>
</search>
